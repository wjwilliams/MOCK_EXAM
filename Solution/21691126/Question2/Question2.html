<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Paged HTML Document" />




<meta name="author" content="Wesley Williams" />


<meta name="description" content="Paged HTML Document">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","bibliography":"Tex/ref.bib","date":"June 2023","output":{"pagedown::html_paged":{"self_contained":true,"toc":true}},"author":"Wesley Williams","abstract":"<p>This is an abstract. Much can be written here. Uncomment this line to go without an abstract.\nAbstracts have no spaces, but can have bullets.</p>\n<p>Bullets can be created as follows</p>\n<ul>\n<li><p>You can add bullets, but do not add colons please.</p></li>\n<li><p>Line breaks are also not permitted.</p></li>\n</ul>","title":"Paged HTML Document"}
</script>

<title>Paged HTML Document</title>


<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuw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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>



<style type="text/css">
h3.abstract{
text-align: center;
}
div.abstract{
margin: auto;
width: 90%;
}
</style>


</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Paged HTML Document</h1>
<h2 class="author">Wesley Williams</h2>
<h2 class="date">June 2023</h2>
</div>
<div class="abstract">
<h3 class="abstract">Abstract</h3>
<p>This is an abstract. Much can be written here. Uncomment this line to go without an abstract.
Abstracts have no spaces, but can have bullets.</p>
<p>Bullets can be created as follows</p>
<ul>
<li><p>You can add bullets, but do not add colons please.</p></li>
<li><p>Line breaks are also not permitted.</p></li>
</ul>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction </a></li>
<li><a href="#references" id="toc-references">References</a></li>
<li><a href="#appendix" id="toc-appendix">Appendix</a>
<ul>
<li><a href="#appendix-a" id="toc-appendix-a">Appendix A</a></li>
<li><a href="#appendix-b" id="toc-appendix-b">Appendix B</a></li>
</ul></li>
</ul>
</div>
</div>

<div class="main">
<!-- First: Set your default preferences for chunk options: -->
<!-- If you want a chunk's code to be printed, set echo = TRUE. message = FALSE stops R printing ugly package loading details in your final paper too. I also suggest setting warning = FALSE and checking for warnings in R, else you might find ugly warnings in your paper. -->
<!-- ############################## -->
<!-- # Start Writing here: -->
<!-- ############################## -->
<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction </h1>
<p>Table</p>
<pre><code>## % latex table generated in R 4.2.2 by xtable 1.8-4 package
## % Wed Jun 14 15:12:42 2023
## \begin{table}[ht]
## \centering
## \begin{tabular}{rlrl}
##   \hline
##  &amp; country &amp; Percent &amp; terms \\ 
##   \hline
## 1 &amp; France &amp; 0.27 &amp; tannins, smoke, smokey, ash, wooden and woody \\ 
##   2 &amp; Italy &amp; 0.40 &amp; tannins, smoke, smokey, ash, wooden and woody \\ 
##   3 &amp; South Africa &amp; 0.34 &amp; tannins, smoke, smokey, ash, wooden and woody \\ 
##   4 &amp; Spain &amp; 0.18 &amp; tannins, smoke, smokey, ash, wooden and woody \\ 
##   5 &amp; US &amp; 0.26 &amp; tannins, smoke, smokey, ash, wooden and woody \\ 
##    \hline
## \end{tabular}
## \end{table}</code></pre>
<pre><code>## \begin{table}[ht]
## \centering
## \begin{tabular}{rlll}
##   \hline
##  &amp; country &amp; Percent &amp; terms \\ 
##   \hline
## 1 &amp; France &amp; 26.402\% &amp; tannins \\ 
##   2 &amp; Italy &amp; 37.636\% &amp; tannins \\ 
##   3 &amp; South Africa &amp; 26.981\% &amp; tannins \\ 
##   4 &amp; Spain &amp; 12.385\% &amp; tannins \\ 
##   5 &amp; US &amp; 19.254\% &amp; tannins \\ 
##   6 &amp; France &amp; 1\% &amp; smoke, smokey and ash \\ 
##   7 &amp; Italy &amp; 3.808\% &amp; smoke, smokey and ash \\ 
##   8 &amp; South Africa &amp; 9.565\% &amp; smoke, smokey and ash \\ 
##   9 &amp; Spain &amp; 3.401\% &amp; smoke, smokey and ash \\ 
##   10 &amp; US &amp; 7.882\% &amp; smoke, smokey and ash \\ 
##    \hline
## \end{tabular}
## \caption{Long Table Example  \label{tab1}} 
## \end{table}</code></pre>
<p><img src="data:image/png;base64,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u82VV14ZEAwdOtQsuuiiwftSE9dcc4254447gixzzjmnGT58ePC+3ETfvn3Np59+6rKtvvrqZsCAAcEqLbn/BSs34USW7r218Le1816LFesigAACCCCAQLwAAaB4m6Ze8vTTTxv98l5rmjJlSq2bSHz9jz76yDz++ONuu5MmTSq5/W+++cb89a9/Ndttt53ZeeedS+YttXD69OnBPkvlK7dsxRVXNIMHDzYbbLBBuax1Wa5g2V/+8peibes8d+vWrWg+MxBoiUAWrrPu3bvnfeafe+45s99++1XEcfXVV5uXX345L+/bb79t9Pkvl3755RejAJKC1kq9e/fOW6Wa+1/eik36Jiv33lr529p5r9WL9RFAAAEEEEAgWoAmYNEuzM2AwJAhQ8wyyyxj9MtpWpo46SFwww03NKpd0Oj0r3/9y5x00kl5u+3atatZcskljWoorLDCCnnLeINASwSycp2p5o1q7/n0wgsv+MmSr99//70ZOXJkUZ5HH320aF7UjBdffDEI/mj55ptvHpWNeVUKtOa9t8qikh0BBBBAAAEEEKibADWA6kabng2vu+66Zo899mhRgRQYaNZ08sknJ1ILKur4Dz/8cLPvvvtGLQrm/fDDD+azzz4z7733ngtCTZw40S1TMErrqjmYAlSNSmrO52sVzDLLLObhhx82m266aaN2z37aiEBWrjM1Gd14443Nvffe685cpQGgJ554wsyYMcOto+azviamAkBRte8KLwvVNPLpD3/4g1lttdX8W16tQDPeezlxCCCAAAIIIIBAWgQIAKXlTNSxHKrZ8ac//amOe2jsps844wyj4I5SLf361FJq9QWiwFqlqX///uaAAw4wvhaAgkEXX3yxUb8ijUqff/55sKttt92W4E+gwUSSAlm6zhQg9QGgUaNGGQV155577pJc/jOuTOpXS/crpREjRhg17yoXVFcNKp+0/5lmyq+om4b7ny9fa7w24703Cae2ft6TMGQbCCCAAAIIIGBM/l+WiCDQBAKzzjqr6dSpk/s322yzNUGJjZl//vnNLbfcYhZeeOGgvDfddJOZPHly8L7eE+FOwZdYYol6747tt1GBLF1nf/zjH4OzqJp7ap5VLj322GNBloMOOsgsvvji7v20adOM+mYrldSn2b///e8gS1Tzr2a8/wUH1AoTabj3JnHYnPckFNkGAggggAAC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CADF0jT3gvPPPz8I/vTs2dPcfffdZplllok8qOeff9706dPHjBs3zqjWkGp+qEkYqe0KfP/99+7gFTiMShtttJGrVaZlK620UlGWcusXrcAMBBBAAAEEEEAAAQQQQACBugrQBKyuvK2zcTXzGjp0qNv5TDPNZB544IHY4I8ybbDBBuaOO+4wM888s1vnlltuccEg94b/EIgQWHTRRc0uu+zi/i255JIROZiFAAIIIIAAAggggAACCCCQJgECQGk6GwmVZezYsebnn392W1thhRXM4osvXnbL66+/vllnnXVcPo0QpqZhJAQQQAABBBBAAAEEEEAAAQQQyIYATcCycR7zjkIjf/nkA0H+fanX/fbbz40Kpn5f5pprrlJZzcsvv2xuuOEGM2rUKPPBBx+YLl26uJGnNPrUwQcfbBZccMHI9dW/0I033uiWDRgwwPUx88gjj7iOqJ999lmjpkMaoUxNjHbeeWc3apkya4QydWT99NNPm2eeecZMmjTJLLvssmbXXXc1hx56qIlrquQLoaDWtddea/7973+bN99803z22WeuVtTKK69sNt10U7Pjjjv6rC1+lbvKqBGyPv74Y/Pll1+aRRZZxKgJnv7tv//+ZuGFF47cfr9+/VxnyPPNN585++yzI/No5ltvvWU0gpbStttu6/65NzH/jRkzxgwZMsSdr/fff98oIKjOvnfaaSez1lprFa11/PHHu06dv/vuO7fs119/NYcffrib1ihyWq700ksvmeuvv95N77777maTTTZx05Wu7zJX8F8jzlsFxSALAggggAACCCCAAAIIIND8Ara5ECljAjYQkbMBGQ335f5dc801iR3h+PHjc/vuu2/OBlyC7fv9+Fc7tHzOBnki93n11VcH69n+hnLHHnts8N6v71+33HLLnI7FBgFye+21V2w+G8Bx+SJ3aGfaIFXOjoYWu772Z/tAytngU9wmys63o27lll9++ZL7sEG13M033xy5rU6dOrl1bXOqyOV+5r333hvs48wzz/Szg1c7LLtbrlcbUMt17do1yO9d9Wqb++UGDhyYs4G1YF1NqIzhfOFpG5QL8to+ooJ8l156aTC/0vUvuuiiYP2bbropWD880YjzFt4f0wgggAACCCCAAAIIIIBAlgWoAWSfcLOW1O+PasXYh2x3aKqRc9dddxnVMtHoTB06dGjRIauGy/bbbx80D1OtH71fbbXVzE8//WRefPFF89hjj5kffvjB2CCRq61y4YUXxu7rqKOOMqr90759e7P22msbNUP74osvzJ133mk0PP2jjz5qTjvtNPOf//zHdWK90EILudo6qiXzr3/9y7zyyituWHsNY2+DXO6YC3f23HPPudHPVGNIafXVVzdbbLGFWWyxxcy7777r9qHtq9aOajWpho2Oq5o0ffp05/Dee++51dZbbz2z3XbbGZXT70M1pX788Uez9957mznmmMPssMMO1eyi6ryqwbPZZpsZ1aDR+dlmm21ceVRzR/09ab46+x49enTQX5R2cuCBB7raVTZQZX755RfTsWNHc8ABB7j9qwZQuVTr+n77jThvfl+8IoAAAggggAACCCCAAAJtQiDL0a22fGy//fZbzgY7gloW9mJ207PNNltONWsuvvjinB32vWTNmUK/c845J9ietq0aPIXJNoHKde7c2eVTLRPtI5zCNYBUJtVUsc2xwllczRVfXv+655575mxAIi+fbSoVlEc1fAqTag6Fa+XYYFTR8drAUM4GOILtHHfccYWbKfveBr6C9f/0pz9F5rejsgV5bNCsKE/SNYC82wknnJCzAaq8/dngSlAzSDW5bNArb7ne2ACZK69qEEWluBpAPm+59UvVAGrUefNl5RUBBBBAAAEEEEAAAQQQaAsCM9kHRVIGBWaffXbXr46vveEPUTVhVLPGBgZczRD197Pbbru5GkKTJ0/22Ype1X/MWWed5earBsuDDz5oevToUZRPI0Ndcsklbr5qDB1xxBGulk5RRjtjlllmcX3mqJ+ccFIfQKpF45P6E7rqqquMDZL4We719NNPD/oaUk2WwqS+b3ytnIMOOsiceOKJRrWjwkk1XK677rqgA+zBgwe7Po3CecpNjxgxIsii449KxxxzjOsPSLWCVBNoypQpUdkSnacaQKoF5kd38xtXLbALLrjAvbU3OXPGGWf4Ral4bdR5S8XBUggEEEAAAQQQQAABBBBAoEEC+U/DDdopu2mMgJoyKbjxzjvvGFszJbIDYgUj1HGxOlNeZpllXFOrqNKpmZWaDSnZfnvM/PPPH5XNzVNnx8stt5yb1mhiH330UWReDT8fDvSEM/n1NU+dUyvoFJWWWmopN1udXavpWTj94x//CN7a2kvBdNSE79xYx3jLLbdEZYmdF+7wWsGLqOCO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u+3mCnzFFVeULPiLL77ogj/dunVzNZLkd8EFF5RcRwtXWWUV86c//cnVuCqbmQypE7j++uvN22+/nbpyUaDqBLbaaisX4FOQL+7ftddeW91GyY1ACwWa4bu5hYeWutWawbpv377u74Q555wzdX4UCIGkBKgBlJQk20EAAQRiBPTr4yOPPGJmmmkm8/DDD5tFFlkkL+eyyy5rbr/9drPJJpuY5557ztx1112J1HDI20mK3/iHvfPOO888//zzzkC1QHr27BlZ6rFjx7r5qqo999xzR+aJmqn8+kdCAIHWE9BndqWVVmq9ArBnBP4nwHdz4y6FZrGu5MekxqmxJwTqI0AAqD6ubBUBBBAIBF5//XWjfgf+8Ic/mO7duwfzwxMKDh100EEu+PHoo49GBoDU/Eo1IBQcUdMnNWVS8ydNFyY1n1F/PdqnasoUJjXHUDOvhRZayPWjo9pH6idBSW3033vvPTetplUqWzipCr2W67gWXHBB12Stc+fO4SwVT48YMcLVeFp66aXNEkssYVQLaNCgQWbIkCHm8ssvz9uO+mpRvw9qAqbky6nyqZzffvutUTMvGat/JTWtmzH1WlMlAABAAElEQVRjhqvx06FDB/Pdd9+5Wld6AFW5C5PyqkaCmgYtsMACZo011nDN9Arz+ffqs+mDDz4wH3/8sXNeaqmljIJ5s846q8/CawICut7k/P3337ut6Rzr+uvatWvR+dFDhmrQ/ec//3HNK3VN6ZzofJZKfh/Ko2txlllmKcqu60O1zdq1axcbnCxaiRk1C5T7XPsdVHPu/b1A9wHdD9TkY+TIkUb3Rd1X9a/U57iae4Xy6pp86623XHPDlVde2V2TagZMal2BpL6bW/commPvtVrr3qvvev3No+ZZ+p5+55133Hf5xhtvbEo1G63m3qDvGn0fhL8Har1fNMcZopRtSSD/r/q2dOQcKwIIINAggRVWWME9UOqPCPXxE5f22msvFyhSLaDCpBpE2o46J1RfQsqr97169XIPLoX5//nPf7rlatIVlY4++mi3/P7773eL//a3v5n111/fTSvQpG3r38SJE/NWHz16tAuM6Bf8Aw880GyxxRbuAaqlHSv72j877bST28+ee+7pXtUsrHDfChapTH//+99dHtWa0vvVVlvNvb/qqqvc+9tuu801pVNTk2222cYsvPDCrsmdtqn86ueoMB1//PEuiKNtqQNadSqtjrpPPfVUF2gK51cAasstt3SBJnXgrSrjasInE9Va+te//hXOznSNAvrc6LypE2+lyy67zL1Xp8LhdM0117iAkM7D7rvvbg499FBXq05BTjX9KzXajB4stt9+e7fduM/oE0884ZYfcsgh4d0yXWeBcp9r7b7acz9s2DB3Lu+44w5zySWXuHvYZptt5vqYUuBXAaC45obV3CsUqFx11VVdgFp9V+2zzz5uvwoCxW2/zpxsPiSg+4qCvbV8N4c2x2QJgVqt11xzTbPuuuu6QOqiiy7qpvXdq+9q1ar2f8sUFqHae8Naa63lPqP6UcynWu4Xfhu8IpAmAQJAaToblAUBBDIpoNoxCkYoaYQjtYNXQKcwwKGaPKq5UpieffZZF8jQr8jqHPnGG2806g9FQRP9WqU/ip588snC1ap6r5o3AwYMcOvol+lLL73U/VPNmXBSwEe/yPfr1889iK+33nquls0ZZ5xhrrzyynDWstOq0aMHMKX999/fva6zzjrulzd1jq1OscNJtXxULj2oK2nfel8YCFCA6OWXX3Z/xKkGiH4dLDyO8HYV5NFDoPKcf/75Lkh3xBFHuPfnnnuuUXDMJ/WTpIfDxx57zGy00UZGyxWIOvzww11tKgXI1EF1qWCD3xavlQmoLwad5w022MCtoKCe3ms0PZ8UgFRgRrU29FCgz4iuAzWrVHBHo+/94x//8NmLXlWr54ADDnDzb7rppqLlmqEAopK/Vt0b/muYQNznupZzr+tCIzAqYKi+xxQc1sOlapDpwVI1AcKpmnvFv//9bxewV80f3RNuvvlmd0/T9fPuu+8aPdD6jsjD+2C6cQK1fjc3rqTNv6ckrFWTWt+72pbu8fqx7C9/+YvR97KCq6olFE613BvC2/HT1d4v/Hq8IpA2geJ2A2krIeVBAAEEMiCgWimqtXPvvfca1XrRPwUcNOKX/qDZeuut3QNB4aGqmZZq2qi508UXX2z067NPqgl01llnmTPPPNNoGHVVhy4V6PDrRb0qSKLAhh5wFAA69thjo7KZ+eabz7z00ktBE6pjjjnGraNAyHXXXeceviNXjJip4I/+oNODUHgULz2In3LKKe6BTMEyn/RgpnKp+rd+7VPtp6hyahh71RJR2ZRU/Tsu3XnnnS6Io2ZyGv3DN5dTcE01ohSwU58AekhUFXP9mqjRx7RvBd18Mw49QOo8qEmJAmQKEO24445xu2V+FQKzzTabO89qaqc+ohT4C593nV/9Ya6kmm++M3G9P+6444xquyn4o8DOiSeeqNmRSQ/mOoc6dzqHamLmkz6HGp2uY8eObhQyP5/X6gUUnA1/rgu3oHuhAiaFKepzXeu5VyBGNYzCtbp0v1UNHTUH02dcQW+lau4VCuTr/qPy6R7dv3//4HBUE0j3D12LyvPCCy8Ey5hovEBLv5sbX9Lm32Ot1ho8Q028dQ/x/f/17t3b9OjRw+hHG33nqom8vpdrvTdEaVdzv4han3kIpEVgprQUhHIggAACWRbQQ6w6d1YtAtVKUE0F/TGjX7D0gKBqxwrAqEZPOKk/oE8//dT1GRF+6PV5FCjRHz96OHrggQf87Lq9nn766UHwx+9k5513dpPqn6eapGCKkgI+4aTAlmpt6Ndx/YpebVJ/L2ry45Me2uOSamIp6VdEH/zxedUcTX9UKoCgXxiV9GComlJ6aPTBH59//vnnd7Wx9N73V+OX8Vo/AQUR9RlSEDIc/PF79M0Ly50TNSPQZ1NNIFWrK5yGDx/uanXpAaNLly7hRUxXKaC+xnwQPOr11Vdfjdxi1Oe61nO/+OKLFwWjNE/3YqUxY8YEZanmXqFam3pI1cOqguqFSc1MdV/SiIbKR2o9gZZ+N7deiZt3z0lY628QH/zxEmruq7+DVEva/w1V673Bbzv8Ws39Irwe0wikTYAaQGk7I5QHAQQyK6Cgxr777uv+6Y8TBX+eeeYZNyy8+oNQDR7VhlFNBd/MyVdp3nTTTYsCDoJS/wWqvaMHFZ+3noDqULcw+cCJaklUmvRHmh5+VGNJv4iHkx6a1B+HamKoM2j1yVFNUieRatJTSVKnz0r6FbEwaRuqURJO6vNH/3xSExHZq8mIHuTUBExp+vTpPguvdRZQR+cK1IWTamnpYUCfqQcffNAtquScqPaHan3oM3jUUUcFm/TNvwqDlUEGJioWUK3HwvMVXll9hUSlqM91rec+apvat4KBqpmj2oY+VXOvUE1PpcVsP2KqtRaVdJwKduleKBNS6wm05Lu59Urb3Huu1Vr97xUm/Rijz5C+i1WTd/nll3d9+hXeZ1r6veD3V839wq/DKwJpFCAAlMazQpkQQCDzAmpOpKYO+qc+bFTTRc0i9MDqOyFWAMIHdfQgEZf0y5eSagHVOxUOYa/9+WCLmqlVmtRcTEkBlKgHPo3Ko6Qq42r6Ntdcc7n3lfynX+kqSarp4Uc7izquuG2oppP6oHnqqadc4Cf8kBg1IlvcdpifnICuI9WwU60yBVPHjx8fbLyac6LaQqrh44N56kNKTYEUrFVgUoFYUm0C+nyqll+1Ke5zXcu5jxsdzo8A5u9p1d4r/L1YQSQF6EslNW0kVS8Q7i9PzX1KJfUp55NqoZRKlX43l9oGyyoTqNZateZU0zYqabAHJfW5pf6AlGq5N7gNFPxX6f2iYDXeIpA6AQJAqTslFAgBBLImMHToUDd8uWoXLLnkkpGHp1ou+qVYf9xomGs1f9KIX344aj2AxCXf4bDPG5cvPF/Nz1qSCps9tWQbqonha1SoM8eomhn6415/1KujbHV4HdX8LW7f1fSDpD8QlUr5hvej86I+m9SBtR4SNWqYzpOajOhBT300xY1GEt4O08kJ6CFdAQU/SphG/VJTMI0GpnOja0wdpVeS9HCoGmnq0Fy1gNS5uTob1T70UJHE9V9JOchTLBD1ua713Ks2QqWpmnuFDxzpnqDOpEulVVZZpdRilsUIhJsBKcAT93Cu1b/66iu3FQUcwt+TtXw3xxSL2TECSVj7z1XULvygGvPMM49bXOu9IWof1dwvotZnHgJpESAAlJYzQTkQQCCzAnqYfP31112/NuERpQoPWDUPVBtGQQb1+6OH16WWWspl0/u45PveUQfNPvkH1bjAhvrhaK308MMPuxoa+gNeQ636X9sLy+M771UzsGoCQIXbiXuvBwF1LC0LDe2uDpwLk4Z0nzBhguujSYEFBfEU/FGH3ldffbUp/DXZ9xkyY8aMwk3xvk4C6pxZwR99fhR8K2zO54d1r/Sc6BzrM6t+fxQAUue/SjT/qtMJrGGzSZ/7uKJUe69Yeuml3aY0gp06IiclL9CpUyfXF4ya9ahz3qjmyX6vvmluYU3aWr6b/bZ5rUwgCWv9cPXNN99E1gJSTU0l/Sij1Kh7g9sZ/yHQZAKV//TRZAdGcRFAAIG0CKhjWSXVKFDAIy7pDxv1M6EmK76piW8epQdbX9MnvL5++fSdk4YffH2TKdUmKkzqfygqoOR/3ar0Qblwu5W+V8evSho5Ky74o+V+pCD1kaFOVeuRevbs6Tb70EMPRW7+pJNOMrvuuqurVq5OhNVET0mdDhcGf+SqfmeUomo1uQX812IBf336mhh+Q2qepbTtttsWBX80X31CKFV6TtQhu0al00OlmvmpSYHmlXrAdDvgv4YLJH3uSx1ANfcKf99WAFkjyhUm1VbQNbXOOuu4fuAKl/O+MgHfvO7vf/977GiP+tzrRwSl8Hek3tfy3az1SZULJGXt+3QL71nfzepPUWnVVVd1r428N7gd8h8CTSRAAKiJThZFRQCB5hTo16+f65BQQRf9caJgQ2GfBepzRMOO6+FWfyj5AM4OO+xg1ERAgSMNGxx++FXtHm1bf/yo00MfNJKSOitUuu+++1xQyb2x/2n9Pn36RD4M+z4V9Afz2LFj/SqJviog5YMt6hC7VNJxa9QtpSuuuKJU1hYv0yhqSpdffnnQH5DfmIap15D36mhWtvLx/cn4PzZ9Xp1Pddztm9YVnl+fj9eWC/iAm6/x5rekJl5KakJZGORRbbPzzz/fLa/mnKgWkNKRRx7pXjVEPCl9AvU493FHWc29YsMNN3RNRTV6YN++fYuC9wosjxw50gUZfY2FuP0yP17g8MMPdwt1n957771dbc5wbn2PqUmnamaqFld4dEjlq+W7ObwfpssLJGV99tlnu37Z/B51z1fTaw1CoR+Vunbt6hY18t7gy8IrAs0iQBOwZjlTlBMBBJpWQJ3H6o99BQjU6bBqKqiJlmoZqInAqFGjjO+kUoEGdXzsk2o9aCSqzTff3L0qUKRRMFRLRw+36vBWNRNUUyHct4G2o2YIqpGiXz232GILt68nnnjCDWm+1VZbBTWH/L7Ux4aaQam/BAVf1DGyhpYv1beCX7fSV/Wnoj/Y1KHreuutV3Y11QLSH+2qzq3gUVwHkGU3FJNBv8DrIUK/EGsENg39rs4ktT/V/JC/am75/kcUPLv55ptdME6/MCpop3Mg1y+++MI129PIPvUKoMUcRpuYrQ6ZlVSDTJ2m6/OkhwGdE3WkriYAqlWhodp1vnR+9LlQEFHnSDW09DmrZBh3BSdPPvlk9/nRtgpHqmsT4E1wkPU493GHXe29YvDgwUaBIDVBVH9Uul51j9Y9Vd8Dureo03L/oBq3X+bHC2i0SD38qwaQnPVP31e6V+h+rH/6rtT3rYL8+s4Np1q+m8PbYbq8QFLWqlGnoKm+q9Xfj2oEqdm8vr+HDRsWFKSR94Zgp0wg0CQC1ABqkhNFMRFAoLkFFPDQr5QallQPA6pJoiYmmqc+ZXr16mX0C7Oac4U7t9RRa3hTNT1SEEcPsueee64ZOHCgq/mjB9Wnn366KDCikbn0AKxgkR581Z+JRt7Sw4ZqryhwEZXUObOCQOr3Rn9U+VGyovK2ZJ5v/uVH6Si3Df2qqwdw1XZSnzv1SKpdpHKpTwk9kJ155pku+KMmHxqKPjzsrIJxvh8gBYJ0Pq+66ir3wKFzdMkll7giahjoUh1W1uM4sr5N9cGjzp312VFwTte9kprbaAQwjYanvrb69+9v/vrXv7ohthUY8rXrlFeBvUpSt27djIKkSqqFV/iZrGQb5Km/QD3OfalSV3OvUK1M3T932WUXNwiARjPUfVvzFGDXg6tqLJBqE5Drrbfe6oK/2pJqy44YMcKZ6x6sH08UoPe1hQr3Vst3c+G2eF9aIAlr/Y2ke/2gQYNcU2wF+fTdoNrOvpaoStHoe0PpI2cpAukSaGdvjpWP25uuslMaBBBoYoFFLj20KUr/eb+r6lJO1YLRUMGqkaARpHzzq3I7UxMjDQ2vYEXciGKF21CASQ8d+lXUV48uzFP4XsNo69dqNX9qS0m1n9RcQJ2F6hfLuKSmHRq+WcEI/arsawjF5a9l/hvbzFbL6g1bd5WHJjVkX1OnTnUPefqlP9yHlJo3qnmYzqGu9VprrunBXTUK9MARDgImdZAH7XVzUpuq63auvWXvum4/iY0nfe4rKVOl9wpty9/vdd/Qw6sCjEmnMe1OSnqTddtej9zAumxbP1yoQ391DD3vvPO62py+OXWlO/Tnqtrv5kq37/P1GbqAn0z96+2HxfddWEvhq7FWbWn9LaPzq+9m9Zmomrb6Qc33DxdVlta4N0SVg3kIpEmAAFCazgZlQaANCbT1AFAbOtUcao0CBIBqBGzB6nq4UFNAPagrIFjqAaMFm3erEABqqRzrRQkQAIpSSe88AkDVnZvCAFB1a5MbAQTCAvQBFNZgGgEEEEAAAQTapIB+8VeH6npVh+uqaXT00UfXJfjTJoE5aAQQQAABBBBodQECQK1+CigAAggggAACCLS2wKd2lD4/6pzKon6yjj322NYuFvtHAAEEEEAAAQQSEyAAlBglG0IAAQQQQACBZhVQv09rrLGG6z/kj3/8oznnnHPy+hhq1uOi3AgggECzC+y8885m8uTJeR09N/sxUX4EWkuAAFBrybNfBBBAAAEEEEiNgIaHHzlyZGrKQ0EQQAABBP4rcP3110OBAAIJCTAMfEKQbAYBBBBAAAEEEEAAAQQQQAABBBBIqwABoLSeGcqFAAIIIIAAAggggAACCCCAAAIIJCRAACghSDaDAAIIIIAAAggggAACCCCAAAIIpFWAAFBazwzlQgABBBBAAAEEEEAAAQQQQAABBBISIACUECSbQQABBBBAAAEEEEAAAQQQQAABBNIqQAAorWeGciGAAAIIIIAAAggggAACCCCAAAIJCbTL2ZTQttgMAggggAACCCCAAAIIIIAAAggggEAKBagBlMKTQpEQQAABBBBAAAEEEEAAAQQQQACBJAUIACWpybYQQAABBBBAAAEEEEAAAQQQQACBFAoQAErhSaFICCCAAAIIIIAAAggggAACCCCAQJICBICS1GRbCCCAAAIIIIAAAggggAACCCCAQAoFCACl8KRQJAQQQAABBBBAAAEEEEAAAQQQQCBJAQJASWqyLQQQQAABBBBAAAEEEEAAAQQQQCCFAgSAUnhSKBICCCCAAAIIIIAAAggggAACCCCQpAABoCQ12RYCCCCAAAIIIIAAAggggAACCCCQQgECQCk8KRQJAQQQQAABBBBAAAEEEEAAAQQQSFKAAFCSmmwLAQQQQAABBBBAAAEEEEAAAQQQSKEAAaAUnhSKhAACCCCAAAIIIIAAAggggAACCCQpQAAoSU22hQACCCCAAAIIIIAAAggggAACCKRQgABQCk8KRUIAAQQQQAABBBBAAAEEEEAAAQSSFCAAlKQm20IAAQQQQAABBBBAAAEEEEAAAQRSKEAAKIUnhSIhgAACCCCAAAIIIIAAAggggAACSQoQAEpSk20hgAACCCCAAAIIIIAAAggggAACKRQgAJTCk0KREEAAAQQQQAABBBBAAAEEEEAAgSQFCAAlqcm2EEAAAQQQQAABBBBAAAEEEEAAgRQKEABK4UmhSAgggAACCCCAAAIIIIAAAggggECSAgSAktRkWwgggAACCCCAAAIIIIAAAggggEAKBQgApfCkUCQEEEAAAQQQQAABBBBAAAEEEEAgSQECQElqsi0EEEAAAQQQQAABBBBAAAEEEEAghQIEgFJ4UigSAggggAACCCCAAAIIIIAAAgggkKQAAaAkNdkWAggggAACCCCAAAIIIIAAAgggkEIBAkApPCkUCQEEEEAAAQQQQAABBBBAAAEEEEhSgABQkppsCwEEEEAAAQQQQAABBBBAAAEEEEihAAGgFJ4UioQAAggggAACCCCAAAIIIIAAAggkKUAAKElNtoUAAggggAACCCCAAAIIIIAAAgikUIAAUApPCkVCAAEEEEAAAQQQQAABBBBAAAEEkhQgAJSkJttCAAEEEEAAAQQQQAABBBBAAAEEUihAACiFJ4UiIYAAAggggAACCCCAAAIIIIAAAkkKEABKUpNtIYAAAggggAACCCCAAAIIIIAAAikUIACUwpNCkRBAAAEEEEAAAQQQQAABBBBAAIEkBQgAJanJthBAAAEEEEAAAQQQQAABBBBAAIEUChAASuFJoUgIIIAAAggggAACCCCAAAIIIIBAkgIEgJLUZFsIIIAAAggggAACCCCAAAIIIIBACgUIAKXwpFAkBBBAAAEEEEAAAQQQQAABBBBAIEkBAkBJarItBBBAAAEEEEAAAQQQQAABBBBAIIUCBIBSeFIoEgIIIIAAAggggAACCCCAAAIIIJCkAAGgJDXZFgIIIIAAAggggAACCCCAAAIIIJBCAQJAKTwpFAkBBBBAAAEEEEAAAQQQQAABBBBIUoAAUJKabAsBBBBAAAEEEEAAAQQQQAABBBBIoQABoBSeFIqEAAIIIIAAAggggAACCCCAAAIIJClAAChJTbaFAAIIIIAAAggggAACCCCAAAIIpFCgfQrLRJFaKDB+/Hjz9NNPt3BtVkujwIwZM0wul3NFm3nmmdNYRMqEQMME9FnQZ0KpXbt2ZqaZ+A2jYfjsKJUCfEek8rRQqFYSCH9H6PtB3xMkBNqygP+O4G+m7F0Fa621llliiSVadGAEgFrEls6VRo8ebc4666x0Fo5SIYAAAggggAACCCCAAAIIIIBATQIDBgwgAFSTYMZWfuSRR0yPHj0ydlRt83AmTJhgpk+f7g6+W7du/JrVNi8Djvp/ApMmTTI//vije9epUycz55xzYoNAmxb45ptvzO+//+4MFlhggTZtwcEjMHHiRPPTTz85CH0/6HuChEBbFlDrENWMUw0gPUeQml9g8uTJZuWVV67pQKgBVBNfOlfWh5xqr+k8N9WWKnwuw9PVbof8CGRBIPwZCE9n4dg4BgRaIhD+HGiahEBbFij8PPCZaMtXA8cuAf8ZCH82kGlugSS6P6ADhea+Big9AggggAACCCCAAAIIIIAAAgggUFaAAFBZIjIggAACCCCAAAIIIIAAAggggAACzS1AAKi5zx+lRwABBBBAAAEEEEAAAQQQQAABBMoKEAAqS0QGBBBAAAEEEEAAAQQQQAABBBBAoLkFCAA19/mj9AgggAACCCCAAAIIIIAAAggggEBZAQJAZYnIgAACCCCAAAIIIIAAAggggAACCDS3AAGg5j5/lB4BBBBAAAEEEEAAAQQQQAABBBAoK0AAqCxRyzJMmTKl7IrK88MPP5hp06aVzUsGBBBAAAEEEEAAAQQQQAABBBBAoKUC7Vu6YlrX++6778wdd9xhRo8ebb7++msz33zzmR49epg+ffqYeeedt+pif/DBB+bOO+80n332mZljjjlMr169zCabbGIWX3zxyG3dfvvt5tZbbzUqx4ILLmiOOOIIs9FGG0XmPe+888xLL73kytulS5fIPMxEAAEEEEAAAQQQQAABBBBAAAEEahXIVA2gZ5991uy5557mlltuMa+++qqZOHGiee2114yCMnvvvbd56qmnqvIaPny4OfTQQ83jjz9uxo4da959911z/fXXm8MPP9y8/vrrRdt6+OGHzeDBg42COcrTrl07c/rpp7uyFGb++OOPXXl23313l79wOe8RQAABBBBAAAEEEEAAAQQQQACBpAQyEwBSgObcc881kyZNMgceeKB57LHHzF133eVe99tvPzd/4MCB5osvvqjI7p133jGXX365mXXWWc2AAQOMgjuPPvqoOeaYY9y2TjzxRDN+/Pi8bd18881mzjnnNEOHDnUBpyFDhphZZpnFDBs2LC+f3lxzzTUu7x577FG0jBkIIIAAAggggAACCCCAAAIIIIBAkgKZCQA98MADLjCz6aabmoMOOsh06NDBOelVtXjUDGvy5MlG+SpJqumTy+XMPvvsY3r37u1q8yiYs9tuu5ldd93V9dtz7733BpvStj///HOz5JJLBvuea665zMILL2w++eSTIJ8mRo0aZUaMGGH22msv16wsbyFvEEAAAQQQQAABBBBAAAEEEEAAgYQFMhMAeuONNxzNBhtsEEm01lpruflqelUuqenYyJEjXbYtttiiKLuf9+CDD5rp06e75b/99pt77dSpU17+2Wabzfzyyy9BPi286qqrzNxzz2122WWXvLy8QQABBBBAAAEEEEAAAQQQQAABBOohkJlOoNVcSx0vq9ZNVPr+++/d7Ljl4XXef/99V/tHtXfUkXNhWnbZZV3zrZ9++snV+lGH0PPMM49r7vXjjz/mZdcoX+p8un37/1IrUKX+idSUTMEhEgIIIIAAAggggAACCCCAAAIIIFBvgczUAFJTLwVrZp999iIz1dJ55JFH3Pzll1++aHnhDPUnpFQqWOSX+T6F1OHzSiut5Jp3jRkzxq3/1ltvma+++sqsuuqq7r3+U+0fBYR22GGHYB4TCCCAAAIIIIAAAggggAACCCCAQD0FMlMDqBTSlVdeab788kvTvXt3s80225TK6pb55lw+yBO1QufOnfPy6k3fvn3N0Ucf7TqhXmGFFczbb7/tgkjqg0jp5ZdfNupc+s9//rPrXNrNrPK/Sy+91Nxzzz2Ray222GJuvmpCRQXCIldiZqoFZsyYEZTv66+/dn1RBTOYQKCNCahfNp9+/fVXN9Kjf88rAm1RoPA7oi0acMwIeIHC7wj/97xfzisCbU3Afyb0qucIUvMLTJkyxR1E+Pu/2qPKfADotttuM/o300wzmVNOOcV07NixrJH6AFLSiF5xyff1o86ffVLTMNXw0bDzqvmjPn40/HzXrl1dkzItUy2lrbfe2q9ivv32W9d0TcEb33F1sDBi4ueffy4afcxnUzM0JV0QtVwUfnu8pktAN29/I09XySgNAq0jwH2uddzZazoF+Dyk87xQqtYR4G+m1nFnr+kV4DsiveemmpIlcR4zHQDScOw33nijC/6cdtppZsUVV6zId4455nD5pk6dGpvfR98KgzY9evQwJ510UtF6zz33nPnwww/Nqaee6voD0q/XZ5xxRtDZtIabV79A5ZqGaSSyuCCWlpEQQAABBBBAAAEEEEAAAQQQQACBQoFMBoCmTZtmBg4caB5//HHX1Kp///5mww03LDz22PeqsaOk2jZxSSN7KflgUVw+zVek7pprrjGLLrqo2XzzzV3WQYMGueDPTjvtZDRCmYadv+iii4xqAqkvobh08sknG/2LSi+88II56KCDXB9DCyywQFQW5jWZwIQJE4IR5Lp160YTsCY7fxQ3WYFJkyYZ39G+amGWqqWZ7J7ZGgLpFPjmm2/M77//7grH9346zxGlapyAavBrgBYlfT/42vqNKwF7QiBdAuPHj3etB9RXrZ4jSM0v4CuhqHVTS1PmAkAKzKiWjUbbUj89CgT16tWrKh8fAPJBnqiVfXBIw7mXS0888YT59NNPzdlnn+1qI6lN8mOPPebKdfzxx7vVl1xySbPrrru65mOlAkDl9sVyBBBAAAEEEEAAAQQQQAABBBBAoFAgUwEgBWXUjGr06NFmoYUWMhdccIHRUO7Vpvnmm8+tohG+VJuosGmVfl3QsPKKvC211FIlN68RyK699lqjAM9GG23k8qpDav1ip+HjfZp//vndLxV+VDE/n1cEEEAAAQQQQAABBBBAAAEEEECgVoGW1x2qdc8Jr6/O3tT3joI/yyyzjBkyZEiLgj8qljpqVofO6qfnlVdeKSrpM8884wI4ylNutK2HH37YdQh9yCGHBM13FBRSKuzLp3379ibcqXTRjpmBAAIIIIAAAggggAACCCCAAAIItEAgMwGgBx54wA2xruZbF154oenSpUtFHOo3R020xowZk5d/zz33dO+vu+46E24Kpvb2t956q1u222675a1T+EadSA8bNsz07NnTrLfeesFi305f2/JJ7flUg0nBJxICCCCAAAIIIIAAAggggAACCCCQpEAmmoApeKIaP0oaVl0dK8clNcW6+uqrg8WXXXaZGTdunDn00EONRvDySZ1GL7fccub99983qr2z8cYbu854n3zySTdsuwI6m2yyic8e+XrvvfcadeKr4efDScO1Kyj04osvuqCV9nPDDTe4zqKr6aw6vE2mEUAAAQQQQAABBBBAAAEEEEAAgTiBTASAVHsnXEvHj4gRddC++VXUsvC8mWee2WikrksuucSNJnbzzTe7xZqvzpr79u3r+gAKrxOe1mg1GoJ+5ZVXNquvvnp4kZvu16+fOeGEE8yRRx7pOqtW7Z811ljDbL/99kV5mYEAAggggAACCCCAAAIIIIAAAgjUIpCJAJD64nn++edb5HDHHXfErtehQwfXr9CJJ57o+hZSP0PqVLqSod8/+ugjs+6668bWRlKtHzUve+qpp1yNIr1XjaJahnSLPRAWIJBCgT5DF0hNqW4/bFxqykJBEEAAAQQQQAABBBBAAIF6CGQiAFQPmPA21TmzOpauJq244opG/0oljfy11157lcrCMgQQQAABBBBAAAEEEEAAAQQQQKBmgcx0Al2zBBtAAAEEEEAAAQQQQAABBBBAAAEEMipAACijJ5bDQgABBBBAAAEEEEAAAQQQQAABBLwA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/XXzuVmzZm77+YAAAggggAACCCCAAAIIIIAAAgggELiA9QTQuHHjJCQkRJYtWya33XabbNq0yUSpw8N+/OMfm+377rtPvv76ayktLZV///vfkpGRYfbHxMQEfke0gAACCCCAAAIIIIAAAggggAACCCDgJmA9AdS3b1954IEHzEVeffVVSUxMdF3wV7/6ldnWlcLatWsnV1xxhTmen59v9mvyiIIAAggggAACCCCAAAIIIIAAAgggYFfAegJIw3v88cdlypQpoit86RLvTrnlllvk/vvvNx9LSkrk4MGDziGZOHGi9O7d2/WZDQQQQAABBBBAAAEEEEAAAQQQQAABOwLuS3XZaVN0Uuenn35afv/738uWLVtcrerQsGeeeUbi4+NlxYoV8umnn4oO+xozZoxMmDDBVY8NBBBAAAEEEEAAAQQQQAABBBBAAAF7AkFJADnhNW/eXHRIWPlyzz33iL4oCCCAAAIIIIAAAggggAACCCCAAALBF7A+BOy5556TqVOnyvbt232O/ne/+53ccMMNZuiYzydREQEEEEAAAQQQQAABBBBAAAEEEEDAJwHrCaDXXntNUlNTJTc316cAtNJ7770nH374YbWSRj43TkUEEEAAAQQQQAABBBBAAAEEEEDgIhcI6hCwqmyLi4tFVwTbunWrqapzB1EQQAABBBBAAAEEEEAAAQQQQAABBOwKBJQAGjZsmGRmZrpFdP78efN5xIgR0qBB5R2MtK6uBuaUhIQEZ5N3BBBAAAEEEEAAAQQQQAABBBBAAAFLAgElgJ566im59tprxUn6lI3J076yx8tvx8XFyc9+9rPyu/mMAAIIIIAAAggggAACCCCAAAIIIBCgQEAJoC5dusjf/vY3+fjjj11hrFq1Svbv3y833XSTREdHu/Z72mjYsKE0bdpUOnbsKLfffru0atXKUzX2IYAAAggggAACCCCAAAIIIIAAAggEIBBQAkivO378ePNyYtBhYZoAuv/++0W3KQgggAACCCCAAAIIIIAAAggggAACF1Yg4ARQ+fDHjRtnlnS/+uqryx/iMwIIIIAAAggggAACCCCAAAIIIIDABRCwngAaPXr0BbgNLokAAggggAACCCCAAAIIIIAAAggg4E2g8mW6vJ3FfgQQQAABBBBAAAEEEEAAAQQQQACBOiNgvQdQ2Ts/dOiQ7Nq1SwoKCqSoqKjsIY/bsbGx0rlzZ4/H2IkAAggggAACCCCAAAIIIIAAAggg4J9AUBJAmvT5zW9+IytWrPAp8eOEnpycLLNmzXI+8o4AAggggAACCCCAAAIIIIAAAgggYEHAegLo5MmTkpiYKLt377YQHk0ggAACCCCAAAIIIIAAAggggAACCAQqYD0BlJKS4kr+6HCuO+64Qzp06CBt2rSRkJCQSuONiYmp9DgHEUAAAQQQQAABBBBAAAEEEEAAAQSqL2A9AZSVlWWi6N69u7z99tsSGRlZ/ag4AwEEEEAAAQQQQAABBBBAAAEEEEDAmoDVVcCKi4tl69atJrhf/vKXJH+sPSYaQgABBBBAAAEEEEAAAQQQQAABBPwXsJoACg0NlaZNm5potAcQBQEEEEAAAQQQQAABBBBAAAEEEEDgwgtYTQDp7fzoRz8yd5WXl2fe+QMBBBBAAAEEEEAAAQQQQAABBBBA4MIKWE8ADRw40NzRCy+8cGHvjKsjgAACCCCAAAIIIIAAAggggAACCBgB6wmgBx54QEaOHCnvvfeePPjgg6LLwlMQQAABBBBAAAEEEEAAAQQQQAABBC6cgPVVwLKzs2XixImyceNGefrpp+Wf//ynxMfHS/v27SUqKqrSO9XeQwMGDKi0DgcRQAABBBBAAAEEEEAAAQQQQAABBKonYD0BNHPmTFm5cqUrivz8fFm9erXrc2UbYWFhJIAqA+IYAggggAACCCCAAAIIIIAAAggg4IeA9SFgfsTAKQgggAACCCCAAAIIIIAAAggggAACQRSw3gNo6dKlUlRU5FfIjRs39us8TkIAAQQQQAABBBBAAAEEEEAAAQQQ8C5gPQEUERHh/WocQQABBBBAAAEEEEAAAQQQQAABBBCocYEaHQJ2+vRpOXXqVI3fJBdEAAEEEEAAAQQQQAABBBBAAAEELmaBoCaAdALo6dOnS79+/aRt27aivYOSk5ONd25urvTp00cyMjKkpKTkYn4G3DsCCCCAAAIIIIAAAggggAACCCAQVAHrQ8A02tLSUklNTZXZs2fLsWPHPN5AXl6eZGVlmdeYMWMkPT1dGjZs6LEuOxFAAAEEEEAAAQQQQAABBBBAAAEE/BcISg+gefPmybRp00zyR5d27969u8TExLhFqRNFOwmfxYsXS1JSkttxPiCAAAIIIIAAAggggAACCCCAAAII2BGwngDatm2bzJw500Q3bNgw2bt3r2zevFl0u2wZPHiwOabDwLRoD6Bdu3aVrcI2AggggAACCCCAAAIIIIAAAggggIAFAesJoLlz50phYaHp9bNs2TKJjo72Gma7du1kzZo1EhkZKcXFxTJ//nyvdTmAAAIIIIAAAggggAACCCCAAAIIIOCfgPUE0JYtW0wk2guoSZMmVUaldZzeQTk5OVXWpwICCCCAAAIIIIAAAggggAACCCCAQPUErCaAtBdPdna2iSA+Pt7nSIYOHWrq7t+/3+dzqIgAAggggAACCCCAAAIIIIAAAggg4JuA1QRQaGioWepdL338+HHfIviuli4Xr0WXiqcggAACCCCAAAIIIIAAAggggAACCNgVsJoA0tC6detmIszMzPQ5Up0HSEtcXJzP51ARAQQQQAABBBBAAAEEEEAAAQQQQMA3AesJoJ49e5orp6SkyJ49e6qMYsGCBbJq1SpTrzrDxqpsmAoIIIAAAggggAACCCCAAAIIIIAAAkbAegJoxowZoqt7nTx5UhISEiQtLU0OHjxYgXvfvn0yYcIEGT9+vDnWu3dvGTlyZIV67EAAAQQQQAABBBBAAAEEEEAAAQQQCEzAegKoZcuWsnDhQmnQoIGZBygpKUnatGljEkEa6pIlSyQqKko6dOhgln0vLS2V8PBw0Z5Aeg4FAQQQQAABBBBAAAEEEEAAAQQQQMCuQFAyLgMGDJANGzZIr169XNEWFhaa7QMHDsjhw4dd+wcNGiSbNm2SmJgY1z42EEAAAQQQQAABBBBAAAEEEEAAAQTsCYTZa8q9pR49esj69eslIyPDvOfk5Ii+tMdPbGysdO7cWTRRlJiY6H4inxBAAAEEEEAAAQQQQAABBBBAAAEErAoELQGkUYaEhMioUaPMy2rUNIYAAggggAACCCBQbwV+/twVtebelt57oNbEQiAIIIAAAggEIhCUIWBlAzp79mzZj67tjz76SAoKClyf2UAAAQQQQAABBBBAAAEEEEAAAQQQCI5A0BJAH3zwgdxyyy3ywx/+0GPkd955p1x22WUyduxYOXLkiMc67EQAAQQQQAABBBBAAAEEEEAAAQQQCFwgKAmgF198UXRy59dff112794t586dc4u0pKREdBn4M2fOyOLFiyU+Pl6ys7Pd6vABAQQQQAABBBBAAAEEEEAAAQQQQMCOgPUEkE70PGnSJDl//ryJcMiQIRUSQHpg+fLlcu+995ql3/Py8uQXv/iFaGKIggACCCCAAAIIIIAAAggggAACCCBgV8B6AmjOnDlSVFQkrVu3lszMTHnjjTckIiLCLeoGDRrIsGHD5O9//7u8/fbbEhYWJp988om8/PLLbvX4gAACCCCAAAIIIIAAAggggAACCCAQuID1BJAu/a7lnnvukYEDB1YZoS4FP2HCBFNv7dq1VdanAgIIIIAAAggggAACCCCAAAIIIIBA9QSsLgNfXFwsOpxLy+jRo827L3/06dNH0tLSZMeOHb5Up44XgdLSUnOksLDQzK/kpRq765CA80w1ZJ0zKyQkpA5FX3dCVVtK7RcoO5+cDjPmudX+Z0aEwRUo/zMiuFe7eFvn75q68ez5GVE3nhNRXhgB/h67MO62r6q/52sp+/O/utewmgDSX051eJcWHQbma3GWim/cuLGvp1DPg4DzhXDixAk5duyYhxrsqssCx48fr8vh1+rY+X6p1Y/HY3D6A9D5IeixAjsRuMgE+HsseA8c2+DZBqtl/d3C+f0iWNegXQTqioD+jsjfY3XlaVUep/NvX+f3/sprez5qNQGkyZ/o6GjZs2ePvP/++2Z1L8+Xdd+7bt06s+Paa691P8Cnagk4vUMuvfRSufzyy6t1LpVrp8CRI0dcydSoqCh6AAXpMfH9EiRYy83qP+Y1wa0lPDy8wvxyli9HcwjUeoHDhw+7FtDg77HgPS5sg2drs2Xt4XDy5EnTZNOmTUVfFAQuZoH8/HzTU0R/R9TfIyh1X8BJADm/9/tzR1YTQBrA8OHD5amnnpLk5GQz0XNsbGylcekk0Onp6aaOLgdP8V/A+ULQRFxoaKj/DXFmrRTQZ+o841oZYB0Oiu+XuvHwnB6mGi1/z9WNZ0aUwRUo+zOBv8eCZ41t8GxttszPCJuatFXfBPh7rH48Uec5lv35X907sz4J9OTJk0WHcmkGvlevXqKrgh06dMgtLu2ypHMFTZ06VRITE83/XiUkJFRr3iC3BvmAAAIIIIAAAggggAACCCCAAAIIIOBVwHoCKCYmRp599llzwaNHj8pjjz1mloTXpeC7du0qV111lTRp0kQ6duwoqampZhJP/bxo0SKzHLzXSDmAAAIIIIAAAggggAACCCCAAAIIIOCXgPUEkEahS8CvWLFCrrzySldQp0+flp07d8rnn3/uNnHnT3/6U9myZYt06dLFVZcNBBBAAAEEEEAAAQQQQAABBBBAAAF7AtbnAHJC07mAhgwZIjrHzxtvvGESPwcPHjQTd2ovIX3p8u8DBgxwTuEdAQQQQAABBBBAAAEEEEAAAQQQQCAIAtYTQLpKyyWXXGIm6NS5gLSHj74oCCCAAAIIIIAAAggggAACCCCAAAIXRsD6EDBd/at9+/Yyc+ZMKSgouDB3xVURQAABBBBAAAEEEEAAAQQQQAABBFwC1hNAL730knz55Zfy/PPPS6NGjVwXYgMBBBBAAAEEEEAAAQQQQAABBBBA4MIIWE0AFRcXS35+vrmT3r17i7NO/YW5Na6KAAIIIIAAAggggAACCCCAAAIIIKACVhNAmvDp27evkd24caOUlJSgjAACCCCAAAIIIIAAAggggAACCCBwgQWsJoD0XubMmSPNmzeXAwcOyIQJE+TEiRMX+Ba5PAIIIIAAAggggAACCCCAAAIIIHBxC1hfBaxly5aSlpYmjzzyiCxYsECWL18uXbt2lc6dO0uHDh3MCmHeyLX3kC4NT0EAAQQQQAABBBBAAAEEEEAAAQQQsCdgPQH00EMPycqVK10RHjt2TD788EPzcu30sjFr1iwSQF5s2I0AAggggAACCCCAAAIIIIAAAgj4K2B9CJi/gXAeAggggAACCCCAAAIIIIAAAggggEBwBKz3ANJl4AsLC/2KNiIiwq/zOAkBBBBAAAEEEEAAAQQQQAABBBBAwLuA9QRQq1atvF+NIwgggAACCCCAAAIIIIAAAggggAACNS5Qo0PATp8+LadOnarxm+SCCCCAAAIIIIAAAggggAACCCCAwMUsENQEUH5+vkyfPl369esnbdu2FR3ilZycbLxzc3PNhM8ZGRlSUlJyMT8D7h0BBBBAAAEEEEAAAQQQQAABBBAIqoD1IWAabWlpqaSmpsrs2bNFVwHzVPLy8iQrK8u8xowZI+np6dKwYUNPVdmHAAIIIIAAAggggAACCCCAAAIIIBCAQFB6AM2bN0+mTZtmkj9hYWHSvXt3iYmJcQuzqKjIlfBZvHixJCUluR3nAwIIIIAAAggggAACCCCAAAIIIICAHQHrCaBt27bJzJkzTXTDhg2TvXv3yubNm0W3y5bBgwebY3369DG7tQfQrl27ylZhGwEEEEAAAQQQQAABBBBAAAEEEEDAgoD1BNDcuXPNMvDa62fZsmUSHR3tNcx27drJmjVrJDIyUoqLi2X+/Ple63IAAQQQQAABBBBAAAEEEEAAAQQQQMA/AesJoC1btphItBdQkyZNqoxK6zi9g3JycqqsTwUEEEAAAQQQQAABBBBAAAEEEEAAgeoJWE0AaS+e7OxsE0F8fLzPkQwdOtTU3b9/v8/nUBEBBBBAAAEEEEAAAQQQQAABBBBAwDcBqwmg0NBQs9S7Xvr48eO+RfBdLV0uXosuFU9BAAEEEEAAAQQQQAABBBBAAAEEELArYDUBpKF169bNRJiZmelzpDoPkJa4uDifz6EiAggggAACCCCAAAIIIIAAAggggIBvAtYTQD179jRXTklJkT179lQZxYIFC2TVqlWmXnWGjVXZMBUQQAABBBBAAAEEEEAAAQQQQAABBIyA9QTQjBkzRFf3OnnypCQkJEhaWpocPHiwAve+fftkwoQJMn78eHOsd+/eMnLkyAr12IEAAggggAACCCCAAAIIIIAAAgggEJiA9QRQy5YtZeHChdKgQQMzD1BSUpK0adPGJII01CVLlkhUVJR06NDBLPteWloq4eHhoj2B9BwKAggggAACCCCAAAIIIIAAAggggIBdgaBkXAYMGCAbNmyQXr16uaItLCw02wcOHJDDhw+79g8aNEg2bdokMTExrn1sIIAAAggggAACCCCAAAIIIIAAAgjYEwiz15R7Sz169JD169dLRkaGec/JyRF9aY+f2NhY6dy5s2iiKDEx0f1EPiGAAAIIIFADArkhj9bAVXy7RMfSP/pWkVoIIIAAAggggAACCPgpELQEkMYTEhIio0aNMi8/4+M0BBBAAAEEEEAAAQQQQAABBBBAAIEABawOATt+/LhkZWVJbm6u6ekTYGycjgACCCCAAAIIIIAAAggggAACCCBgQcBKAuipp56SuLg4iYyMlD59+kinTp2kefPmcv/995uJoC3ESRMIIIAAAggggAACCCCAAAIIIIAAAn4KBJQAOnv2rIwdO1amT58u2dnZUlJS4grj1KlT8uyzz0qXLl1k+/btrv1sIIAAAggggAACCCCAAAIIIIAAAgjUrEBACaAnn3xSFi9e7Iq4devWcscdd8iQIUOkRYsWZv8333wjDzzwgKsOGwgggAACCCCAAAIIIIAAAggggAACNSvgdwJIV/NKT0830YaGhsprr70musS7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AggggAACCCCAAAJ2BYKScRkwYIBs2LBBevXq5Yq2sLDQbB84cEAOHz7s2j9o0CDZtGmTxMTEuPaxgQACCCCAAAIIIIAAAggggAACCCBgTyDMXlPuLfXo0UPWr18vGRkZ5j0nJ0f0pT1+YmNjpXPnzqKJosTERPcT+YQAAgjUcYHoeRNrzR3sn/p8rYmFQBBAAAEEEEAAAQQQQODCCQQtAaS3FBISIqNGjTKvC3eLXBkBBBBAAAEEEEAAAQQQQAABBBC4uAWCMgTMH9ItW7bIq6++6s+pnIMAAggggAACCCCAAAIIIIAAAgggUImA1QRQcXGxFBQUVHK5iofOnDkjjz76qOiQsW3btlWswB4EEEAAAQQQQAABBBBAAAEEEEAAgYAEAk4AFRUVmRW+rrvuOmncuLFERERIp06dZMqUKWYVsMqie+edd+Taa6+VJ554QrQdCgIIIIAAAggggAACCCCAAAIIIICAfYGAEkCnTp2Sm2++WXSp961bt5okjk7ynJubK//zP/8jXbt2lT179lSI+tixYzJ+/HjRFcDKHtfl4SkIIIAAAggggAACCCCAAAIIIIAAAnYFAkoA/eY3v5G33nrLFZEmcLT3j1N0yfe7775bSkpKnF2yc+dOuf766+XFF1907Wvbtq387//+r9x///2ufWwggAACCCCAAAIIIIAAAggggAACCNgR8DsBpHP9PPvssyaK5s2bm+XeDx06JHv37pXdu3dL//79zbF169bJ8uXLzfbq1aulV69eZjl43aGrhE2ePFm2b98uI0aMMHX4AwEEEEAAAQQQQAABBBBAAAEEEEDAroDfy8B/9NFHcv78eRNNcnKy3Hrrra7IOnfuLEuXLpXu3bvL119/bXoJtWnTRn7605+KThStJTY2VubPny+9e/d2nccGAggggAACCCCAAAIIIIAAAggggIB9Ab97AH3++eeuaO69917XtrNx+eWXy8SJE83HN998UyZNmmSSP9rrZ9q0aWbOIJI/jhbvCCCAAAIIIIAAAggggAACCCCAQPAE/O4BdPz4cROVzvujK395Kt26dTO7dVJoLeHh4bJs2TIzcbTZwR8IIIAAAggggAACCCCAAAIIIDcSnTQAAEAASURBVIAAAkEX8DsBpCuAaWndurXXIFu2bOk61qRJE3njjTdccwO5DrCBAAIIIIAAAggggAACCCCAAAIIIBBUAb+HgOly71p0SJe30qhRI9chHQLmTAzt2skGAggggAACCCCAAAIIIIAAAggggEDQBfxOAFU3ssTExOqeQn0EEEAAAQQQQAABBBBAAAEEEEAAAQsCNZYAatWqlYVwaQIBBBBAAAEEEEAAAQQQQAABBBBAoLoCNZYACg0NrW5s1EcAAQQQQAABBBBAAAEEEEAAAQQQsCBQYwkgC7HSBAIIIIAAAggggAACCCCAAAIIIICAHwJ+rwLmXKuoqEjy8/Odj27vR48edX3WbW/1nEpNmzY1S8U7n3lHAAEEEEAAAQQQQAABBBBAAAEEEAhcIOAE0I4dO+Tyyy+vMpJ+/fpVWWfWrFmSnJxcZT0qIIAAAggggAACCCCAAAIIIIAAAgj4LsAQMN+tqIkAAggggAACCCCAAAIIIIAAAgjUSQG/ewBdffXVYntpd22TggACCCCAAAIIIIAAAggggAACCHgS+PlzV3jafUH2Lb33wAW5rr8X9TsBNHr0aNEXBQEEEEAAAQQQQAABBBBAAAEEEECgdgswBKx2Px+iQwABBBBAAAEEEEAAAQQQQAABBAIWIAEUMCENIIAAAggggAACCCCAAAIIIIAAArVbgARQ7X4+RIcAAggggAACCCCAAAIIIIAAAggELEACKGBCGkAAAQQQQAABBBBAAAEEEEAAAQRqtwAJoNr9fIgOAQQQQAABBBBAAAEEEEAAAQQQCFiABFDAhDSAAAIIIIAAAggggAACCCCAAAII1G4BEkC1+/kQHQIIIIAAAggggAACCCCAAAIIIBCwAAmggAlpAAEEEEAAAQQQQAABBBBAAAEEEKjdAiSAavfzIToEEEAAAQQQQAABBBBAAAEEEEAgYAHrCaDnnntOpk6dKtu3b/c5uN/97ndyww03yOOPP+7zObW9YmFhYZUhap2jR4/K+fPnq6xLBQQQQAABBBBAAAEEEEAAAQQQQMBfgTB/T/R23muvvSYrV66UwYMHyzXXXOOtmtv+9957Tz788EO56qqr3Pb780GTKhkZGbJp0yaTXOncubNcd911MnToUAkNDa1Wk++++6589tlnXs+57LLLZOzYsW7Hly5dKkuWLJFvv/1W2rZtK0lJSdK/f3+3Os4HTXjpfb/yyivSokULZzfvCCCAAAIIIIAAAggggAACCCCAgFUB6wmg6kRXXFwsOTk5snXrVnNaeHh4dU6vUPfYsWNy3333yRdffGGORUZGyurVq81r/fr1kpycLJdcckmF87zt0GTWJ5984u2wdOrUyS0BpImvZ555xuwfNWqU/Pvf/5bHHntM5s6dKwkJCW7t7NmzRzIzM+Xuu+8m+eMmwwcEEEAAAQQQQAABBBBAAAEEELAtEFACaNiwYSaJUTYoZzjTiBEjpEGDykeYad2SkhLX6eWTJK4DPm7oUDJN/vTs2dMkXrRXzVdffSW//vWv5f3335e//vWvMn36dB9bE5Oc0soPPvigNGrUqMJ5zZo1c9v38ssvi+7TYXBaX31Gjhwp6enpFRJA8+fPN3VHjx7t1gYfEEAAAQQQQAABBBBAAAEEEEAAAdsCASWAnnrqKbn22ms9zmHjJIJ8DTguLk5+9rOf+Vq9Qj2dc2jjxo3SpEkTmTNnjjRu3NjUufLKK+Uvf/mLScSsWrVKJk2aZBIvFRoot+PQoUNy4sQJufTSS0V781RVzp49K/v375fu3bu7kkUtW7aUdu3ayeeff+52usaalZVlYmnatKnbMT4ggAACCCCAAAIIIIAAAggggAACtgUCSgB16dJF/va3v8nHH3/sikuTLJoIuemmmyQ6Otq139NGw4YNRRMgHTt2lNtvv11atWrlqZpP+3QeIS39+vVzJX/Mju/+0KFg119/vZlvR+PTa1VVdGialquvvrqqqub46dOnzXtERIRbfU1InTx5UoqKiiQs7P+4n3/+eXOvt956q1tdPiCAAAIIIIAAAggggAACCCCAAALBEAgoAaQBjR8/3ryc4HTYkyaA7r//fjMEytkf7Pfs7GxzCR3+5ak4CSCd1NmfBJAmcLRHkCaTPBXdrwktnYeobNFVvqKiolzJn08//dRMUK3DyjQ5REEAAQQQQAABBBBAAAEEEEAAAQSCLRBwAqh8gOPGjTNLuvvac6b8+f5+1rl+tOiwK0/F2e9MEO2pTtl9Tg8gTfxMmzZNNHGjk1brHD89evQw8wLp8DCnhISESLdu3Uy93Nxc06tJJ7f++uuvZciQIU410d4/mhAaPny4a191NvQ+Dx8+7PEUvZYWHX537tw5j3XYWbcESktLXQHrM9WvM4p9gfr8/VKf7k3/PnaK/n1cn+6tPt2L84x4D75A+Z8Rwb/ixXkFvj/rxnOvzz8jatMT4PuhNj0N32PhufluVd2aNWnrXKvsz//qxms9AXShJjV2hmA5iZ7yEM2bNze7nHrlj5f/rKt0aVm0aJFZPl6Hu+kPFp3P55133jG9eFJTUyUmJsZ1qs4vNGXKFLnnnntE5zTS3kYaz8SJE02dDRs2yLZt2+Thhx+u1mpkrgt8t6GTR+tk057KNddcY3ZrLyRdhp5SvwSOHDlSv26oFt1Nff5+qa/3dubMGdFXfSn19TnVl+dTF+6Dr6HgPSVsg2cbrJYLCgpEXxT7Anw/2DcNdouaLOC5BU+5Jm0LCwvNjQSSAKp8ma7gOVltWVcS00mYtZRfmcu5kDM3j4Pm7Pf0rkkipzeN9t7ReYPS0tLkhRdekJdeekk00aLDwf7whz+YpJDThiaJtIfP0KFDzQpoOsfPggULpHXr1qIPSY+1bdtWbr75ZucU05tn165d4ktcrpPYQAABBBBAAAEEEEAAAQQQQAABBKoh4HcPIO0F8/bb/1979wEnVXX2cfxBmgKCAip2omIvmGBXJJrYew9oomIhaoyIImoUxF5iNxYiWIIFLNiw90JsIRbUaBQLYhcrSJ33/I/vubk7O7M7M3t35s7s73w+sDO3nHvu987O7H3mOec84g+lIIkGX1a5/vrrTQGNUsrWW29t+lds0XTzGk9H3wbnC6SE5e3atWu0etV10003+eBM796963S7UQBn5MiRNmDAAD9NvGYe23TTTaM6NaD1sGHDoufhwZNPPmlvv/22n5Jeg0H/8MMPNnz4cD9zmbZRuzQuUGNdwzTrmvbNVVSHZhjTDGiML5RLqPqWKbAZIry6rnQBa55rWMu/L7V0bsrCDDNM6n1U4641pfz8tUFTakhu31q6TsmpUFNjAvHPCF5DjWmVvh7b0u3KuWfSnxHlbHs1HYvfh+q5WvFMaa5b8123ctoq7tHUUnIA6Omnn7azzz7bH79Lly5RAGjcuHE2ceLEktrVvn37kgJAOlj37t1N4/toxq1cJSwvZNp1wWr6dv3LVZTRs8466/huYOoSFg8A5dpeGUrqurXiiivaNtts4ze57LLLfPBn9913Nw1crcDZBRdcYD179vRjCeWqR8t22203/y/X+meffdbGjx/vs6DydYXLtR/L0ivwxRdfRFlmuqYEgJrnWtXy70stnZv+kAkD7Ssgmi/js9BXyYxCNyzDdrV0ncrAxSH+X+Dzzz/34xPqKa+h5ntZYNt8tknWrC5f3377ra9SN2Qh+z/JY1AX7zXV9BoIXxLo/oH3sea7cuW0DUktTQkENT2E1HyWRdWsAJBKCPRk76wuWypNmWo+XueSSy7pnxbS5+/hhx+2999/38+WpoulLmYPPvigDyIde+yxttlmm9npp5/u67v11lvjh+ExAggggAACCCCAAAIIIIAAAggg0GSBkjOATjzxRFPwQkWZO6HcdtttUcZCWFboz3g9he4TtgsBGWXkbLzxxmFx9FPLVdZYY41oWb4H6sKmAZs7dOhge++9d87N9K2bynLLLZdzfViodNTRo0f7waL79evnF0+bNs1/Y7fSSiuFzfw4QfqmotBZyqIdeYAAAggggAACCCCAAAIIIIAAAgg0IlByAEjjzeQaT6ecfeDi56axg5RVo3GJ+vfvH19l6oKlMYtUNKZPY2XGjBl+wGely2244Ya+61Z8H83GNGXKFL9orbXWiq+q91jd4TSg9DnnnBN131FQSEVdGOJFY1qEwazjy3mMAAIIIIAAAggggAACCCCAAAIINEWgZrqAKetH4+e88847ftauOIqmTVdXLY3Bo/F24kXj5qiL1tSpU6PFChKpL58G373uuuvqZDQpQHPuuef6AafVdUszf+Urc+bM8ftr1jBtG8rSSy/tH4YsIj1Rfz51U9Mg0xQEEEAAAQQQQAABBBBAAAEEEEAgSYGSM4DyNUIBmDBIZ75t8i1fdtllSw6AKFvn0EMPtVNPPdVPzz5p0iTr1auXvfbaa6bHmi1m6NChURZOaMMll1xin3zyid9XM3ipKDNHM3Spi5syil5++WU/eHPr1q3tqaeeMnXh0raDBw8O1eT8OWHCBNMgvieddFKd9V27dvVTyT/33HO+feqWdsMNN/hMpTCbWp0deIIAAggggAACCCCAAAIIIIAAAgg0QSDxANAxxxxT8ixgI0aM8IGXUs+nb9++dtFFF/kA0OOPP276p6LMIAVrNIV6oaVPnz525ZVXmgJEb775poXBmdXFTdPeKzikMYLyFc1Wc+ONN/ouZ6oru8hpyJAhdsQRR1jnzp199s8GG2xgu+yyS/amPEcAAQQQQAABBBBAAAEEEEAAAQSaJJB4AKhJrUlg5/XXX99Pha4uXxpQWYND9+jRw/JNlaZp6/MVje9zzTXX+CklVZemHNbU8PnqitejTChND69p3nMVZf2MGTPGHn30Ud89Tc+32mqrgurOVR/LEEAAAQQQQAABBBBAAAEEEEAAgXwCiQeAlBmz77775juen/1KY91ozJ27777b/9xhhx1s1KhRPhMm745FrujWrZvpXxKlS5cupn/FFGUbNZZxtNRSS9UbsLqYY7AtAggggAACCCCAAAIIIIAAAgggUIhA4gEgzcZVaBk5cqTtsccevsvY+eef77tvFbov2yGAAAIIIIAAAggggAACCCCAAAIIFCZQ0VnANPaNpknXzFcXX3xxNFV7YU1nKwQQQAABBBBAAAEEEEAAAQQQQACBQgQqGgBSA9u1a+dn2NLjJ598Uj8oCCCAAAIIIIAAAggggAACCCCAAAIJClQ8AKRzWXvttf0pPf300wmeGlUhgAACCCCAAAIIIIAAAggggAACCEggFQGgJ554wl+Ntm3b+p/8hwACCCCAAAIIIIAAAggggAACCCCQnEDFA0AaA+iRRx7xZ9SnT5/kzoyaEEAAAQQQQAABBBBAAAEEEEAAAQS8QOKzgN1xxx323nvvNcg7b948mzlzpk2ePNnuvfdev22rVq1s++23b3A/ViKAAAIIIIAAAggggAACCCCAAAIIFC+QeADo2muv9TN7FduUoUOH2uabb17sbmyPAAIIIIAAAggggAACCCCAAAIIINCIQOIBoEaOV2/1+uuvb0cccYQdeOCB9daxAAEEEEAAAQQQQAABBBBAAAEEEECg6QKJB4DGjBljs2bNarRlGvB5scUWsw4dOjS6LRsggAACCCCAAAIIIIAAAggggAACCJQukHgAqHPnzta9e3dbaKGKjy9dugp7IoAAAggggAACCCCAAAIIIIAAAjUkkHiUZvjw4bbiiivaiSee6Ad6riErTgUBBBBAAAEEEEAAAQQQQAABBBCoSoHEM4D+8Y9/2PTp023UqFF2xhlnVCUKjUYAAQQQQAABBJpb4OD+Y5v7EAXXP/qmAQVvy4YIIIAAAgggUJ0CiWYAzZ8/37744gsvoRm9WrduXZ0qtBoBBBBAAAEEEEAAAQQQQAABBBCoIYFEA0AK+PTt29fzvPDCC7ZgwYIaouJUEEAAAQQQQAABBBBAAAEEEEAAgeoUSDQAJAJ1+9JA0J988okdcsgh9t1331WnDK1GAAEEEEAAAQQQQAABBBBAAAEEakQg8TGANLX7VVddZUOHDjVNCX/nnXfaGmusYb169bKePXtau3bt8tIpe2iLLbbIu54VCCCAAAIIIIAAAggggAACCCCAAALFCyQeABoyZIhNnDgxask333xjkyZN8v+ihXkejBgxggBQHhsWI4AAAggggAACCCCAAAIIIIAAAqUKJB4AKrUh7IcAAggggAACCCCAAAIIpEFgaqthaWjGz224Oj1NoSUIIFDdAokHgDQN/OzZs0tS6dSpU0n7sRMCCCCAAAIIIIAAAggggAACCCCAQH6BxANAiy++eP6jsQYBBBBAAAEEEEAAAQQQQAABBBBAoOwCic8CVvYz4IAIIIAAAggggAACCCCAAAIIIIAAAg0KlJwB9MADD/jBnlu3bm0XXXRRgwdhJQIIIIAAAggggAACCCCAAAIIIIBA5QRKzgB6/vnn7bLLLrPLL788b+vnzp1rM2fOtFmzZuXdhhUIIIAAAggggAACCCCAAAIIIIAAAs0rUHIAqJBmnXbaadaxY0fr1q1bIZuzDQIIIIAAAggggAACCCCAAAIIIIBAMwg0awCoGdpLlQgggAACCCCAAAIIIIAAAggggAACRQoQACoSjM0RQAABBBBAAAEEEEAAAQQQQACBahMgAFRtV4z2IoAAAggggAACCCCAAAIIIIAAAkUKEAAqEozNEUAAAQQQQAABBBBAAAEEEEAAgWoTIABUbVeM9iKAAAIIIIAAAggggAACCCCAAAJFCrQpcns2RwCBKhWY2mpYulp+dbqaQ2sQQAABBBBAAAEEEEAAgVoWIABUy1eXc0MAgRYvMHnHRVJjsP59s1LTFhqCAAIIIIAAAggggEBLE6ALWEu74pwvAggggAACCCCAAAIIIIAAAgi0OIFEMoBeeeWVnHCfffaZX57JZCzfNvEde/ToYUsttVR8EY8RQAABBBBAAAEEEEAAAQQQQAABBJoo0OQA0Lx586x3794NNuOnn35qdBtVMGLECBs+fHiDdbESAQQQQAABBBBAAAEEEEAAAQQQQKA4AbqAFefF1ggggAACCCCAAAIIIIAAAggggEDVCZScAdSnTx8bNGhQoiesOikIIIAAAggggAACCCCAAAIIIIAAAskKlBwA2nHHHU3/KAgggAACCCCAAAIIIIAAAggggAAC6RYoOQCU7tOidQgggAACCCCAAAIIIIAAAghUp8DB/cempuGjbxqQmrbQkKYJMAZQ0/zYGwEEEEAAAQQQQAABBBBAAAEEEEi9AAGg1F8iGogAAggggAACCCCAAAIIIIAAAgg0TYAAUNP82BsBBBBAAAEEEEAAAQQQQAABBBBIvQABoNRfIhqIAAIIIIAAAggggAACCCCAAAIINE2AAFDT/NgbAQQQQAABBBBAAAEEEEAAAQQQSL0AAaDUXyIaiAACCCCAAAIIIIAAAggggAACCDRNgABQ0/zYGwEEEEAAAQQQQAABBBBAAAEEEEi9QJvUt5AGIoAAAggggAACCCCAAAIIIIBARQSmthpWkePmPejVedewohEBMoAaAWI1AggggAACCCCAAAIIIIAAAgggUO0CBICq/QrSfgQQQAABBBBAAAEEEEAAAQQQQKARAQJAjQCxGgEEEEAAAQQQQAABBBBAAAEEEKh2AcYAqvYrmIL2r3DxoSloxf+a8OExo/73hEcIIIAAAggggAACCCCAAAIIIGBkAPEiQAABBBBAAAEEEEAAAQQQQAABBGpcgABQjV9gTg8BBBBAAAEEEEAAAQQQQAABBBAgAMRrAAEEEEAAAQQQQAABBBBAAAEEEKhxAcYAqvELzOkhgAACCCCAAAIIIJB2gYP7j01VE09JVWtoDAIIIJCMABlAyThSCwIIIIAAAggggAACCCCAAAIIIJBaAQJAqb00NAwBBBBAAAEEEEAAAQQQQAABBBBIRoAAUDKO1IIAAggggAACCCCAAAIIIIAAAgikVoAAUGovDQ1DAAEEEEAAAQQQQAABBBBAAAEEkhFgEOhkHFNRSyaT8e2YO3euzZkzJxVtqkQjauncwzWVo86rVatWlSCt+WPW0msmzRerqc7z5s2LTm/+/Pk19T7XVJsIhgcIlCjAazA/HDb5bVjT8gT4fWh515wzblignL8T4Vjxe8SGW1d/LQGg+iZVuyS8EL755hv76quvqvY8mtrwWj33r7/+uqk07J9HoFZfM3lOt2KLk3SeNWuW6V+tlCRtasWE8yivAK/B/N7Y5LdhTcsT4Peh5V1zzrhhgXL+TsyePds3Jtz3N9yy3GsJAOV2qcqlITtk8cUXt+7du1flOSTR6Fo69xkzZpgyHVS6devWpAygaUng1mgdtfSaSfMlaqqzPvS+//57f4qLLLKIdezYsUmnm6bfiabaNAmCnRFwArwG878MsMlvw5qWJ8DvQ8u75pxxwwLl/J0IAaBw399wy3KvJQCU26Uql4YXQps2baxt27ZVeQ5JNLqWzj1cU7novOLPk7Cijp8Fauk1k+Zr2lTneBew1q1b19T7XFNt0nzdaVt1CPAazH+dsMlvw5qWJ8DvQ8u75pxxwwLl/J1YsGCBb0xT7gkZBLrh68laBBBAAAEEEEAAAQQQQAABBBBAoOoFyACq+kvICSCAAAIIIIAAAk0TmNpqWNMqSHrvq5OukPoQQAABBBBAgAwgXgMIIIAAAggggAACCCCAAAIIIIBAjQsQAKrxC8zpIYAAAggggAACCCCAAAIIIIAAAgSAeA0ggAACCCCAAAIIIIAAAggggAACNS5AAKjGLzCnhwACCCCAAAIIIIAAAggggAACCDAINK+BmhOYvOMiqTmn9e+blZq20BAEEEAAAQQQQAABBBBAAIGWK0AGUMu99pw5AggggAACCCCAAAIIIIAAAgi0EAEygFrIheY0EUAAAQQQqITAChcfWonD5j3mh8eMyruOFQgggAAC5RVI02cEnw/lvfYcrTICZABVxp2jIoAAAggggAACCCCAAAIIIIAAAmUTIABUNmoOhAACCCCAAAIIIIAAAggggAACCFRGgABQZdw5KgIIIIAAAggggAACCCCAAAIIIFA2AQJAZaPmQAgggAACCCCAAAIIIIAAAggggEBlBAgAVcadoyKAAAIIIIAAAggggAACCCCAAAJlEyAAVDZqDoQAAggggAACCCCAAAIIIIAAAghURoAAUGXcOSoCCCCAAAIIIIAAAggggAACCCBQNgECQGWj5kAIIIAAAggggAACCCCAAAIIIIBAZQQIAFXGnaMigAACCCCAAAIIIIAAAggggAACZRMgAFQ2ag6EAAIIIIAAAggggAACCCCAAAIIVEaAAFBl3DkqAggggAACCCCAAAIIIIAAAgggUDYBAkBlo+ZACCCAAAIIIIAAAggggAACCCCAQGUECABVxp2jIoAAAggggAACCCCAAAIIIIAAAmUTIABUNmoOhAACCCCAAAIIIIAAAggggAACCFRGgABQZdw5KgIIIIAAAggggAACCCCAAAIIIFA2AQJAZaPmQAgggAACCCCAAAIIIIAAAggggEBlBNpU5rAcFYGWIXBw/7GpOdFTUtMSGoIAAggggAACaRCYvOMiaWjGz23o8vf0tIWWIIAAAjUqQAZQjV5YTgsBBBBAAAEEEEAAAQQQQAABBBAIAgSAggQ/EUAAAQQQQAABBBBAAAEEEEAAgRoVoAtYjV5YTgsBBBBAAAEEEEAgfQIrXHxoahp1V2paQkMQQAABBMohQAZQOZQ5BgIIIIAAAggggAACCCCAAAIIIFBBAQJAFcTn0AgggAACCCCAAAIIIIAAAggggEA5BAgAlUOZYyCAAAIIIIAAAggggAACCCCAAAIVFCAAVEF8Do0AAggggAACCCCAAAIIIIAAAgiUQ4AAUDmUOQYCCCCAAAIIIIAAAggggAACCCBQQQECQBXE59AIIIAAAggggAACCCCAAAIIIIBAOQQIAJVDmWMggAACCCCAAAIIIIAAAggggAACFRQgAFRBfA6NAAIIIIAAAggggAACCCCAAAIIlEOAAFA5lDkGAggggAACCCCAAAIIIIAAAgggUEGBNhU8NodGAAEEEGhBAgf3H5uqsz0lVa2hMQgggAACCCCAAAIINK8AGUDN60vtCCCAAAIIIIAAAggggAACCCCAQMUFCABV/BLQAAQQQAABBBBAAAEEEEAAAQQQQKB5BQgANa8vtSOAAAIIIIAAAggggAACCCCAAAIVFyAAVPFLQAMQQAABBBBAAAEEEEAAAQQQQACB5hUgANS8vtSOAAIIIIAAAggggAACCCCAAAIIVFyAAFDFLwENQAABBBBAAAEEEEAAAQQQQAABBJpXgABQ8/pSOwIIIIAAAggggAACCCCAAAIIIFBxAQJAFb8ENAABBBBAAAEEEEAAAQQQQAABBBBoXgECQM3rS+0IIIAAAggggAACCCCAAAIIIIBAxQUIAFX8EtAABBBAAAEEEEAAAQQQQAABBBBAoHkFCAA1ry+1I4AAAggggAACCCCAAAIIIIAAAhUXIABU8UtAAxBAAAEEEEAAAQQQQAABBBBAAIHmFSAA1Ly+1I4AAggggAACCCCAAAIIIIAAAghUXKBNxVtAAxBAAAEEEGjhAvtes3RqBG497JPUtIWGIIAAAggggAACCCQnQAZQcpbUhAACCCCAAAIIIIAAAggggAACCKRSgABQKi8LjUIAAQQQQAABBBBAAAEEEEAAAQSSEyAAlJwlNSGAAAIIIIAAAggggAACCCCAAAKpFGAMoFReFhqFAAIIIIAAAggggAACCCBQLoHJOy5SrkMVdpwufy9sO7ZCoAgBMoCKwGJTBBBAAAEEEEAAAQQQQAABBBBAoBoFCABV41WjzQgggAACCCCAAAIIIIAAAggggEARAnQBKwKLTRFAAAEEEECgugVSleJPen91v5hoPQIIIIAAAlUmQAZQM12w2bNnN1qztpkxY4bNnTu30W3ZAAEEEEAAAQQQQAABBBBAAAEEEChVoOYygBRUue222+yll17ywZVevXpZ7969bbvttrPWrVsX7fTWW2/Z+PHj7YMPPrCOHTvaOuusY1tttZWttNJKOeu69dZb7eabb7avvvrKlllmGfvjH/9o/fr1y7nt2WefbZMmTbJx48ZZly5dcm7DQgQQQAABBBBAAAEEEEAAAQQQQKCpAjWVAfTNN9/YQQcdZFdddVUUAHrggQfsnHPOsVNPPdXmzJlTlJcCSYceeqg99NBD9vHHH9vrr79u119/vQ0aNMj+9a9/1atr4sSJdvnll/tgjrZp1aqVnXLKKb4t2Rv/97//tUcffdT22Wcfgj/ZODxHAAEEEEAAAQQQQAABBBBAAIFEBWoqAHT66afbRx99ZBtttJHde++9dtddd9ktt9xiK6+8sj311FN26aWXFoz32muv+e3btWtnZ555pim4o2DS0UcfbbNmzbLjjjvOPv300zr1jR071hZddFG75pprbMCAAT4Q1bZtW7vuuuvqbKcn1157rd92v/32q7eOBQgggAACCCCAAAIIIIAAAggggECSAjUTAHrjjTfshRdesEUWWcTOOOOMKKtm2WWXtQsvvNB3/7r//vvt+++/L8hPmT6ZTMb2339/69u3r8/mUTBn7733tr322suP2zNhwoSorp9++sk+/PBDW2WVVax9+/Z++WKLLWbLL7+8vffee9F2eqC2PvPMM9a/f3/frazOSp4ggAACCCCAAAIIIIAAAggggAACCQvUTADoiSee8DRbbrmlLbzwwnWYunbtahtuuKHvAqYgUGNl5syZPpik7bbddtt6m4dlyjKaN2+eX//jjz/6n506daqzvQJSCjqF7bRy1KhRtvjii9uee+5ZZ1ueIIAAAggggAACCCCAAAIIIIAAAs0hUDMBoClTpngfdf/KVRQAUnn11Vdzra6z7M033/TZP8re0UDO2WX11Vf33be+/fZbn/Wj9QoyKUNI4xDFi2b5WmKJJaxNm5/H2548ebIfE+iAAw7w2UrxbXmMAAIIIIAAAggggAACCCCAAAIINIdAzcwC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fmufffaZJ+jevbt17dq1JXNw7gjYu+++a/Pnz7fWrVvbyiuvjAgCXoAAEC8EBBBAAAEEEEAAAQQQQAABBBBAoMYF6AJW4xeY00MAAQQQQAABBBBAAAEEEEAAAQQIAPEaQAABBBBAAAEEEEAAAQQQQAABBGpcgABQjV9gTg8BBBBAAAEEEEAAAQQQQAABBBAgAMRrAAEEEEAAAQQQQAABBBBAAAEEEKhxgTY1fn6cHgIlC1x11VV+5HxVoNm3OnToYKuuuqpttNFGfjT9b775xsaOHWuDBg3yz0s+UNaOTz31lH399de22267+TWNtePll1/2s17ssMMOWTXxFAEEEECgWgS+//57u+GGG2yzzTaz3r17J9Ls5vqcSqRxVIIAAghUmcDbb79tzz77rB100EGpbXn8PqIa2ptayBpuGBlANXxxObWmCYwbN84++OADmz17tp+K/aOPPrIRI0bY8OHDfcX6Y/2WW26xBQsWNO1AWXt/8skn9t5770VLG2vHlClT7Omnn4625wECCCCAQPUJPPTQQ/bggw/aNddck1jjm+tzKrEGUhECCCBQRQLvv/++TZgwIdUtjt9HVEN7U41Zo40jA6hGLyynlYzA7rvvbptssklU2SuvvGJHHXWUffjhhz4rKFpRxIN58+ZZmzb/+9XLfp6rqobakWv7xpaFoNVCC/0vBjx//vycmUwKgLVv376xKlmPAAIIINAEgfvuu88OP/xwu/DCC+3dd9+1lVdeOWdtDX1mNLQuXtncuXOtbdu28UU8RgABBBBISKCx99js9+rs56EZmUzGf9HcunXrsKjez3z71tuwgQVJtVeHaKw9+dbPmTPHfy6p1wWleQX+dxfavMehdgRqQmDppZf25/HTTz/ZIossEp3T9OnT/R/ud955ZxTcOe2002ydddaxPfbYw4YMGWJ9+vSxe+65xxSZ32CDDeyPf/yjnX766T7LaMMNN7RTTjnFdzOLKm3gQbwd8c2ULaR0z7/85S9+sdq5995729///ncfsDrmmGNMXcWUuaQ3YKWwdunSxa688kr/AbPPPvvYAQcc4Pd9/PHH7ZJLLrEff/zROnbsaAceeGDULS1+TB4jgAACCDRN4J133vGfBVtuuaU9//zz/htmfW6EosdrrrmmTZw40WekrrXWWv59vnPnznbHHXfYG2+8YV988YX95z//sR49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n3uhPTk3YCECCCDQjAJkADUjLlUjgAACCOQXuO++++zwww+3Cy+80N59911beeWV62ysGxZ9w922bdto+bbbbmv6l130h3z49jZ7nZ7rD/t4Pbm2YRkCCCBQjQL77ruvrbfeelHThw0bZnfffbcdf/zx0bLsBw29Z4Zg0UILFfc98bx586xNm9y3Fg29B+faLyw7+eSTs5vug1lqY65jzZkzx7/Xt2rVqt5+YUHHjh3t2GOPDU9NGU677rqrvfLKK9anT59oefaDhsxCe7P3aex5Q/sVa6bPy1KzvBprJ+sRQKB2BHK/S9fO+XEmCCCAAAIpFFAWzwcffGBbbrmlPf/88zZhwgQbMmSIb6n+sL/44otNASL9Mbv88subbmh69erlt/vXv/5lI0eO9EEddX9QJtHMmTNtkUUWsd///ve2zz77+HpU34Ybbmj33HOP7za24oor2vDhw+sFmlLIQ5MQQACBkgXUTUvvh9lFAYWG3jMVPDnvvPNs0qRJPqCublGDBw/OrsYuueQSH7Q/66yz/Lpvv/3Wb/fqq69at27dfHBl44039uuUiXT++efb1KlTbeGFF7b+/fvbgAED/DrVra5QN998sw9gHXfccf5zQO/b+kxQVo4ycbbZZhv/T4Gaiy66KMrO2WCDDXyQa7HFFvNdtk499VTfLn1uqGux6lMXr8aKAkkKGOXatjEzfXlxwQUX+OMus8wytt9++9l2221X55DKzDrhhBNMJgcffLBfpy5i1157rclOBieddJItscQSft0dd9zhu9zpfFWnAnnrrruuX5dtpjplK3t1c9tiiy18ACx8nmonPd5+++3tN7/5ja+D/xBAoGULFBfab9lWnD0CCCCAQEICCu5svvnm1qlTJ/+HqVLiFcRReeGFF+yZZ54x/RE8ceJE/8fx6NGj/bqffvrJf1urJ6pDYztcd911viuZuj387W9/M3V5UNFP3UToG+QHHnjA/yE9atQov47/EEAAgVoR0PucAjuXXXaZD3qoy1MIssTPsbH3TAUy1M326quv9u+rb7zxht11111RFepydumll5qCFwrC6/1bRd3AFCxS/Xvuuaf95S9/8cEIdR1T8ELr7r33XjvjjDP8+/ojjzzi99N7tN77//rXv/rxhRT8V5es7777zp+L9tM2Ckyp6IuBzz//3AdHbrzxRlN7FFxS0WfESiut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9VbU7ilTpvjzW3TRRfMe/o033rAJEyZE69VuSvkFyAAqvzlHRAABBBBAAAEEEEAAgRoQOOigg+zf//539O/FF1+0Rx991C655BJbddVV7Z133vHBmtdffz2Rs73++uvt1VdfTaQuKml+ga233tofRBlbn3zySc4DPvDAA9a+fXtbYYUVTEGSDz/8MOd2Tz31lF++zTbbROsPP/xwU/ZNQ4GXaONmetCmTRv76aef7O67727wCLfcckuD61lZHgECQOVx5igIIIAAAggggAACCCBQYwJLLrmkrbfeetE/dQvbaqut7Oijj/aBmp122slmz55tBxxwQEWyNGqMu+pOZ9lll7U11ljDt/uZZ56p135lkr377rumroPbb7+9X6+AUHb5z3/+Y5999pl17NjRNttss2i1sssuvfRSW3zxxaNl5X6gLo8q48ePb/DQCgAtscQSttxyyzW4HSubV4AuYM3rS+0IIIAAAggggAACCCDQAgWU1aFuYL169fIZQhdddJGdcMIJ9SSUPfH222+bbvK//fZbW3nllW311Ve3pZdeOtpW4/6oy426EqkoGKBuN927d7ellloq2k4Ppk+f7rdVcKFbt27++KqvXbt2dbZr7EkmkzGN06K2qay55po+mKEgRL4yd+5cH/hSJosyQ9Zdd11bbbXV/OPsfdR+FQVIFlqobl6CTBQYUZvlF0qoV9lV77//vj399NM+ILLSSiuFTaKfX331lT3xxBP2448/+mysjTbayFq1ahWtjz/45ptv/DVSxpbq6t27t7eLbxMey0PnKXf5N1Z+85vf2JtvvmnPPvus7b333nU2v//++/1zZQqttdZadvXVV5sCQBpfJ16efPJJ/1Rj/sSvo14Tem3Io23btn4bHUuectc11OtK17Fr1672q1/9ypZZZpl41XUeL1iwwF/vV155xebNm+cd9Npp3bp1ne3iT3beeWd/bmq3unV17tw5vto//te//uWz4f74xz/686u3QWxBKa9f1f/aa6/ZIoss4oNpyqbS74qyrgq9TrEmmByU2adunvo93GCDDer9noXti3nN69rIUtdL10avZ2UN6ndL1yburEwwXXedk1676k6YSHEHpiCAAAIIIIAAAggggAACCBQosOuuu2bczVjGBXQa3ePYY4/127psoHrb/v3vf8+4G2a/XvWFf+4GPnPUUUdlZs6c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" width="576" /></p>
<p><img src="data:image/png;base64,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hgwxhx56qKteCqCpU6ea5s2bV9mcs846y1x88cVRuh49ephffvkl2s+0sfvuu5unnnrKJTnggAPM3Xff7bb33Xdf8/DDD7vt6667zpxwwgmZiinpc+Xc19122808/fTTbnxuu+02c/jhhxf9WNX3vw+PPfaY2WuvvYp+nGggBCAAAQhAAAIQgAAEyoEALmDlMIol2IdtttkmavX8+fOzVmo9//zzUT5tyKrns88+SzoWtyM959tvvx2d2m677aJtNiAAgcIS+PLLL81WW21lpIhFIAABCEAAAhCAAAQgAIHCEMAFrJY5y9VowIABGWv56KOPzLx581ya5Zdf3siqJZ2Ug/uX+qZ+rrzyyubbb791XX3nnXfM5ptvnq7b7viECRPMxx9/7LYbNGhgvPHaCy+8YNZcc82MeT///PPIzUt5t91224zpOQmBQhCoj38f5Pq51lprmQULFmRl9VeIcaAOCEAAAhCAAAQgAAEI1AcCKIBqeZR79+5thg8fnrGWXr16mbFjx7o0xx13nDn11FMzpi+Xk7IC8gqgYcOGVdmtF198MVL6yG3k0UcfdXlkFXTaaadlzP/mm29G56UsWmaZZaJ9Md91113d/vrrrx8dL8eN+tTXUhi/+vj3QYoffRAIQAACEIAABCAAAQhAoLAEUAAVlje1BQSkALr55pvdkXfffdcpd2Sdk05k6eNFCp+XXnrJTJ8+3ch6aMaMGaZ169b+dKXvt956KzqW6v612WabGX3qg9SnvtaH8aSPEIAABCAAAQhAAAIQgAAEsiVADKBsSZEu7wS23HJL07DhkktQq3CNGjUqbR2LFy92Ch8laN++venfv79RfomsCV577TW3ne6/TAqgdHk4DgEIQAACEIAABCAAAQhAAAIQKBcCWACVy0jafowbN858+OGHbtn5b775xrk5yd1JH8UO8sqWdF3WikR//PGHO73hhhu6+BwK0Dxy5Ejnxqbz3bt3N6uttprZc889jeKX1ES8IsevaiZLnnTLwasNvm1bb72168v2229vnnzySdcEuYFpla84+eqrr4ziB0m00liqtc/o0aOj84pLlBqDKeSy8cYbG61aJvnxxx8dF1kvNW7c2Ky77rpOMZVrnCZZL3366afuo4DW7dq1M2uvvbb7rLrqqhnHTeknT57s2rPpppuaiooK88knn5ihQ4caH2tlv/32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Wz9+/HhzwAEHmK233jptGk5AoFgIZLqWi6WNtAMCEIAABCAAAQhAAAIQgEApE6go5cbX97Y3btzYNGvWLBbDeeedZ+69917TtGnT2PMchEAxEch0LRdTO2kLBCAAAQhAAAIQgAAEIACBUiWABVCpjpxt96WXXmrmzJnjPk2aNCnhntD0+k6Aa7m+XwH0HwIQgAAEIAABCEAAAhCobQIogGqbMOVDAAIQgAAEIAABCEAAAhCAAAQgAIE6JoALWC0PwKeffmrmzZtnWrVqZfr27Rtb21dffWWmT59uGjVqZPr37x+b5scffzSK6yNXmXXWWcel+fnnn824cePc9vrrr+8CO//222/ml19+MRMmTHDHFVtlxIgRbrtr165m+eWXd9up/8mS6OOPPzYffPCBWbBggdl4441dW/LhQqayv/nmG6N+fv31185tbeWVVzb6iEnDhn/qIRcuXGg++ugj17xOnTqZ3r17pzY1af+zzz4zc+fOTctX/f/222+NxmHUqFGme/fuZu211zb9+vUzzZs3TyrL74wdO9bxa9u2rVl11VXd9lNPPeW+xWXgwIE+afSdSx+jTCkb77//vhk5cqT5/fffzeqrr24GDBjgxkt90LhIVlppJdOhQ4eUnEt2p02b5vqpvmp7zTXXdH1NN+axhaQc/Omnn1x7/PWrtnz55ZfmnXfecddZr169zLbbbmt69OiRknPJrq4lXVcSjXWLFi2MApO/9tprplu3bmbPPfc0HTt2NHHX8pISkv+fNGmSeeGFF4zGaNGiRWbFFVc0G264oeOSnLLyXm3wqVwLRyAAAQhAAAIQgAAEIAABCBQpAftAh9QigV133VWRmhPt27dPWOVGpZoWL16cWGaZZVwapbMP3JXS6MCmm27q0myzzTbR+ZNOOinKZ5VM7vhFF10UHVN54efEE090aaZMmRIdP/vssxNvvfVWwj6MR8d8HutWlvjvf/8b1VedjVtuuSVhlQeVyvZ12If3xOeff55UtFUMufRW+ZJ0PHXHKrsSVmnm0opFqljFT0Ll+7rC7y5duiSefvrp1Cxu/8gjj3R5tttuu4RVyiRat26dVMYFF1yQlK86fQwLsAqVhFX2JNXh23rUUUclZs6cGZ27//77w6xuW9fQlVdembDKuiidz6/v/fbbL6Exr4784x//cGWKo1W+JDbaaKNKdeg6OeaY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adhmlRPOg+KunXHjxrlYSl27dk1ypcvlGgjbyzYEipkACqBiHh3aBoESICD/c72B+vDDDyu1VgoYBSXUmzwvTz31lLn77rvNX/7yF2cV44/77+uvv96899575vTTTzfbbrutO/zss8+aIUOGmH/84x9GZsc+po4mHHKpkiJFN/f777/f3HPPPW6i4MvTBFGTxwMOOCBJaaFybr31VnPiiSe6yai2NWnzIsXJOeec4yZM/lhNv3///XdXhJRSXvmjA7ky0STnsMMOq7I54i8euab3BWtSpze0mkCGIpPzf/3rX7FsVJfM95955plK46CgnrKCCvselss2BCAAAQiUNwHdP6QImD59uhk2bJjZYostYju89dZbm8033zzpYVwJ/b1v6NChlZQfUnQoFo6/9/mCFWT6oosuqqR8kKLguOOOM9tvv71PGn0///zz5uabbzaKxxOK4vfttttu5ogjjnAKDn9OVr4qT3nOOOMMpxTx5/St+H+6/1X18iTME26Hyp811ljD3ZszxWyU2/lNN90UKbx8WVIAaX4lBVKq3HLLLUZcpTgKZb311nNzOSm+NG5+DJRGru366P5+1FFHmUzzNZUf5g3rCLdTxy/buYjcBzVP7Ny5s5sbhmV+/vnn5pRTTnGHNM/UohxeNH+UK6KUfI8++mh0zeV6Dfjy+IZAsRNAAVTsI0T7IFDEBGRtc/jhhxt9r7XWWs6UW2/IFMRRShy9UVEQRylp9CaopqIbsyyMNIHUqherrLJKpEy48MIL3WRSgSQVh0dvePTmThOTe++9170BO/fccys1QZMdTS4GDhzo+iDLlZdfftnlPeuss5wCpboTtrAyTUyl+JLsuOOO4amct7XKx/7775+UT5NStdMrwvQt1zNJrumVR28A//nPfxrFMNpss83Mpptu6t5uynRfyjNNdq+77jo3BkovkQLt/PPPd+OviaKUfJpsqu+PPfaYefjhh40PHEkQ7CXM+B8CEIBAfSLQsmVLs8EGG5h3333XKTF0T5GiRy+KwhWsdD/Lx71XChy9sJBlyM477+zui7qvqV4Fmlb8HFkbb7LJJtEw6MXJXXfd5ax3lKdfv37OclnzGlklafUyWZjss88+UR5tyHr5hBNOcMf+/ve/u8DWsliW27fmQVJs7LTTTkl5stkJlT+yfNZ8J2SVWobmYOqzRHObjTbayL2Q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9yfz0XhDgAABAgQI9CHQdl3A7rnnniKLV6RNXWmllXo9/W233bZYHi2GHnjggfnWvemmm1K0EIpywAEHzLfMGwIECBAgQIBAPQKRuSvKqquu2utmkZF00qRJxb3MGWecMV+SiehG9o1vfCO99tpraYsttijSw/e6MwsJECBAgAABAhUCbdcC6IknnihOL5pFxwCOvZVoWn3ttdemW265Je23335p6tSpxc/999+frrjiimLTgw46KE2ZMqW33VhGgAABAgQIEOhVoLw/mTx5cq/rRfaxaJV86KGHpmipHA+kdtxxxyJz2FVXXZUef/zxIoh0yCGH9LofCwkQIECAAAEC3QXaLgBUDojY1w1WQEQroRNOOCGdffbZRcrVuMmKnyiRfePggw9Om222WfHe/wgQIECAAAEC/RGITKLRtStKXy2AYp2NNtoonXLKKUWmrrvvvjudc845MTtF1q6ddtqpCA4tuuiixTz/I0CAAAECBAjUKtB2AaBoyRM/tZZ40hZdvPbdd9/05JNPpmnTpqUIHo0fP77WXViPAAECBAgQINCjQKR2v/LKK3tcXm1BjO9z6qmnpunTp6fHHnusSEYRD6diXwoBAgQIECBAoD8CbRcA6g9CbDNq1KhizKC+xg3q7/5tR4AAAQIECBCoV2BiztoWPwoBAgQIECBAoFEBj5EaFbQ9AQIECBAgQIAAAQIECBAgQGCICwgADfEL5PAIECBAgAABAgQIECBAgAABAo0KCAA1Kmh7AgQIECBAgAABAgQIECBAgMAQFxAAGuIXyOERIECAAAECBAgQIECAAAECBBoVEABqVND2BAgQIECAAAECBAgQIECAAIEhLiAANMQvkMMjQIAAAQIECBAgQIAAAQIECDQqIADUqKDtCRAgQIAAAQIECBAgQIAAAQJDXEAAaIhfIIdHgAABAgQIECBAgAABAgQIEGhUQACoUUHbEyBAgAABAgQIECBAgAABAgSGuIAA0BC/QA6PAAECBAgQIECAAAECBAgQINCogABQo4K2J0CAAAECBAgQIECAAAECBAgMcQEBoCF+gRweAQIECBAgQIAAAQIECBAgQKBRAQGgRgVtT4AAAQIECBAgQIAAAQIECBAY4gICQEP8Ajk8AgQIECBAgAABAgQIECBAgECjAgJAjQrangABAgQIECBAgAABAgQIECAwxAUEgIb4BXJ4BAgQIECAAAECBAgQIECAAIFGBQSAGhW0PQECBAgQIECAAAECBAgQIEBgiAsIAA3xC+TwCBAgQIAAAQIECBAgQIAAAQKNCggANSpoewIECBAgQIAAAQIECBAgQIDAEBcQABriF8jhESBAgAABAgQIECBAgAABAgQaFRAAalTQ9gQIECBAgAABAgQIECBAgACBIS4gADTEL5DDI0CAAAECBAgQIECAAAECBAg0KiAA1Kig7QkQIECAAAECBAgQIECAAAECQ1xAAGiIXyCHR4AAAQIECBAgQIAAAQIECBBoVEAAqFFB2xMgQIAAAQIECBAgQIAAAQIEhriAANAQv0AOjwABAgQIECBAgAABAgQIECDQqIAAUKOCtidAgAABAgQIECBAgAABAgQIDHEBAaAhfoEcHgECBAgQIECAAAECBAgQIECgUQEBoEYFbU+AAAECBAgQIECAAAECBAgQGOICAkBD/AI5PAIECBAgQIAAAQIECBAgQIBAowICQI0K2p4AAQIECBAgQIAAAQIECBAgMMQFBICG+AVyeAQIECBAgAABAgQIECBAgACBRgUEgBoVtD0BAgQIECBAgAABAgQIECBAYIgLCAAN8Qvk8AgQIECAAAECBAgQIECAAAECjQoIADUqaHsCBAgQIECAAAECBAgQIECAwBAXEAAa4hfI4REgQIAAAQIECBAgQIAAAQIEGhUQAGpU0PYECBAgQIAAAQIECBAgQIAAgSEuIAA0xC+QwyNAgAABAgQIECBAgAABAgQINCogANSooO0JECBAgAABAgQIECBAgAABAkNcQABoiF8gh0eAAAECBAgQIECAAAECBAgQaFRAAKhRQdsTIECAAAECBAgQIECAAAECBIa4gADQEL9ADo8AAQIECBAgQIAAAQIECBAg0KiAAFCjgrYnQIAAAQIECBAgQIAAAQIECAxxAQGgIX6BHB4BAgQIECBAgAABAgQIECBAoFEBAaBGBW1PgAABAgQIECBAgAABAgQIEBjiAgJAQ/wCOTwCBAgQIECAAAECBAgQIECAQKMCAkCNCtqeAAECBAgQIECAAAECBAgQIDDEBQSAhvgFcngECBAgQIAAAQIECBAgQIAAgUYFBIAaFbQ9AQIECBAgQIAAAQIECBAgQGCICwgADfEL5PAIECBAgAABAgQIECBAgAABAo0KCAA1Kmh7AgQIECBAgAABAgQIECBAgMAQFxAAGuIXyOERIECAAAECBAgQIECAAAECBBoVEABqVND2BAgQIECAAAECBAgQIECAAIEhLiAANMQvkMMjQIAAAQIECBAgQIAAAQIECDQqIADUqKDtCRAgQIAAAQIECBAgQIAAAQJDXEAAaIhfIIdHgAABAgQIECBAgAABAgQIEGhUQACoUUHbEyBAgAABAgQIECBAgAABAgSGuIAA0BC/QA6PAAECBAgQIECAAAECBAgQINCogABQo4K2J0CAAAECBAgQIECAAAECBAgMcQEBoCF+gRweAQIECBAgQIAAAQIECBAgQKBRAQGgRgVtT4AAAQIECBAgQIAAAQIECBAY4gKjhvjxDfvDmzNnTnr99dfTc889V/e5jK57CxvUIlDLtWBfi2T/1uHfP7eB2KoW+6jH538gtBfcRy3+7Bd0G6g5tfhX1vXqq6+mN954o3JW20yX5zV9+vR+3Z+0DcQQOpF6P59D6NDb4lD4t/Yy8m+dP/vW2UfN9frPnDmzOOC5c+f2+8AFgPpNV/uGCy20UBoxQmOr2sUGd03XYnB9+9o7/76EBm85+8GzrWXP/GtRGrx16vWPv93tXsKkXpd2N2nV+bkOrZKfVy9//q0VaF3tPvuts4+a6/Wvd/1qZycAVE1lAOeNHDkyjRo1Ki2++OJ17/XlurewQS0CtVwL9rVI9m8d/v1zG4itarGPenz+B0J7wX3U4s9+QbeBmlOLf2VdY8eOTe0aBCrPa7HFFuvX/Umlk+mBEaj38zkwtdpLKcC/lGjNK//WuEet7Ftn3x//sgVQI4EgzVJae83VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1AAGjQiVVAgAABAgQIECBAgAABAgQIEGitgABQa/3VToAAAQIECBAgQIAAAQIECBAYdAEBoEEnVgEBAgQIECBAgAABAgQIECBAoLUCAkCt9Vc7AQIECBAgQIAAAQIECBAgQGDQBQSABp1YBQQIECBAgAABAgQIECBAgACB1goIALXWX+0ECBAgQIAAAQIECBAgQIAAgUEXEAAadGIVECBAgAABAgQIECBAgAABAgRaKyAA1Fp/tRMgQIAAAQIECBAgQIAAAQIEBl1g1KDX0MQKXn311XTaaaf1WuMuu+ySVl999fnWmTlzZjrvvPPSjTfemF544YW0xhprpA022CDtvPPOaeTIkfOt6w0BAgQIECBAoB6BK664It122209brLUUkulvffee4Hl99xzTzr33HPTI488ksaNG5fWW2+9tN1226XJkycvsK4ZBAgQIECAAIG+BNoqAHT//fcXgZzeTjoCO5UBoGnTpqWDDjooPfbYY8VmSyyxRPrjH/9Y/Fx77bXp6KOPTossskhvu7SMAAECBAgQINCjwPnnn59uuummHpdHQKd7ACgeTJ100knFNuPHj0+zZs1KN998c/rlL3+Zjj/++LThhhv2uD8LCBAgQIAAAQLVBNoqAHTfffcV5zh16tTiCVm1E47WPZXlK1/5ShH82XTTTdNRRx2VJk6cmJ544on0hS98IV111VXpu9/9bvrsZz9buYlpAgQIECBAgEDNAuX9ycEHH5xGjx69wHaLLbbYfPNuv/324v4jHkDFg6gtt9wyzZ49O/32t7/tvC/5+c9/npZddtn5tvOGAAECBAgQINCbQFsGgKJ59K677trbeRfL7rrrrnTDDTeksWPHpq9+9atpzJgxxfwVVlghffvb30677757uuiii9KBBx6Yut+c9blzKxAgQIAAAQJveoGnn346vfjii2nJJZdMe+65Z00eP/3pT9Mbb7yR9tlnn7TVVlsV2yy88MLF9k8++WTR2jmCQZ/4xCdq2p+VCBAgQIAAAQIh0FaDQEcXsChTpkwpXvv635VXXlmssvXWW3cGf8ptoivYJptsUjS5jiCQQoAAAQIECBCoV6Bs/VPrvUmMZxgPp6LstNNOC1RXzvv9739ftApaYAUzCBAgQIAAAQI9CLRNACiaRj/44INp1KhRnYMjxhO3GOC5p3LnnXcWi6L7V7USAaAovQ3cWG078wgQIECAAAECIdA9ABT3K88//3yPOHfffXfR+mfFFVdMyy+//ALrrbXWWkWr5OnTp6dHH310geVmECBAgAABAgR6EmibLmCRIeP1119PK620Uop+8b/5zW/Sc889l0aMGFHM+9CHPpR23HHH+RxirJ8okyZNmm9++aacXw4QXc7v/nryySf3+BQuBpmeM2dOeumll7pv1uf7hfpcwwr9EajlWrDvj2xt2/CvzWkw1qrFPur1+R8M/VTT3wH2g2Mfe631818eQQy6HN2wGi1lACgCP4cccki65ZZbivuC6Fq+8cYbpxgXKLqHlaWve5NYL+5P4nzi/qSnjGDXX399Z0uict/laxxLlGhtVK9LuQ+vAyvgOgysZ71741+v2MCuz39gPevZG/t6tAZ+3Xr9y8YtjdyftE0AqLzBiqdhp59+eoqUqjEY9MMPP1z8xGDPkT3jyCOP7Lxyr7zySjFdBno6F3RMTJgwoZgq1+u+vHz/gx/8oMeWRuuvv35xA/nyyy+Xq9f8Ov+QkDVvZsU+BGq5Fuz7QGxgMf8G8BrctBb7qMLnv0HoHjavxZ99D3gDMLsW/8pqypusynn9mS67p5955plp5MiRKVrwlK2WL7/88nTjjTcW2b7KDKXlPUdP9yZxDLXcn/z1r39N8YCqWllttdWK2REAqtel2v7Ma1zAdWjcsJE98G9Er/Ft+Tdu2N89sO+v3MBsV69/eW8iAJT9yxuseKJ23HHHpUj3HiVwojXQiSeemC688MK02WabpW222SbNnTs3zZgxo1inpwGeI+1qlBK6eON/BAgQIECAAIEaBCKYE4M2R4mxew477LAi8US8j/nHHHNMioQUcd9y6qmnFt3YIygTpad7k1hW3p+U9zExTyFAgAABAgQI9CXQNi2A9t1337T99tsXadwr+8wvtNBCRTavaAkUgaCzzjqrCABF17DI/vXaa6/1GOApAz+RhrW38s1vfrPHLmDnn39+in76vT3J62nfc3paYH5DArVcC/YNEfe6Mf9eeQZ1YS32cQA+/4NzGWrxZz849rHXWvwra497hEZL7CO6pT/77LPFg6m4JylL3Ksce+yxae+99y7GCYqBnzfffPM0bty4YpXogtZTKe9PqqWUL7d5z3vek8pWReW88vWFF15I0TI6gkz1upT78DqwAq7DwHrWuzf+9YoN7Pr8B9aznr2xr0dr4Net17/8+195P1HvUbVNAChuYtZee+0ez3+HHXYoAkAPPfRQ0fonAkDRTSz6z/fU966cX96M9bTzMiNHteWXXXZZ0by6PzeS9Xcaq3YE5nUXqOVasO+uNnDv+Q+cZb17qsU+9unzX69sbevX4s++Nsv+rFWLf+V+I6lEIzdYsa+414jBnOOnWllmmWXSeuutV3QDi0QWEQCKe5Mokciip1LL/cmaa66Z4qdaueOOO4rZEUCq16Xa/sxrXMB1aNywkT3wb0Sv8W35N27Y3z2w76/cwGxXr3/cV0Rp5P6kbbKA9XUJ4iYrSjxRK/vXlzdZ5Y1U932UN1+LL75490XeEyBAgAABAgQaFlh66aWLfUTiiih93ZvEOu5PQkEhQIAAAQIE6hVomwDQueeem2Iw5ujqVa089dRTxewYOLHsV1/edMVTt2qlnN9by6Jq25lHgAABAgQIELj33nvTT3/60xT3KD2Vp59+ulj01re+tXgt702ihXJkN+1eolt5pJGPp4BrrLFG98XeEyBAgAABAgR6FGibAFB0tTr77LOLG61qZ3vNNdcUs9ddd93OxTFmUJTYtnuJQaIjO0eUckDp7ut4T4AAAQIECBDoSSDG2onMpN/73vfSI488ssBqEci58847i/nl/UmMDRSZwiIzSGTy6l6uuOKKIo18rLPooot2X+w9AQIECBAgQKBHgbYJAG277bbFSUbQ5oEHHpjvhG+66abOp28HHHBA57LICLbKKqsUgy9edNFFnfNjIoJJ0Rx75ZVXTptuuul8y7whQIAAAQIECPQlEA+QYoDHyEh6xhlnzJcwIjJ4feMb3yiSUWyxxRZF0Kfc3wc/+MFi8ic/+cl84xRGa6H//d//LZbtueee5epeCRAgQIAAAQI1CbTNINBxI3TttdemW265Je23335p6tSpxU+kh4+nZVEOOuigNGXKlE6YGDzpYx/7WPrSl75UpGC97rrriubUt99+e4rphRdeOB1xxBENDbLUWZkJAgQIECBA4E0lMGbMmHT00UenQw89tGhtHA+kdtxxxzRy5Mh01VVXpccffzytuuqq6ZBDDpnPZeutty4SW9x9993pox/9aIqHXLNnzy72EQ+nImC03XbbzbeNNwQIECBAgACBvgTaJgAUN1MnnHBC0XInUq7GTVb8RInsGwcffHCKFj/dy1ZbbZW+853vFAGgCBSVwaJoGRQ3ZOuvv373TbwnQIAAAQIECNQksNFGG6VTTjklnXTSSSkCOuecc06xXWT+iCyiERzq3pUr7mmi21jcn1xyySXFvU1sFPP32GOPdOCBBxZjANV0AFYiQIAAAQIECHQItE0AKM4nnrRFF6999903Pfnkk2natGlp8uTJafz48b1e8He84x1FF7F4qhaDLsYAjMsuu6ybq17VLCRAgAABAgRqEYjxfU499dQUAzjHfUYko4iHU2U612r7iBTtRx55ZPrsZz9bdG2PbmSxzbhx46qtbh4BAgQIECBAoE+BtgoAlWc7atSotNJKKxU/5bxaXpdccskUPwoBAgQIECBAYKAFJk6cmOKnnhL3NJXd1+vZ1roECBAgQIAAgUqBthkEuvKkTBMgQIAAAQIECBAgQIAAAQIECHQJCAB1WZgiQIAAAQIECBAgQIAAAQIECLSlgABQW15WJ0WAAAECBAgQIECAAAECBAgQ6BIQAOqyMEWAAAECBAgQIECAAAECBAgQaEsBAaC2vKxOigABAgQIECBAgAABAgQIECDQJSAA1GVhigABAgQIECBAgAABAgQIECDQlgICQG15WZ0UAQIECBAgQIAAAQIECBAgQKBLQACoy8IUAQIECBAgQIAAAQIECBAgQKAtBQSA2vKyOikCBAgQIECAAAECBAgQIECAQJeAAFCXhSkCBAgQIECAAAECBAgQIECAQFsKCAC15WV1UgQIECBAgAABAgQIECBAgACBLgEBoC4LUwQIECBAgAABAgQIECBAgACBthQQAGrLy+qkCBAgQIAAAQIECBAgQIAAAQJdAgJAXRamCBAgQIAAAQIECBAgQIAAAQJtKSAA1JaX1UkRIECAAAECBAgQIECAAAECBLoEBIC6LEwRIECAAAECBAgQIECAAAECBNpSQACoLS+rkyJAgAABAgQIECBAgAABAgQIdAkIAHVZmCJAgAABAgQIECBAgAABAgQItKWAAFBbXlYnRYAAAQIECBAgQIAAAQIECBDoEhAA6rIwRYAAAQIECBAgQIAAAQIECBBoSwEBoLa8rE6KAAECBAgQIECAAAECBAgQINAlIADUZWGKAAECBAgQIECAAAECBAgQINCWAgJAbXlZnRQBAgQIECBAgAABAgQIECBAoEtAAKjLwhQBAgQIECBAgAABAgQIECBAoC0FBIDa8rI6KQIECBAgQIAAAQIECBAgQIBAl4AAUJeFKQIECBAgQIAAAQIECBAgQIBAWwoIALXlZXVSBAgQIECAAAECBAgQIECAAIEuAQGgLgtTBAgQIECAAAECBAgQIECAAIG2FBAAasvL6qQIECBAgAABAgQIECBAgAABAl0CAkBdFqYIECBAgAABAgQIECBAgAABAm0pIADUlpfVSREgQIAAAQIECBAgQIAAAQIEugQEgLosTBEgQIAAAQIECBAgQIAAAQIE2lJAAKgtL6uTIkCAAAECBAgQIECAAAECBAh0CQgAdVmYIkCAAAECBAgQIECAAAECBAi0pYAAUFteVidFgAABAgQIECBAgAABAgQIEOgSEADqsjBFgAABAgQIECBAgAABAgQIEGhLAQGgtrysTooAAQIECBAgQIAAAQIECBAg0CUgANRlYYoAAQIECBAgQIAAAQIECBAg0JYCAkBteVmdFAECBAgQIECAAAECBAgQIECgS0AAqMvCFAECBAgQIECAAAECBAgQIECgLQUEgNrysjopAgQIECBAgAABAgQIECBAgECXgABQl4UpAgQIECBAgAABAgQIECBAgEBbCggAteVldVIECBAgQIAAAQIECBAgQIAAgS4BAaAuC1MECBAgQIAAAQIECBAgQIAAgbYUEABqy8vqpAgQIECAAAECBAgQIECAAAECXQICQF0WpggQIECAAAECBAgQIECAAAECbSkgANSWl9VJESBAgAABAgQIECBAgAABAgS6BASAuixMESBAgAABAgQIECBAgAABAgTaUkAAqC0vq5MiQIAAAQIECBAgQIAAAQIECHQJCAB1WZgiQIAAAQIECBAgQIAAAQIECLSlgABQW15WJ0WAAAECBAgQIECAAAECBAgQ6BIQAOqyMEWAAAECBAgQIECAAAECBAgQaEsBAaC2vKxOigABAgQIECBAgAABAgQIECDQJSAA1GVhigABAgQIECBAgAABAgQIECDQlgICQG15WZ0UAQIECBAgQIAAAQIECBAgQKBLQACoy8IUAQIECBAgQIAAAQIECBAgQKAtBQSA2vKyOikCBAgQIECAAAECBAgQIECAQJeAAFCXhSkCBAgQIECAAAECBAgQIECAQFsKCAC15WV1UgQIECBAgAABAgQIECBAgACBLgEBoC4LUwQIECBAgAABAgQIECBAgACBthQQAGrLy+qkCBAgQIAAAQIECBAgQIAAAQJdAqO6Jk0NhsDs2bPTrFmz0tNPP1337hetewsb1CJQy7VgX4tk/9bh3z+3gdiqFvuox+d/ILQX3Ect/uwXdBuoObX4V9b1yiuvpDfeeKNyVttMl+f1wgsv9Ov+pG0ghtCJ1Pv5HEKH3haHwr+1l5F/6/zZt84+aq7Xf+bMmcUBz507t98HLgDUb7raNlxooYXSiBEj0ujRo2vbwFqDLuBaDDpxrxXw75VnUBeyH1TePnfOv0+iQV2hXv+RI0cO6vEMhZ0vvPDC7k+GwoXIx1Dv53OIHHbbHAb/1l5K/q3zZ986+6i5Ff4CQIN8zeMGctSoUWnixIl11/Ry3VvYoBaBWq4F+1ok+7cO//65DcRWtdhHPT7/A6G94D5q8We/oNtAzanFv7KuMWPGpHiI046lPK/x48f36/6kHU1afU71fj5bfbztVj//1l5R/q3zZ986+6i5Xv+yBVA0MOlv6f+W/a3RdgQIECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQGAG54oAAEAASURBVIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUQAGoqt8oIECBAgAABAgQIECBAgAABAs0XEABqvrkaCRAgQIAAAQIECBAgQIAAAQJNFRAAaiq3yggQIECAAAECBAgQIECAAAECzRcQAGq+uRoJECBAgAABAgQIECBAgAABAk0VEABqKrfKCBAgQIAAAQIECBAgQIAAAQLNFxAAar65GgkQIECAAAECBAgQIECAAAECTRUY1dTamlDZc889l375y1+mBx54ID311FNp6aWXTquuumraa6+90lve8pYFjuDVV19Np5122gLzK2fssssuafXVV6+cZZoAAQIECBAgULPAFVdcka6++ur0+OOPp7lz56aVVlopvfOd70zvfve7q+4j1r/tttuqLouZSy21VNp77717XG4BAQIECBAgQKC7QFsFgK688sp03HHHpddeey2NHDkyLbnkkummm25KN9xwQ/rd736XPve5z6Xtt99+PoP7778/nXfeefPN6/5mgw02EADqjuI9AQIECBAg0KfAzJkz0+GHH55uueWWYt0JEyYUr/fee2+69NJLi/uTE044IY0dO3a+fZ1//vnFPcx8MyveTJ48WQCowsMkAQIECBAg0LdA2wSAnnjiic7gz/7771/cFI0ePTrFjdfPfvaz4uf4449Pa665ZlpxxRU7Ze67775ieurUqWm77bbrnF85scYaa1S+NU2AAAECBAgQqEng+9//fhH8WWWVVdIXv/jFNGXKlGK7e+65Jx177LHp73//e/re976XjjjiiPn2V96fHHzwwSnuZ7qXxRZbrPss7wkQIECAAAECvQq0TQDoggsuKFr+7LDDDukjH/lI50nHTdPHPvax9Oijj6ZoIRTrHXTQQZ3LyxusCP7suuuunfNNECBAgAABAgQaEYhu5tECecSIEUWwJ7qkl2WttdZKX/va19KHP/zh9Pvf/z596lOfSosuumix+Omnn04vvvhi0ZJ5zz33LDfxSoAAAQIECBBoSKBtBoEum1ZvueWWVUE23XTTYn50+aos5fvyiVzlMtMECBAgQIAAgf4K3H777WnOnDlFy+PK4E+5v5gX4xO+8cYb6cEHHyxnp/LhlHuTThITBAgQIECAwAAItE0LoO9+97spBoCeNGlSVZbnn3++mF+5fPbs2cUN16hRo1L0pY8ST9yi1VC15tbFCv5HgAABAgQIEKhBYJNNNilaAM2YMaPq2nEfMn369GJZ5f1J9wBQrBf3J0sssUTV/ZhJgAABAgQIEKhFoG0CQBGwWX755auec9w4XXTRRcWyddddt3OdRx55JL3++utFJo6f//zn6Te/+U0RRIqm2pGd40Mf+lDacccdO9fvaSL68M+aNavq4gg8Rf3Tpk2rury3mW1zcXo7yRYsq+VasB+8C8N/8Gz72nMt9rEPn/++JPu3vBZ/9v2zrWWrWvwr9xNBm2iZ00hZaKGF0uKLL97jLi655JLi/mHixIlphRVW6FyvDADF/cMhhxxSjCEULYli3J+NN944xbhAkeiit/KnP/0pRSaxaiUefEV56aWX+nV/Um2f5jUmUO/ns7HabN1dgH93kea+599c78ra2FdqNH+6Xv8Y3zhKZBPtb3lT3Gv+8Ic/LNKuxs1VpHQvS3mDFeMDnX766UVK1RgM+uGHHy5+vvKVr6Sbb745HXnkkeUmVV8ji1h5MbqvsP766xc3kJGZrN5ieMd6xWpbv5Zrwb42y/6sxb8/agOzTS32UZPP/8B4d99LLf7su6sN3Pta/CtriwdEg1mefPLJdMoppxRVfPzjH08RLCpL2T39zDPPLLKaxnhBEQyKbmKXX355uvHGG9NJJ53Ua4bSO+64I5177rnlLud7XW211Yr3ce9Sr8t8O/JmwARchwGj7NeO+PeLbcA24j9glHXviH3dZAO6Qb3+PcUc6jmotg8A/eIXv0jxE616Pv/5z6cxY8Z0+pQ3WPFELdLHR7r3KPHEL1oDnXjiienCCy9Mm222Wdpmm22KZf5HgAABAgQIEGhEILqsH3rooUXrm+gmVpmE4pVXXkkRHIqy0047pcMOO6wzRXzMP+aYY9Jdd91V3LeceuqpqWzN08jx2JYAAQIECBB4cwi0dQAobozi6VkEfyL1arTGqSz77rtv2n777VM0va7sPhZP4XbfffeiFVAEgs4666xeA0BnnHFGj82wfvzjH6foBtZXU+3K4yqnq3cqK5d67a9ALdeCfX91+96Of99Gg7VGLfZRt8//4FyBWvzZD4597LUW/8raIyNXZaucymWNTEer489+9rPp//7v/9I666xTZAer3N/YsWNTdEt/9tlniwdTlccQ9yrR7XzvvfcuBoq+4YYb0uabb165eef0HnvskbbYYovO95UTEUg6/PDDi/ufel0q92N64ARch4Gz7M+e+PdHbeC24T9wlvXuiX29YgO7fr3+ZQugynuDeo+oLQNA0Wz7+OOPT9G3fpFFFklf+tKX0tZbb72ATbT8WXvttReYX86IlPIRAHrooYeKAE8EkqqVDTfcsNrsYt7ZZ59dBKDiOOotvgjUK1bb+rVcC/a1WfZnLf79URuYbWqxj5p8/gfGu/teavFn311t4N7X4l9Z28iRIyvfDsj0bbfdVnQrj7F3Ntpoo/TVr341jRs3br59x73GiiuuWPzMt6DjzTLLLJPWW2+9ohtYdAnrKQAU3d4rxxWq3Fd0D4uy8MILF/dJlctMt0ag3s9na46yfWvl39pry791/uxbZx811+tfjk0oAFRx3eKm6gtf+EIxYOKECROKQFDcKPWnxE1WlBjgOZpkR8BIIUCAAAECBAjUKxBj90TAJx5SRdeuGF+wv923ll566aL66EqmECBAgAABAgRqFWirFkCRIjUyYzzwwAPprW99azrhhBN6fIIWQDE4Ytw87bzzzmmVVVZZwOypp54q5kUgSfBnAR4zCBAgQIAAgRoELrjgguKeJFbdf//900c+8pEet7r33nvT9ddfn6IL2p577ll1vaeffrqYH/c6CgECBAgQIECgVoG2CQBFc6h4mhbBnylTpqRvfetbRd/23iAuu+yyYiDFCPQcffTRC6x6zTXXFPMqU8cvsJIZBAgQIECAAIEeBCKY881vfrMYT+hzn/vcfNlIq23ywgsvFJlJo3l3DBC98sorz7dajCt45513FvPcn8xH4w0BAgQIECDQh0D1QW362GgoLo6na7fffnuRyj1utGJg577KtttuW6wSzbIjcFRZbrrpps70qQcccEDlItMECBAgQIAAgT4FYrDG73znO0V20Y9+9KN9Bn9ih5GRdNKkScU2kWQi0r+XZcaMGekb3/hGkbo9BniO9PAKAQIECBAgQKBWgbZoARQ3WD/4wQ+Kc46sGbvttluP57/66qsXT9ZihWhafe211xbjBe23335p6tSpxU+kh7/iiiuKfRx00EFFi6Ied2gBAQIECBAgQKCKwHnnndeZ0j2ygsZPTyXGB3rXu96VxowZU7RKjjTx0VI5HkjtuOOOKQalvuqqq9Ljjz+eVl111XTIIYf0tCvzCRAgQIAAAQJVBdoiABRZumLw57LMmTOnnFzgtfJJWtxMxThBkakrUq7GTVb8RIkMHDGe0GabbbbAPswgQIAAAQIECPQlcOutt3au0tu9Saw0d+7cznUjQ9gpp5ySTjrppHT33Xenc845p1gWKeJjAOkIDsUYQQoBAgQIECBAoB6BtggARRPoq6++up7z7lw3nrRFF6999923eEo3bdq0NHny5DR+/PjOdUwQIECAAAECBOoViIdM/S0xvs+pp56apk+fnh577LEiGUU8nIo08QoBAgQIECBAoD8CbREA6s+Jd98mUrGutNJKxU/3Zd4TIECAAAECBFohEGMa1jKuYSuOTZ0ECBAgQIDA8BLwGGl4XS9HS4AAAQIECBAgQIAAAQIECBCoW0AAqG4yGxAgQIAAAQIECBAgQIAAAQIEhpeAANDwul6OlgABAgQIECBAgAABAgQIECBQt4AAUN1kNiBAgAABAgQIECBAgAABAgQIDC8BAaDhdb0cLQECBAgQIECAAAECBAgQIECgbgEBoLrJbECAAAECBAgQIECAAAECBAgQGF4CAkDD63o5WgIECBAgQIAAAQIECBAgQIBA3QICQHWT2YAAAQIECBAgQIAAAQIECBAgMLwEBICG1/VytAQIECBAgAABAgQIECBAgACBugUEgOomswEBAgQIECBAgAABAgQIECBAYHgJCAANr+vlaAkQIECAAAECBAgQIECAAAECdQsIANVNZgMCBAgQIECAAAECBAgQIECAwPASEAAaXtfL0RIgQIAAAQIECBAgQIAAAQIE6hYQAKqbzAYECBAgQIAAAQIECBAgQIAAgeElIAA0vK6XoyVAgAABAgQIECBAgAABAgQI1C0gAFQ3mQ0IECBAgAABAgQIECBAgAABAsNLQABoeF0vR0uAAAECBAgQIECAAAECBAgQqFtAAKhuMhsQIECAAAECBAgQIECAAAECBIaXgADQ8LpejpYAAQIECBAgQIAAAQIECBAgULeAAFDdZDYgQIAAAQIECBAgQIAAAQIECAwvAQGg4XW9HC0BAgQIECBAgAABAgQIECBAoG4BAaC6yWxAgAABAgQIECBAgAABAgQIEBheAgJAw+t6OVoCBAgQIECAAAECBAgQIECAQN0CAkB1k9mAAAECBAgQIECAAAECBAgQIDC8BASAhtf1crQECBAgQIAAAQIECBAgQIAAgboFBIDqJrMBAQIECBAgQIAAAQIECBAgQGB4CQgADa/r5WgJECBAgAABAgQIECBAgAABAnULCADVTWYDAgQIECBAgAABAgQIECBAgMDwEhAAGl7Xy9ESIECAAAECBAgQIECAAAECBOoWEACqm8wGBAgQIECAAAECBAgQIECAAIHhJSAANLyul6MlQIAAAQIECBAgQIAAAQIECNQtIABUN5kNCBAgQIAAAQIECBAgQIAAAQLDS0AAaHhdL0dLgAABAgQIECBAgAABAgQIEKhbQACobjIbECBAgAABAgQIECBAgAABAgSGl4AA0PC6Xo6WAAECBAgQIECAAAECBAgQIFC3gABQ3WQ2IECAAAECBAgQIECAAAECBAgMLwEBoOF1vRwtAQIECBAgQIAAAQIECBAgQKBuAQGguslsQIAAAQIECBAgQIAAAQIECBAYXgICQMPrejlaAgQIECBAgAABAgQIECBAgEDdAgJAdZPZgAABAgQIECBAgAABAgQIECAwvAQEgIbX9XK0BAgQIECAAAECBAgQIECAAIG6BQSA6iazAQECBAgQIECAAAECBAgQIEBgeAkIAA2v6+VoCRAgQIAAAQIECBAgQIAAAQJ1CwgA1U1mAwIECBAgQIAAAQIECBAgQIDA8BIQABpe18vREiBAgAABAgQIECBAgAABAgTqFhAAqpvMBgQIECBAgAABAgQIECBAgACB4SUgADS8rpejJUCAAAECBAgQIECAAAECBAjULSAAVDeZDQgQIECAAAECBAgQIECAAAECw0tAAGh4XS9HS4AAAQIECBAgQIAAAQIECBCoW0AAqG4yGxAgQIAAAQIECBAgQIAAAQIEhpeAANDwul6OlgABAgQIECBAgAABAgQIECBQt4AAUN1kNiBAgAABAgQIECBAgMD/Z+88wN0ozoU9BDCdS8ehXMBgMN305mB6MwkQTC+md0w3EIwh9Bp6IDTTjDEl9GYI2PyEbiD0UEIPjunEgCmBn3dyR8jH0jkqK50j6f2eR0fS7uzs7Ds6uzPffEUCEpCABBqLgAqgxuovWysBCUhAAhKQgAQkIAEJSEACEpCABMomoAKobGQeIAEJSEACEpCABCQgAQlIQAISkIAEGouACqDG6i9bKwEJSEACEpCABCQgAQlIQAISkIAEyiagAqhsZB4gAQlIQAISkIAEJCABCUhAAhKQgAQai4AKoMbqL1srAQlIQAISkIAEJCABCUhAAhKQgATKJqACqGxkHiABCUhAAhKQgAQkIAEJSEACEpCABBqLgAqgxuovWysBCUhAAhKQgAQkIAEJSEACEpCABMomoAKobGQeIAEJSEACEpCABCQgAQlIQAISkIAEGouACqDG6i9bKwEJSEACEpCABCQgAQlIQAISkIAEyiYwRdlHeEBZBL7//vvw7bffhrFjx5Z1HIWnL/sIDyiFQCl9IftSSFZWRv6VccviqFLYcx5//1nQnrSOUvjLflJuWW0phX/+ucaPHx9+/PHH/E1N8zld18cff1zR+KRpQHShCyn399mFmt4UTZF/53aj/DuPv+w7jz1nLpf/N998Exv8ww8/VNxwFUAVoyvtwMkmmyxMPvnkYbrppivtAEvVnIB9UXPE7Z5A/u3iqelO2dcUb4eVy79DRDUtUC7/bt261bQ9XaHyaaaZxvFJV+iIn9pQ7u+zizS7aZoh/87tSvl3Hn/Zdx57zlwu/ymm+K/6Bh1DpaICqFJyJR6H8ofXDDPMUOIRPxcb//NHP2VIoJS+kH2GwNtUJf82QOr4tRT2NMfff206pRT+sq8Ne2othX/+2VEAVTPAyq+rq31O1zXttNOWzaWrXUuztKfc32ezXHdXuQ75d25PyL/z+Mu+89hz5nL5p8Wp9ByvpPXGAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYioAKogTrLpkpAAhKQgAQkIAEJSEACEpCABCQggUoIqACqhJrHSEACEpCABCQgAQlIQAISkIAEJCCBBiKgAqiBOsumSkACEpCABCQgAQlIQAISkIAEJCCBSgioAKqEmsdIQAISkIAEJCABCUhAAhKQgAQkIIEGIqACqIE6y6ZKQAISkIAEJCABCUhAAhKQgAQkIIFKCKgAqoSax0hAAhKQgAQkIAEJSEACEpCABCQggQYiMEUDtbVmTf3mm2/CjTfeGJ566qnw6aefhp49e4bevXuHDTbYIEw++eQ1O68VS0ACEpCABCQggWIEXnnllXDDDTeEt99+O0w33XRhySWXDGuttVbo0aNHsUPcLgEJSEACEpCABIoSaHkF0GeffRb22Wef8O6770ZIs8wyS7jnnnvi65FHHgnHHHNM6NatW1GA7pCABCQgAQlIQAJZE2Bh6pxzzonVTj/9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AAEEEEAAgVAESACF0tPEiQACCCCAAAIIIIAAAggggAACwQqQAAq26wkcAQQQQAABBBBAAAEEEEAAAQRCESABFEpPEycCCCCAAAIIIIAAAggggAACCAQrQAIo2K4ncAQQQAABBBBAAAEEEEAAAQQQCEWABFAoPU2cCCCAAAIIIIAAAggggAACCCAQrAAJoGC7nsARQAABBBBAAAEEEEAAAQQQQCAUARJAofQ0cSKAAAIIIIAAAggggAACCCCAQLACJICC7XoCRwABBBBAAAEEEEAAAQQQQACBUARIAIXS08SJAAIIIIAAAggggAACCCCAAALBCpAACrbrCRwBBBBAAAEEEEAAAQQQQAABBEIRIAEUSk8TJwIIIIAAAggggAACCCCAAAIIBCtAAijYridwBBBAAAEEEEAAAQQQQAABBBAIRYAEUCg9TZwIIIAAAggggAACCCCAAAIIIBCsAAmgYLuewBFAAAEEEEAAAQQQQAABBBBAIBQBEkCh9DRxIoAAAggggAACCCCAAAIIIIBAsAIkgILtegJHAAEEEEAAAQQQQAABBBBAAIFQBEgAhdLTxIkAAggggAACCCCAAAIIIIAAAsEKkAAKtusJHAEEEEAAAQQQQAABBBBAAAEEQhEgARRKTxMnAggggAACCCCAAAIIIIAAAggEK0ACKNiuJ3AEEEAAAQQQQAABBBBAAAEEEAhFgARQKD1NnAgggAACCCCAAAIIIIAAAgggEKwACaBgu57AEUAAAQQQQAABBBBAAAEEEEAgFAESQKH0NHEigAACCCCAAAIIIIAAAggggECwAiSAgu16AkcAAQQQQAABBBBAAAEEEEAAgVAESACF0tPEiQACCCCAAAIIIIAAAggggAACwQqQAAq26wkcAQQQQAABBBBAAAEEEEAAAQRCESABFEpPEycCCCCAAAIIIIAAAggggAACCAQr8F89p5h6msZ+wgAAAABJRU5ErkJggg==" width="576" /></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIAAAAPACAYAAABNVwK4AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAASAoAMABAAAAAEAAAPAAAAAAL6J26wAAEAASURBVHgB7J0FvBxF9raLeG4SbiACIRAkhCCLswR3JwSHxd012IaFP8EX2cVlcRYJwVncg7s7BEhwEsjGXebrt/arpmfuSE9Pz73dM8/5/eZOT3d1ddVTPXO73z51znwZzwwGAQhAAAIQgAAEIAABCEAAAhCAAAQgULMEWtVsz+gYBCAAAQhAAAIQgAAEIAABCEAAAhCAgCWAAMSJAAEIQAACEIAABCAAAQhAAAIQgAAEapwAAlCNDzDdgwAEIAABCEAAAhCAAAQgAAEIQAACCECcAxCAAAQgAAEIQAACEIAABCAAAQhAoMYJIADV+ADTPQhAAAIQgAAEIAABCEAAAhCAAAQggADEOQABCEAAAhCAAAQgAAEIQAACEIAABGqcAAJQjQ8w3YMABCAAAQhAAAIQgAAEIAABCEAAAghAnAMQgAAEIAABCEAAAhCAAAQgAAEIQKDGCSAA1fgA0z0IQAACEIAABCAAAQhAAAIQgAAEIIAAxDkAAQhAAAIQgAAEIAABCEAAAhCAAARqnAACUI0PMN2DAAQgAAEIQAACEIAABCAAAQhAAAIIQJwDEIAABCAAAQhAAAIQgAAEIAABCECgxgkgANX4ANM9CEAAAhCAAAQgAAEIQAACEIAABCDQBgTJJTB16lTz5Zdfhm5ghw4dTGNjo3117tw59H4UTD6BUaNGmfHjx9uGLrbYYqZHjx7Jb3TIFs6YMcN89tlnIUuXLtbQ0GCWXXbZ0gUpkZfAb7/9Zn744Qe7rW3btmbFFVfMW46VEIAABCAAAQhAAAIQgEC6CCAAJXi8PvjgA7PeeutFaqFEAu17yCGHmI033jhSHeyUHAJDhgwx99xzj23Q5Zdfbo499tjkNK7Clnz99ddm9dVXr7CWP3ZfY401zNtvv/3HCpbKIqDz7Oijj7b79OzZ04wZM6as/SkMAQhAAAIQgAAEIAABCCSTAFPAkjkuFbdKT/Dvuusus8kmm5gDDjjAzJs3r+I6qQACEIAABCAAAQhAAAIQgAAEIACBdBLAAyhF47bvvvuaTp06FWzx5MmTzffff2+njQWf2t966612ytBFF11UcF82QKClCGjK1tprr1308O+9956ZOXOmLdOnTx/Tu3fvguWZ/lUQDRsgAAEIQAACEIAABCAAgTomMF/Gszruf6K7/uqrr2ZNAfv5559Nr169SrZ5zpw55t///rfRtKHff//dlm/VqpUVhpZeeumS+1MgeQRefvll891339mG/fnPfzb9+/dPXiOr2KIll1zSjB492h5BQubJJ59cxaPVd9VXX301U8Dq+xSg9xCAAAQgAAEIQAACNUoAD6AaHNg2bdqYgw46yCy++OJmyy23tNO/NAXs2muvNf/85z9rsMe136X111/f6IVBAAIQgAAEIAABCEAAAhCAAASiECAGUBRqKdlns802M+uss47f2nfeecdfZgECEIAABCAAAQhAAAIQgAAEIACB+iGAB1CNj7VSOL/yyiu2l4oPFMYUS+jDDz+0r48++sh07drVrLLKKvalqUeaThbWXnvtNaOpbN9++61p3769jfWieC+K4yL74osvzK+//mqXV1ttNTP//PPbZfdHx//vf/9rPyqrmbyblB3toYcestmJVl55ZbPnnns22U87xNkPZZXS65tvvrHp2JdZZhmz/PLL21ffvn3NfPPN55pc9D1qPUqTPnbsWFt3v379isbAUaFffvnFSPDTfl999ZVZaKGFzEorrWRfipFTagw/+eQTf/qgRMR27drZY2samsb09ddfN0oRrjFTBq+kxd3ROaVzS9a6devQ3lNvvvmmmT59ut1v1VVXNY2NjXY5yGPAgAGmY8eOZtasWebdd9+1PLR9kUUWMcstt5zZaaedjOIalWOVnqs6r6ZOnWoP2a1bt8Smbldweo2LXl9++aWZNGmS/X3RFL+NNtrIiHkx03d/woQJtoi+f8pSVsjk9fjSSy/5m+VBp3MhaC35+xI8p9L4HQtyZBkCEIAABCAAAQhAICUEFAMISyYBT7hRfCb/5cUAKruh3o2Fv/+6665bcn9vmljG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AQhAAAIQgAAEIACBYgQk8kjsUTwfiT8SgaJahw4dfNGnU6dOUathPwhAAAIQSCgBBCBvYPQP85577jFfffWVGTdunOndu7fZfPPNzYYbbph3XrOyJdxwww1Fh3Tbbbc1Sy+9dNEybIQABCAAAQhAAAIQgEC5BGbPnu2LPprmpRg/Ua2hocEXfTp27Bi1GvaDAAQgAIEUEKh7AeiNN94w5557rn1iovHq3r27+fbbb83LL79sNttsMzN06NAmw/j111+b++67r8n64IpVVlkFASgIhGUIQAACEIAABCAAgcgEFLjZZe5SQOdKTFO6lLlL07vat29fSVXsCwEIQAACKSJQ1wKQPH/OOussM2XKFLPRRhuZE0880WY1kPvsxRdfbJ599lnTt29fs/fee2cN6ciRI+3n1Vdf3WyyySZZ29yHfv36uUXeIQABCEAAAhCAAAQgUDYBpWjX9aqEH12vVmLK2CXBRy/F98EgAAEI1BsBeU8+88wzRk4g8p5cbLHFzNZbb22WX375ukFR1wLQzTffbP+ZLrfccubss8/2g9s1NjaaM8880+y3337m+uuvNyuttJJ9ubPCCUAOpVNiAABAAElEQVQSfwYNGuRW8w4BCEAAAhCAAAQgAIGKCEyfPt0XfRR2IKopU5euaZ3oo/TtGAQgAIF6JfDCCy+Ygw46yM72CTI46aSTzC677GLv+/V7WevWqtY7WKx/n3zyid281157+eKPK69/ktttt52dU/3888+71fZdU8Bk/fv3t+/8gQAEIAABCEAAAhCAQFQCU6dONT/88IP56KOPzMcff2x++uknE0X80T7yYD/ttNOMbnaWWWYZ06NHD4P4E3Vk2A8CEKgFAo8//rgN76JQL/lM4V3WXXddPyxMvjK1sq5uHwUoWJ7+0cqWXHLJvOO5yCKL2PUffPCBv33OnDlWNdQ/0qWWWsqul/uY5k8zh9rHxAIEIAABCEAAAhCAQAECug7V9C4JNr/88ovR9WVU03WoYleOGDHCvPnmm0axgmQSguStrpAFGAQgAIF6JaAptHL4UMbEYvb555+bwYMHG80SqmWrWwFIbrHKeqB/knK1zWf6hyrT3Gtn3333ndHcwT59+phhw4aZBx980GYOa9WqlV23zz77mC222MIV5x0CEIAABCAAAQhAAALWq1zXli6QcyWij7LWvvjii9bL55133il4Y6OYlsOHD4c+BCAAgboloOzdEyZMCNX/W2+91Zx//vlm4YUXDlU+jYXqVgDSYC2xxBJG3j1vv/123ulc7733nh3TYNA9F//n+++/NzfeeKPNGqYnK6NHj7avc845x2i/IUOGFD0fLrzwQvtkJl8hiUuy33//vaK0nvnqTus6l95UFzwS77D0EQiq7hJVGcf0jaFaPG/ePPu7NHbs2HR2gFb7BPSdZBx9HKlc0PVJlGlCqexsShut6xc9aNQ46aXf0Kj266+/Wi8fTe368MMPQ10jPv3003zPowIPsR/XpyEgJbxI8DvJ9WnCB6tI84pdn2r6V1jTd/qhhx4yO+20U9hdmrWcPEdlwfO23AbUtQC01VZbWQHo3//+t1l55ZXNiiuu6PPTUxVFCJfJ40cng25YXfyfLl26WHVQ6d5l2i5voMsuu8w89thjZq211rKZxezGPH8kZEhEymddu3a1q3VxHrxpzle23tZVcrLXG6sk95dxTPLohGsbv03hOCW9FOOY9BEq3j5dezCGxRm1xFb9j5sxY4YVfPSucYpqCjnQsWNHc8EFF5jbbrut7GrkbaQbBmIAlY2urB24rikLV2ILM46JHZrQDcv3P3HMmDGh91dBlc9XT1mVVKlwHO2qawFom222MXoyIo+do48+2gwYMMD07t3bevLInXbnnXc2999/v50q5rwVlBls0003tVkVXIwgja+2SymUJ5CEoDvuuKOoAKTyrs7c80PTyTAIQAACEIAABCAAgXQQ0I2j8/SR6FOJtW3b1oo+ClWgZZmCREexTp06If5EAcc+EIBAzRAoN7NXueXTBqquBSAJMJobfd111xlF/n799dft+HXv3t0cddRRZp111rECUOfOnf1xleeP0sYXss0228wKQKNGjbKuWYXEHE0B0yufPfXUU+bYY481Cy20kM3ckK9Mva3TxZSeYpHJIr0jr/FzF8X6jrmL2vT2qD5brjnUiluhMcTSSUABZ2WtW7c2PXv2TGcnaLUNHKxrkuA1Clial4A8xF08Hxc3MmoLJNQsuOCCNmV7hw4dmlQjr3U9lCzXNt54Y9OrV69yd6N8SAJcn4YEleBiXJ8meHDKaJquT/WbrHvFXNt88839+/zcbfk+Dxo0KLG/m24KWCGNIV9/ctfVtQAkGO3atTPHHHOMOfTQQ+30Ll1ILb744pbTW2+9Zd/LCQIl0Uam4NJ6WqOLMwwCEIAABCAAAQhAIP0EdPHtRJ9gjMgoPVP2WE3vkqAu8aeY/eUvf7Gp3cuN23XccccVq5ZtEIAABGqegO7zL7roIv9BdLEOS/xZwosTXMsWWQBSIDr3FDEuQHpCUY7YEsdx5bKrl/4Jr7DCCllVvv/++/ZzMDbQvffea7N+6UlMvpPDzTGcf/75EX+yaPIBAhCAAAQgAAEIpI+ApnZJ9NEr6lQs9Vqe57o+lNgjLx8nIIXxiNUDSmWnGThwYOjgn0ceeaSRZzoGAQhAoJ4JKMTLlVdeaQ455JCiGKRDXHPNNUXL1MLGyAKQpk2deeaZsTJQfUOHDo21zmKVXX311eaee+4xe+yxhzn88MOzimqKwxNPPGHXrb322v62Z5991nz22Wc2OFS+tr7yyiu2bK6Y5FfAAgQgAAEIQAACEIBAogkoY5cyAkn0kQAU1eSm39jYaKd2Ka6Epl7KotS59dZb20QjikdZzBNIAZ+Vjfass86K2mz2gwAEIFBTBA4++GB/5k++KbtrrLGGufvuu2084JrqeJ7ORBaA8tSVulXy7Bk+fLiN2bPXXnv5HjvyCFJsIGXqWnXVVW2GMNc5zaWWAPT888+bvffe2/Tt29dtMu+++66Rh5DsoIMO8tezAAEIQAACEIAABCCQXALK1CXvHif6uDgLUVoskUcZXSX4SPxxok+UunL3kQf6t99+a29UXnrpJfPNN98Y3czIk10hDJSdVg82l1pqqdxd+QwBCECgrgnsu+++ZttttzV33XWXeeONN8zkyZPNoosuapQYSq9CCZpqDVpkAWiHHXYwSy65ZF4eX331lTnvvPPsNv0z0ry7fv36WcCKuaP0519++aV1sfrhhx9ssONhw4YVDa6c90AVrlxvvfWM1D5l/NLc6o022siKQG+++aaNB6QgUnqCErRdd93VvPbaa0bTw/bff3+z+uqr25fSw48YMcIWlctt//79g7uxDAEIQAACEIAABCCQIAISfXQD4EQfBRCNavK6keCjl6Z5VRKgs1QbFDD6wAMPtK9SZdkOAQhAAAJ/EOjWrZvN/q0M4PVqkQWglVdeOcszxgH8/fffzdlnn20/nnPOOeavf/1rk2w/Ek1kJ5xwgjn55JPNFVdcYf7v//7PpmS3G5rpj/45q63XXnutefTRR83DDz9sjyz1b5NNNrHTwnIzJ+gpjoJI3XnnnUailbx+9JIttthiNnvXWmutZT/zBwIQgAAEIAABCEAgOQTk5S2PGYk+Lqth1NYpdo/L3KWkH/Xy9DgqL/aDAAQgAIGWJ9Aq7ibI80fuqPvss485/fTTm4g/wePJG+jSSy8166+/vvWqkaDS3KZ/2KeccoqN93P99dfblPCPPfaYnTedK/64tilwn6Z4KV27hCDFElK8ILUf8cdR4h0CEIAABFqSgB7AyJNVDzt0Y6r/uXoA88knn1S1WV988YXRXPslvCwaOqb+l+62225GMfLuu+8+s+WWW/pBcJdbbjn7P9glUNDDmO222862W1Na5D2sLEbyFs61n3/+2Zx44onW41Zl9VRPLtwPPfRQVtE77rjDeizrAY44yFND02M01z9Jpsyje+65p40/IG56qCRP448//jhJzYy1LTondG7oHFGfdc4oSKfOoTht7ty5VvDR9el7771n5KmuB5aK91iu6VxToNDll1/eTreSp7s8fhB/yiVJeQhAAAIQaAkC83nur5k4D6yLS/1zVbDkTTfdNFTV8gDSBZ6C2inDQb2bhKVjjz3WXizr4h0zNm2fAjGKhy7esfQR0PjNmDHDNlwpb8NkPUlfL2u/xe6JucYQSyYBeTb86U9/KpqpUx64Eoh69uwZayfkUXvMMccY3XCXY7qBXm211cwLL7yQd7eGhgZz++23m5122slu14MaTd12WZRyd1I5CT8ShArVqX222GIL+zAnd//m/qwHZm7qfO6xJSwoLqHErqApE6seYik7VNpMl57qjx4C5jOJdcrYcsQRR+TbHGqdxB39Xul/j94rudxVqnZN7ZK3j87FOExBoNUumcZQY4mlj4Cua7g+Td+4BVvM9WmQRnqX9Xuqaby1fu+s+HQrrbSSvWbYZZddIg1YrHfS+mf74Ycf2oboiUhYczcS1X4qGbY9lIMABCAAAQiklYCCwEocKGaXXHKJDRirhw1xmbJqKgZeFNOUnGJCjTIy7b777jbWnjxFJPDMmjWr4KEeeOABs8wyy5gff/yxYBltePrpp42SQMibt6XsH//4R0HxR22ScHHSSSdZ8eGAAw5oqWbGelxlpyok/uhAEhB1Lun6ULEXw5ou/nUzp5fOqUpEH8XZcaKPPL8xCEAAAhCAQC0QiHUKmDwzlPVApsDKYc2lTu/du3fYXSgHAQhAAAIQgEAOAcWoyzddKqeY/XjqqafmWx1pnbwZ4hST8jVCD5kkCihwYzHxx+1bSvxx5TR9W1ODWsIk1CkGYhiT19bEiRPDFE10mVGjRhUVvIKNlzdZqXTpOhd+/fVX8/nnn9sEHaNHj7acoog/8sLp06ePjXG5wgormEUWWcQg/gRHhGUIQAACEEg7gVgFIMFQVi3ZGWec4bu22hUF/iiF5Y033mi3KgsXBgEIQAACEIBANAKaghXW5FWjmDtx2JNPPmlcHJ846itUh+LhvP3224U2R16vpBUtYYpD5KbGljq+3NtdsopSZZO8Xd5WYWPv6JzSuZVrYibx7NNPPzUffPCBzS6rbF7lmqbXafqhYg+tuuqqNhut4vsozg8GAQhAAAIQqEUCsQtAgwcPtpxGjhxpNtxwQ/Pggw/mdcHVP2pdcCnYo5uvp8B/GAQgAAEIQAAC0QiUmvqVW6sSGMRhuglPsyl2YUtYudzef//9lmhmrMcstw+OkQTLn376yQbF/uijj6yn29SpU8tum0QfeasrELhEn2WXXdbGwiIuXdko2QECEIAABFJIINYYQOq/snvIPfuqq64y+getefoKmqeYQIsuuqhR4KLvv//eyEXXPfVSlg89hUxjIMMUjjlNhgAEIACBGiVQbvDlUtNrwmJy/8/Dlk9auTBTyqrR5nK56Roq7VZOH5Qlrm/fvja+ZDn75TJSJjyJProebWxsNAoyjUEAAhCAAATqkUDsApAgXn755TYC9wUXXGDnbisjiV75nvpo2tf9999v/ynX4wDQZwhAAAIQgEBcBHRzO27cuNDVyQMiDtNNeppNU4BawsrlVm75luhTqWMW64O8c1ZeeWWz8cYb29dCCy1kq4si/ri4lArkrO+FRCAMAhCAAAQgUO8EqiIA6Z+sYgAddNBB5rnnnrNPbpQdTC9N99L8amUp2Xnnnc0OO+xAOuh6PwvpPwQgAAEIxEJAac3vuuuuUHXpZjuuqdcDBw40uuEOG9slVAPzFJIXh47z+++/59kafVW1A1gXatmOO+5ozj///EKbs9ZrvAYNGpS1Lo0f1OcrrrjCb7q8cRQ/UqKPQgfISyeqaRqXBB+9FNtHzDAIQAACEIAABP4gUBUByFWvrF777ruv+8g7BCAAAQhAAAJVJHD99deb++67zz5sKXUYTdGOK8ORsiVJRFF6+WramWeeadt8+OGHlzxMWEFq6aWXNttss03J+qpRQMKHHobJE7qUSaxTW9Nu8vzedtttzZQpU4yW119/faPsW1GtXbt2VjSS6KNQAog+UUmyHwQgAAEI1AOBqgpAuQAVrE9pOYn1k0uGzxCAAAQgAIHKCej/60MPPWQTLMybN69ghYqtcs011xTcHmWDpn0rFXfUwNISAYplcjrwwAPNcccdZ5umbGBXX311wWb26tXLDB8+3BcaChWUl8jrr79eaHOzrL/pppvMd999Z955552Cx5N3jKbXp9kUn0qZzBQSYOjQoXkThITtn4RLeQpJ9OnUqVPY3SgHAQhAAAIQqHsCVZ0Q/dtvv5mTTjrJuvTq6aAuTPVPXzZq1Cj71EdPKotdpNb9CAEAAhCAAAQgUAYBebO8++67NstR7m7yitlnn33s9OzcbZV+1vSbRx55xFx88cU2DmCwPt2kH3rooWbXXXe1U7iC25QIQmLNN998Y6eOy6MjaH369DESSfRypkQTt912m1lyySXdKvuuNsjzWFm9NthgA5spSh4muSYvEYkqyirVvXv33M3N+lnxaV566SXzt7/9rYknjESOc8891zz11FOxeWs1Z+c07V/Xgl9++aUdE43x+PHjI4k/DQ0NRp7lK664ollppZVsYhHEn+YcTY4FAQhAAAK1QKAqHkDy8tGTqrPOOss+7ckHSlnAXnnlFfvac889za233kosoHygWAcBCEAAAhAok4Di7Olm++eff7YeQfK60DrF6ik3VXw5h1Y8Fz34OeGEE2zcPx1LIoaCTbdv395WNXHiRJslVF7BS3jBl5WG29mNN95oLrvsMrvvpEmTjMSfFVZYwW3OepeQpddnn31ms4vqIZMCCAenEylmkMQVpRC/9957bQZSiUa77bZbogSVjh07mvPOO88+JFPac8U4UgBkjVnaMlYpo5pEHr00hpWYxlRePjqH3PlTSX3sCwEIQAACEKh3AlURgHTxpos/mZ426mmN3Lq//vprn7cCRepJnZ4ODRs2zOjiRxd+GAQgAAEIQAAC8RCQ9+2RRx4ZT2Vl1KJkEBJ98mUZk8dLPq8cV71u+tddd133seT78ssvb/QqZvIe2W+//YoVScQ2eT+tueaaiWhLOY1Qli6JjBJ9FNunEtO0PIk+euV6g1VSL/tCAAIQgAAEIODpM3FD0Lz8U0891VarIH+KMaAneMcff3zW/PXNN9/cPp3ca6+9zMsvv2w9gE4++WTTv3//uJtEfRCAAAQgAIGyCShmyZtvvmkfXuhGVN4lip0Tt8lDRXF75C0hIUNTl/TARJ4UCvo7YMCAqnuBjBkzxrz22mvWa1fxcyTQ5JteM2PGDPPggw9a7109wOnWrZudhqVpVGuttZaR4FTKNAVc8W6cB9A666zT5EZfnsSaxqWYQpquJS75xKRSxwpu14Mnxfv59ttvrfeP6ltmmWWCRVK/nMtN5+tqq61Wsl/ykJJXtqbESaBbe+21jc6DYjZ9+nRf9NH+UU3jq2M60UcPDjEIQKDlCMgD8brrrrP3afpt33vvve20y5ZrEUeGAATiJBD7f9lLL73U6EmQLqzkbi3PnkK22GKL2Xntiy66qL2I0Pz+iy66qFBx1kMAAhCAAASahYDiy+hhhqZQBU1Zm6688kordgTXR1l+/PHH7RQmeU4UM92I//3vf6+KB4umaOkBjf5fSzxwpiC7Wn/mmWfaqTcSw4YMGWKnZxVL9b7DDjvYhz168JNrmqp1zDHHmOeffz5rk278zzjjDBvgWWLAo48+agYPHpzlNawdNFVMHsZbbrll1v5hPig72v/93/+ZsWPHZhWXp5HGs1JxKavSFvqg80ljNnLkyKwWSOQSt6233jprvT5IxDv77LNt9rZcEUdZ4jSdX9doziTayctH56zEwKgmDzFNz9PY6z1t09yi9pv9IJBkAvLe22qrrcyrr76a1UzFdVP8LT2o0P9ADAIQSDeB2INAa+66TBfOxcQfh01l5Ckky71ocWV4hwAEIAABCDQXgb/+9a9WbMkVf3R8ea7IQ0cXwpWYBAn97ysl/ugYEmn2339/c8opp1RyyCb7KhafLubvueeeLPFHBXVzr6xem222mfXU2XTTTc0//vEPU0z80X7uBkGeO0HTDYU8mXLFH5WRoCDBR8GbJThst912TcQflfviiy+siKEn0+WYpsAddthhTcQf1aF2yQPpmWeeKafKxJVVUGydT/muo7766iub5v7aa6/Narc8zHSzpyDTueKPCj7wwAP2/HAxlnR99+mnn1pRNIr4I5FHHmMK+i2vJHm36TPiT9aw8AECLUJAHqh6MJ8r/rjGyDtQv+Fp/610/eEdAvVMIFYBSE8IdXEgW3311UNz1QWI7Pvvvw+9DwUhAAEIQAACcRPQTW8pT1R5TWj6ctT/WRKWjjjiiLKbrqewypwZhyn75kEHHdTEwym3bk0L2nDDDc2LL76Yu6ngZ2V92nHHHa13iQrpxkLeJKViw9xxxx3Wg6Vgxd4GeSkdddRRdnpYsXJu27///W+TK3y4be5dYoayk+V6B7ntSX/XNMXjjjuuZDOPPvpo8/bbb/vl9KAunyAnQUbCoATHm2++2Y7br7/+aqck+juHXNB0rh49etjp/fKy6tu3r/X6kQcQBgEIJIeAfucnTJhQtEH6vyGBXuIxBgEIpJdArP+BddGg4I0yZfkIa7pYlIWJHRC2TspBAAIQgAAEyiWgqUhhTB4TF154YZiiTcocfPDBRhfSUSxs+0rV/eSTT5pPPvmkVDG7XSnlyzWl/b7rrrvsbldffXWs4ooeNmnaUimTWBSWl65ZNIU9jaaMq2HOJ5Vx3HTdpalvzpSUQ9PhNE3uiSeeMBqznXfe2Sj+R7mmeFnKYKb4QxJ9lHVNMX4QfcolSXkINA8B/S9wMzhKHVFhPhSzFYMABNJLIFYBSBgUJFP23HPP2fcwf5566ilb7E9/+lOY4pSBAAQgAAEIxE5AU6KcF2uYyhWrJooVcrEPU5emVimIcaXWHG78jzzyiG1mVE7F+igBS55YxUxJKcrx0nLtLVZn0rbJe6mcsdT1lp7eP/300zZLq6b2aQqY1l9yySVm4MCBVqwpt5+KGaVYVQrWrdT1iy++uOnSpYsN4F1uXZSHAASal8AVV1xR1gHT+FtZVgcpDIEaJxB7EGjNDx0xYoR9yqRgkJrjXcxuueUW+7RJZcqZNlasTrZBAAIQgAAEyiXw3XfflbXLDz/8YD0vyvVsUCDdSkztXGqppSqpwvz4448V7R9mZ8fTvYfZJ2wZPYVW5rJggOLcfcs9rgTAtJmmZpWKyxTsk4QaZWGTR45En/bt2wc3l7WsGI4LLrigndLV0NBQ1r4UhgAEkkPgm2++Kasx48aNK6s8hSEAgWQRiF0AUvDMO++80+jCWHPIFURSsQByTRdm55xzjp1frm3rrbeejRGQW47PEIAABCAAgeYgkC/tebHj6ma6XPFH9Wm6tKYxRbVy25nvOM1xw+6mhMfR3nx9cPXn26Z15R5XHitpszB9lEij+B4bbbSRvS7TdLeePXtG6qqO50Qfnf8YBCCQfgJhfkeCvdQ0TwwCEEgvgdgFIKXzVNBFZQ7RRYYCXerlnjIpJoDS6/7+++8+NV2IyhMoyoW0XwkLEIAABCAAgQoIrLDCCjZ75fTp00PVsuaaa4Yql1tIXitRp3HppjuO6dKaplPO1KHcPoT5/Oc//9kW07syUcVp8i7W9UYxU/yZcsQ2195idSZtmwIs9+nTp8lUN8Xg2Xjjja3oo6n5Ua+vJFQqNohiBClLGzd+STsDaA8EKiewxRZbmHKmdSm+FwYBCKSXQOwxgIRCFx1vvPGGWWuttXwycteWKZ1tUPzR/HOl1S01VcyviAUIQAACEIBAFQhoSsvee+8duuZDDz00dNlgwRNPPDH4saxltS8O7x1lvdJNfRiLctMvweGAAw6w1R9yyCFhDlNWmTB1LrDAAja7V9iKw9QZtq7mLOfarRTOEmluvfVW8/DDD5vBgwfbIMzlij+KrfTaa6+Z8847z2y99dbmmGOOsUJSlPOgOTlwLAhAIBqBww8/vCxx1wWTj3Y09oIABFqaQOweQK5DepKmCwilrNX7yJEj7UtZOZZZZhnTr18/KxQNGjTI7cI7BCAAAQhAoEUJKCCusiCVipGz1VZbmT322CNSW4888kibgemLL74oa//evXvbm/KydipQWF5IQ4YMsVOxCxSxq+VBc8011xjdIJQTa+a0004zyy67rK1D048OPPBAf8p3oePNP//8ZuGFFy7pLaR4gccee2yharLWX3zxxTYphcs2mrUx8GGXXXax6Y0Dq1KxqCDQEgXlFVZJJlXV8/rrr9sYjq+88ooJxqlSljEe0qXidKCREIhEoE2bNjYL4lFHHVVyf83w2MibTopBAALpJVA1AUhI5ptvPvv0TU8aMQhAAAIQgEDSCSg2yvPPP2/FAKUyz2fbb7+9ueOOOyrKcKTU6hIywopA/fv3t14dUWO35OvH0Ucfbb2AzjzzzLxpxBUTR/3UgxoFnd52221NmOlxEpYkGgTtX//6l+V10003BVf7yxK3HnroIaP3nXbayXoR+xsDC+uvv765//77Tdj4MxK6NJ7qg4If5zMJeYXala98S67TQzSJM//973+NRC0XSyqK+CNxb9q0aTZWozK3Ok9t1z9dw0nIU2p4DAIQqG0CejCh3xT9PyhkG2ywQdWnDhc6NushAIH4CMQuAF1//fXms88+M3KNVzrQMKZg0Hriut1225lTTz01zC6UgQAEIAABCFSFgDxUP/roIzuVRmLD119/bd3jV1ppJbPffvuZbbbZpuLjahqXUrpfe+21Nv22EifoZl7TbJShSUE5582bZz0vJIhoOlU1puDo5l71qx3y/Bg/frz1JFFMCAlEijEj09RuTeE+/fTTzb333muUBUbtk4igGH+KQyNxRp5Cii+Ua5puduONN1p+ElvefvttKz4sscQS9n//YYcd5gdtfvXVV43iBd59992WkYQIXU9IqNltt93KFt7kHaPrEh1fIpPiL0lAUowgeSZpKnqSTaLP5MmTreij8dEUraimJ/2aGqeXPK40PUxsr776apsV7KeffrLn3zrrrGPjN+qcxyAAgfogMHToUPOXv/zF/o4rPIcEf/129+3b14r6O++8c32AoJcQqHEC83kXFpk4+6gnhI8//rh59NFH7dPCMHXr4ktP6OTGfPvtt4fZpabLPPnkk+a4444zjz32mOnWrVtN9zVs53RjpIte3QCVG88g7DEoV10Cs2bN8r0MGMfqsq5m7RpH/dtwgf2reSzqrg4BTfeRSVhhHKvDuNJa9R2Td86UKVPsS2JbVJNIp4xpeinOlcYda3kC7rpGLdEYhY3J1fItpwVBAm4cua4JUknXMten6RqvQq3VfaL+V9b6dY28dTW1Xg40eigWxWL3ACqnEfrRVGygDz/80O4WR2DLco6f9LI6iSu56Et6/8ppn9Mp9Q6Tcsglp6wbQ7WIMUzOuERtCWMYlVxy9uP3NDljoZboOyXRR1O89Ar+ZpbbUnn6SPCRJ5kuhp3oozorqbfcdlC+MIHgOGiZ39TCrJK8xY0jY5jkUQrfNr6H4VklraT7Ltb6GMbRv4oEIHn7aN540Jxr8o477ljSU8MpdW7/NdZYwy3W9bu7UJOLNh5A/zsV9MRaru9K+6sLWyx9BDR+zvNA48jTzvSNoVo8YcIEGwzY/TbpH5GmBP3nP/+xU2vkYbDaaquZ/fff36y44oqxdFLpyjW1yE2T0rmjNLRKMiDXdGdyWf/rX/9q01brBlq/pboBVgBbtWmfffYxa6+9tite9F0PKPRk5amnnrI35e7CQnXq+DqHt9xyS6OgmQMGDChaV3Djm2++aT1dP/74Y+vVqOlmhQIQ6//r8OHDbX/Gjh1rp4jppl6JFH799Vc7Tc3FbZEHgf5n6PdR04X0NFqM9IRok002CTbBTuXSCu3jxjGrQJEP4vDggw+aBx54wHzzzTdWXFCacU2NE2Nnmjpw880329g6o0ePtn3V8cRPbNVOBXxW3zX9S7F/ipliJd1yyy126pjGdon/P3VM0xV0DirjldIYKzaOxkdjrult+RJNaEzvueceG39JHqUrrLCC2WuvvewUNqWrV7s1RU3eN4qto4dTOu81jUxZTHXtovaL3eKLL24ZTJw40fTq1cto6tz+3rmv8ZVHsxtnTTkTO42XBBmladdnTatTXCdlTdV5FDa2UT5W+u5pWuENN9xgdJ7JxFVZwk444YR8u7CuBQnoO6LzSqZzTDG3sPQR4Po0fWOW22KuT3OJpPOzfk/1/7nc65q09dZd91UyI6aiKWC6INP8cCf6VAJQc/Q1DczFG6ikrrTvq4tTZThRPAZ4/G803T9Y8UAASucZHvwH2717dwSgdA6jLwBpDBVUVzEB3n///Sa90Y3+8ccfb5SFSTf+UW299dYziglTyCTAXHXVVXYK8Z133lmomL9eU40Vq043y4VMgpOyfIV9yqIbfgU5LuZ2rH/YRxxxhBUx8h1XwTUlSkgYmDRpkhWrlMo7DpNQpanFziQ6yDQu5QSVVnwYjbcTF1x97l39u/zyy817771nFCh7zJgxblPRd4lVV1xxhRWCcgtKJDnjjDPM+eefn3c8lPpcx5ELfz6TsPLyyy/b/xv6DVIcIf2PzWeKhaPA3xKoKjGJOE7szlePxEONt+IqKWNqJWK4jqXvoo6nuD2FmEtsk6iloNhYMggEBSAJuwhAyRiXclvB9Wm5xJJXnuvT5I1JlBY5AajW7511PSn95bzzzrMP0aKwqsiVQileFThSFxXOFMz5+++/N1tvvbUNCunW53vXRY+ezi655JL2SaueXmIQgAAEIJB8AsoWojnI8srJZ7pxv/TSS+2NqdKIRzHVX0z8UZ0KXvvSSy9ZT4swx1BWKwksCgYskSrXPvnkE+vFkbu+2Odbb73Vet3II6mQycNEAaULmfqgeHgSKySe6D0uk+Cx+eabV5S9RRdWSv2rgNiFTNcDOh/kuaSb27Am8UYeXnqaJW+VoCkxxIUXXhhclbVc6Pxzhd544w3rWaPzSKLeW2+95TY1eZeHTxyWT/zRBan4SfRRkOxKRFGJBQsuuKB9+KbrJnGT95HO60ImjzE9aNN7JV5GhepnPQQgAAEIQAAC6SBQkQCkLh500EH25bqraWESgPRUVssYBCAAAQjUHoFTTjmloPgT7K1EAU3TkcdDOaYbd4kiYUzTbMoxedYMGzbMTvvJ3S9qRiiJO5oKt+uuu+ZWadcXE3/cDp9++ql9mhOn+OPqfvbZZ222TT2ciWKaTlVM/HF1KgFEVJPHmLKByltFJk+iYuJP2OOoHglwxcSfsHWVU07TryT46KVpZvkExzD1zZkzx2h6o87zyy67zM+W5jy51Ldi4o87hqapyQOumFDpyvIOAQhAAAIQgEBtEqhYAMrFohgLckPu379/7iY+QwACEIBADRBQjBl50oQ1eQCVKwDleoKEPVbYcmqTbpyDpvgxirUT1VRnPgFIIlhYe+GFF8IWLbucUrhHEYDk0aK4ONU2BUC+7bbbjMRFmabVxWWKUdUcttRSS1nBR94+itUU1eTiLRFU54MEQX3nZAMHDrQeYsF6lTE0rClOEgYBCEAAAhCAQP0SiF0A0lMoTQ0oNB8/H2oFqdTUMT35k7s3BgEIQAACySXwwQcf2EDQYVv42muvhS3ql1OA4Wqa4tgoxk8wiF7UqWqunYX6WWi92y/4HjbuUHCfsMsKcBzFPvroIxsIO8q+5e4TZBVcLree3PKVxvXJrS/4WcG2nadPnz59gpvKWlZwa01Vk+ij93xTycREUwSdySurnDiMujZT7C5NvccgAAEIQAACEKg/ArELQHrK9vjjj9t4AwqoGMZ0sfP6669nZXMJsx9lIAABCECg+QmEmW4SbJXLdBNcV2pZ016qaRIEdMMdDLyq+CiVmG6uddMejLEiTw69kmDlPJgJtldTh5rLgscq9zxrrjZqKpcyn0n0kaePm7IW5fjqrzx8lARDU9RKiTm5TNw0sHKO/fPPPyMAlQOMshCAAAQgAIEaIhC7AFQOG12Ajxw50nz44Yd2N6XBxCAAAQhAINkElBq7HFOmpnJNWbpK3QyXW2ewvISfoPijbWussUawSNnLCswbFH9UgTKDKSXpuHHjyq4v7h0UPDiKlUrRHqXOQvsEs1TpuKWCPBeqJ+71Ctqs80Oij4KTa6yjmlLJv/jii1b0UQa9cryTcsdC3kflmuIRYRCAAAQgAAEI1CeBigQgBXlWto+guQv2HXfcMcu1PljGLats0N290otvVy/vEIAABCBQPQJKP6nU07qRDWPKvlSuKWZQJQGFSx0vXywcpXM/4IADSu1acHu+OlVY68PGTNKDEMXCqYatv/76kaqVN6+mNinBQ7UteK6Im+LgxGES+1wcnbD1KT290sjLy0fnY65gGLYelZPXjbyd5elTbtDy4HFyzzF9D5VWPqyXnYQrlccgAAEIQAACEKhPAq0q6fY///lPK+A4F3e9O0FH4k5wfb5lV1ZtUHrSHXbYoZLmsC8EIAABCDQDAXlDnHbaaaGOJEHjhBNOCFU2WOiee+6JnDUpWE++ZcX9KRRvLqpIojqHDBmS73B2fdi038qEVQ1T+yqJcaQsYGEsGFMpTPlgmX79+pnddtvNX6VsonGJFRdccIFfb7EFna+bb765Of/8883TTz9tLr74YpvRNIr4M3r0aHPLLbeYfffd1+ih2OWXX16R+CNxbPXVV2/SfAX3DmthxzFsfZSDAAQgAAEIQCBdBCryAFp22WWNspu8/fbbfq8VzFlPCfWUqlQwxLZt29p0pgpGqIu+BRZYwK+HBQhAAAIQSC6BY4891sYueeCBBwo2UqKHsjrlTlspuENgg6aAXX311ebII48MrM2/qJt0ZY7KZDL5C+Ss1Y34KquskrP2fx+Ven7++ecv21tE4ooeZOQzTbnR9sMOOyzfZn+dtp933nlG/xvPOussf30cC+pzuVP3gsc9+OCDjdjcfvvtwdVZy4qNo8xd6qsChZdjYn7//ffbvrv9NHVu+PDhZtCgQWUllnD7u3eJHjqPvvvuO3PRRRe51f67ji0PH03vWnPNNY08f6Lal19+ab185O0jASgu03XSrbfemre6E0880Si7l6aVFbNNNtnEVEtgLHZctkEAAhCAAAQgkCAC3gVzrLbNNtvoCjzjue7HWm89Vfbkk09mvPSxGS8dcT11u2hfp0+fnvFc6DOeZ1nRcmxMLgEvxbYdQ42jF4w2uQ2lZUUJjB8/PuNlerRlvEDNmTPPPDPjiTX2d1+//e7lPSDIjBgxomhdYTbeeeedmTZt2vj1uvr17sW0yXgx5Gw1nrdGxvMWyVvO7ePFl8l4glXJw6pfar/br9i7FwA44yU/KFmnCjz88MOZxRdfvEm9ngCRufTSS7Pq8G72Mz169GhStlhb8m3r1KlTZtiwYVl16zuo15gxY7LWl/rgee1mPE8ayz33WH379s3of5dsypQpmYMOOih02z2vq4yXoazg4b0kERlv2mGT+jyhJuOJH5m11167yTa1z4u/lPHEqKx6r7vuuownLNnXTjvtlLnqqqsyXsatjJcVLtLLm6KWueGGGzJ77LFHplevXhlPBMt4QlJG51ouo6ifd91117zXAxpDb1qb3z9PpLPHzz2O2nTooYf65VhIBgFvqqf/P9EL7p2MRtGKsglwfVo2ssTtwPVp4oYkUoN0fVoP985eshGrE9x7772ROGmn+fTHu1iIzfS0Tul7d999d7P00kvHVm89VfTUU08ZPV1/5ZVXjHcDUE9dL9hXZdbxvtiWh3czWLAcG5JLQOPn0horboW8HLD0EVCsEWXo0hg6UyajZ555xnz77bdGnjurrbaa8W7KS8aBc/uHefdu1K03kY7v3Wibk08+2QwcOLDJrspEqelj3kWAPb48VeU9seKKK1ovj3LOO/0vk2fRJ598YuPyKKCzpgJ5oor1FNHx5TlSzm+S2MmTRnFgNFVa054222wzW2duZzR1WjFjPv/8c6MMZfr+9OzZ03rXytvo7LPPtpmjFETYE2Ds/w1llNI4NDY2Wj577713brXGZY6Sh5bqK9cUS0fjLT5iooxY6623nsmd5qY2y0NM/VVf5OWrINmKHSVvIcX9k7dwIc+pYLt0qaIsWfI4Vva2JZZYwk7VcsGYldr8iiuuMPLA0fhoGpe8loJT0tQG70LfBuRWHWpDFBNveRMpI1f//v3NF198Yf8/6bzUWMrjTWPrxlljruDW6sOPP/5omanPWv/ZZ5/Z8VVCDPHT+bXUUkvZ75fGRl476ms+0ziqfDC4t9p02WWXmXfeecfuIo8mXU/IywlLFgFPOPBjN2kMo0wzTFaP6rM1XJ+mf9y5Pk3/GKoHuj7U/95av3fWtYxiccpjfJdddok0eLELQJFawU5ZBBCAsnDYD/yDbcokbWv4B5u2Ecvf3nwCUP6SrE0qgUoFoKT2K1+7dJMt0Ue/P5UE15ZYJFFNIpbiEpUjJOZrVxzr8glAcdRLHc1DAAGoeThX+yhcn1abcPXr5/q0+oyb4wgIQOEp40oRnhUlIQABCKSGgDwc5Akik0eBvCLymbwxFLdNT6DlRZLrxZG7j9JyKzOTvB3k/SLPAnk16Fg6poLo6uZY9eilm2Ydv1C93nRA60miJxrydMgN+qtkAfI0kaeEPEoUW05puHWcoOnY8pRR+/QESC955qg+pWBX++R9omPIu1KigLw1tt9+e9tGV5cu5lVWnhTy2NDL3fyLjzxeZLrQGO3FeHn33XftMeVlpCcyWieRYKGFFrKCg0QHeUU5zx3tq2PLQ0PtEj+x/Prrr+1LHkvyitE+hUzeJ940PKMbSHGQx4k3Fc0WlyeJ6la/FdMmNy29q1NjLq8ZtU+xduQponbos+L8yKtFXryKX6T1GkMneshzxZveZ72sxOSnn36yHNQXl5VKXkFqo/jo3NKYiZFYfvrpp+axxx4z3lQxs+6661ovHfVfbOVJpGPlelXJs0fnncZV3jPyvHFxA7X+2Wefte3cc889bTIKXdCLs8Yzqsl7SByd6FPoHI5av/YTO53X8mQSH5nOT51H8g4bMGDA/2PvTOCnmv7/f7JGKEQlKkm7tEhRKRQlW0kqUfYWkbTYd7Lvu0i2pEhICX1JKUSLiJB2W2XP1/Ll/3ke//P53c987sznzp2Zz2fuzOv9eHw+M3PvOeee8zx3Zu59zfv9PnZbMv+CvveTaVNlRUAEREAEREAEcoNAaAEIt3QuuLDDDz/cXtzxfNy4cdYFm+fJ2qGHHmr4k4mACIiACIQjwI0yK3SRFBZxBSOpLUIH7qLcVGKscFSQv8cU5Fexr/nHjW5B7hbDqkIIN17js51ks4gWXuNGHUEgkXFzW5CDxFx00UWFYQ6EaF1++eV2eXSEAAxxgJCXq6++2oopo0ePtisnuf3eYxDSRagXN+nnnXeeKcg/U7gKpbdcoucuoTHJkQvyuJiCeGozYcIEK6z41UOUQTRCXOAmPVlDSEFQ4oa/JGvQoIEdk1tMgbAjkivffPPNvsux0zaiFKKQM3g2a9bMTJo0yYoLnA+EB7HCFWF7sUZ5+udnCIgFeW7M4sWLbRhWvHJ+dd02BBQEvZLqIjQNHDjQJsJ+8MEHbagbokasITZxPtIe5wPnDh60qSS7po+IPpyzvAe8IWSxx0/lNe+nG264wYqWrh3OLwQrLx9Y9OrVyzxakAC6pL4U5FGy7/2CXFMJ3/vueHoUAREQAREQARHIPwKhQ8BYoYSbB4zlVUeNGmWfd+3a1bz88sv2ebL/aI8bgnw3hYAVPwPkYlucSdS2yMU28zOGCEI8sN/NMkfHE4OcLAUJb02i5aARiRD4nfhALpWHH3445QEgatAu5wI5WlwoUmzDCBHcxOMdkci4IeaGHa+QXDTGh9CEiHPsscdacSPMOBHpEAUQAAsSHodpokzq4L0Uz4OHeYcLXk4dOnQokpMq2c7CB/ET0Yc8LCUJLcm27y2PAMay8AXJzb2bS3yOlxdeUl6PLm8IGNcNxx13XNz3PgLe5MmT7fuuxIOpQKkQUAhYqWDO+EF0fZpxxBk/gK5PM464VA6gELDgmLcIXlQlRUAEREAEspUAYVKJxB/6jScNS2rHu6l2YyOMCMGBhLsIP+kQf2ibEC08kQgNiif+UA4PiJLEH8pxM81frhpjQ9zo2bNnaPEHNnhokbA6aqxiz1O8YQhVQ/Qh/DDWSy2Z8wCvOEQf/hB9EB1Lw/jxLFnxh37xfmDMJMKONUIWS3rvIwojEBWsmlcYahbbjl6LgAiIgAiIgAjkPoHQAtCFF15ohg0bZgm5nAi8wNW8pHCAeFi97cQro+0iIAIiIALFCeBBGc/zx1s69qbau8/7fMGCBTY8i9W20mludaJ0tpnLbRG29cQTT6Q8xKiJP27AeLyQJwghjMd4uaxc+USPtOVEH7zhStsIeyTsK6whyOK9F5sXiPe+X5hk7HFYvY2V48aOHRu7S69FQAREQAREQATyhEBoAYhfz/iLtUSJK2PL6rUIiIAIiEDqBAiBIrwj3UZeHJIhy0SgNAkgzrRr1856+rRu3bow8XaYPhA2RQJqhJ/YxOFh2kulDnm5SHaeit100032hzbXBj+4EdYZ1J599lkzZsyYuEnZg7ajciIgAiIgAiIgAtEkEFoAiuZw1WsREAERyD0C69atC+T9k+zISSgtE4HSIED+HUKcCO/ab7/9iq0CFrQPhA+yyhirlPFH6JQ3qXLQdjJRjiTNqVpsG4RSBvH8c8fFC4gk5OQUkomACIiACIiACOQfgdACEMlGSfZMIsbbbrst/8hpxCIgAiKQJQRil8xOV7cymQw3XX1UO9ElUKVKFRvahejDsvFhzzdWSFu4cKEVfN588027PH02UuF6KVWLbSP2dZD2w9QJ0q7KiIAIiIAIiIAIZD+B0AIQceh33XWX/ZUungBEWAJ/JFdUaFj2nwzqoQiIQDQJsAQ4HhQbN25M6wCaN29ulyJPa6NqLK8J7LHHHtbLB9GnYcOGoVlwbUFOHLx8Zs2aZVj9w8+y6dqjcePGfl1MaluTJk2KlK9atWpS7/3KlSsbhDeZCIiACIiACIhAfhIILQAFwcVqFyw7ywXYpk2bglRRGREQAREQgSQJ4DnRp08fc/fddydZM3HxAQMGGJJBf/PNN4kLaq8IJCBQp06dQtFnr732SlAy8S4SmM+dO9eKPrNnzw4U+nTUUUclbrQU97ISGyuX/fjjj6GPetFFFxWpy3v/xBNPtD/IFdkR50Xfvn1LbcWzOF3QZhEQAREQAREQgTIkkFEBqAzHpUOLgAiIQF4RuPTSS21yWPJ7JLKdd97ZegqVlBflsMMOs0u2s/R2165dEzWZ1D5ugslZ9MEHHyRVL18LIxgMHDjQXH/99SkhYJXNVBMQJ9OBRo0aFYo+u+++ezJVi5Rldas5c+aYmTNnWvEnmTFw7k6YMKFIe2X5YocddrDzyHyGsWOOOcbUq1evWNVLLrnETJw40eb2KbbTswFPwYsvvtizRU9FQAREQAREQATyjYAEoHybcY1XBEQgJwnsuuuuZtq0aVasQWDxMxK/krtt8eLF5tRTT7Uhun7lSMbrbpyPOOIIu3T1qFGj/Iomte3QQw81Tz31lCERLe0uWrTItz5LfdevX9+8//77vvvdRpb1ZmWndIe+ufbL+pGxEeaE18z3339vHnjggVBd2n777W07LAEO/0wYnihNmza1ok+HgiXbOR/DGuFc5PLh/HjllVcMK10la+S5yUaREa86EjczF8lYy5YtzfPPP+9bJZn3PiFgMhEQAREQAREQgfwlsFn+Dl0jFwEREIHcIsAN+IcffmgQa2rUqFE4uJo1a5oLL7zQ7iOHCGEgiEA84mHijJw/9913n3n99ddNpUqV3GYzcuRI8+677xq8Osjp5ozk0+Qe8m5z+7yPLVq0MCwpz808YsRuu+1m5s2bZ1jS2psHhpvTM888067ixPHGjh3r6/Gw1VZbmWOPPdaGprHM97Bhw4qMw3vsIM8RLD777DNzzTXXWLElXp29997bskU8Sza3DIJEmzZtTKtWrUpc4Yqy3bp1sx4dHBNx5f777zdTp041hxxySLElvBHCaBuBzzsX9PH444+37eA58uSTT1ovMS9z71gTLZNO/VtuucX079/fINBhzP8BBxxgCEtCWOTc6dmzZyjx59tvvzXPPPOMGTRokDnllFPsWBA8XnjhBVOrVi17PO8/zgFYxs4DrBBLEJHSkXPHe8x0PSc8/q233jJ4wzF3GHPO+9SxdcfiPQF33g+JLN57n8+BCy64oPC9n6gN7RMBERABERABEch9AuUKwgD+CTNMLmCuuOIKewFIMkY/wy05CjmA+PWYC0+WV92wYYO98OzUqZNp37593FVJcEOfNGmSmT9/vv1llot0LsA6d+5c7OLcj02ibdwknXPOOYYcB7vsskuionmzj9wP/AIOj0yteJQ3MMtooMwf84hxU0N4hiyzBMi9FiQJ/08//WQ9aYK8t7ixZmltkvkS0oLxNUJeE25imVc+H7fbbjubowVRoaR2//jjD1sHccjP8ABhqWv+EKxib5Jdnd9++822gwjA95I7LuFPq1evtmIV/aOv5DXCy4h+xhr9pz7jwVhlinq04zXCk9jOd4cTatw2xsJx6Cvb6LdXnMELiuPA5++//zYIGsuXL7dihxMFvMfyPqc8c+YYe0U8yq1Zs8aONZ6ggwcKbcBrxx13tP1CyHNG31asWGEFCfpMfxgnBgvGtX79evsY8hLCtgVf+o4HC9/DPGdM7li2kOcf42I/9WLPlaVLl9pz0m8+PU1k3VP4MZeMh/MW43x37zG3za/jzCP1/MYc9L3v1662lQ4B3n8ueTlzGHtOl04vdJRUCej6NFWCZV9f16dlPwfp6AGfp1y75fq9M9eO/JiLxtKjR49Q6PI+BIxfofnVlwtajBtTLsL5da5jx47m8ssvLwaWE4xfKbmhwLhwnj59uv17++23bR0u5mUiIAIiUJYE4gkAsX1yQk7s9nivWUXIWweRwOsx5AQMb5l4bbGdz8tEn5kIOYgDsUJHbJt4g8R6hLgyCDTO6BcCVjxD6IkVe/zKuhvvffbZp3C3V0hx/fWycQW52Yu94UOQCmKIAq5NdwxvvSA5d2gDDuSEijX65R0TggSCDxfJfFciHoU15gfRCU7e8zPIuZJoXA0aNAjbpTKtx3sndg453/EGSsW8bFNpR3VFQAREQAREQARyi0BeC0D84ognE7/OdigIATj//PPtRTUXuIQmvPbaazYcgDAJr1199dVW/MH9nMSrXLzxax3JFVmO9s477zTDhw/3VtFzERCBHCGAl+DkyZNtCBWeK6xwRDgSj6VpfH4RIrNw4ULrSYJgwc0kv/xzM926dWvDCkiIMdzAjxkzxowfP956vrCfZbgJDeFmPJ7xuTZ48GAbrsWvnLSFcMAxnOcnx8SLAQGnVkGoDuFRq1atsvmI8NigHoIBZfAecUZ5BHeWsaZdBA08O+gPIWKEdr3zzjvWM4T6TiRiLJirj2hywgkn2PAywpAQKjgWbRIShdcQrKjHTTHCD+3RNz77KcsNN8el/xzXiRyMFQ8e6tF3yrux0B516TMM2M8+niNy8AsUZfBmIYcPYXBweeONN+wcUJa6JOYl3IsQKJY0R2RhH8emLmIM5xb9wGuJfvPrD/s5DuPB87RLly42RA/P1Oeee84ei3OCsD7GBRc8lfhxAw8f+o5xDMZHX5gPtnOOs61Dwfci7VKf/WENpkuWLLG5b2h35cqVtg/MOeMnzxE/qPB+Qhg67bTTyixZMfPAdzxzAWvm1Qli/PBDImaZCIiACIiACIiACESVQF6HgN18881mypQphl8OSa7JhbszLtz79etnL0pZWhlXK+zjjz82Z511lr3wJjcBNxnOuMno3r27vVDmxiz2111XrqRHhYAVJyQX2+JMorYlF1xs+Swglw5CgNf47OBz4fbbbw/kOeKtG+Y5+WDIy8ONfCJDADn77LPN6NGjbZhJbFlu6klGG7u0NOVOOukk88QTT8RW0essJoAohHgU1hCtEH0QBwlpDiv60AcSOCN2IaQgXCVrCHyIVfvvv3+yVUOX5z3FdYETx/wawjMHT19EyrK2RCFgZd03Hb9kAgoBK5lRFEro+jQKs5S4j7lwfZp4hPmxVyFgwec5rz2A+EUSO/HEE4uIP2zjF2F+Pb/nnnvs8rNOAOKCFiM/kFf8YRu/XHKxOnfuXPvrN8kwZSIgArlB4IorrrAeg36j4YYRUeaLL76wyXD5/MiUEfNLfrUghgcPglU8w7sBz0U8Xm644YbCNbckggAAQABJREFUYiz7jjeNLFoEwog/iIQIPgg/JE32/hCSzOj50YSceHxHsoIXP4ikYngD4WWLkOS+f1Npr6S6JB8nUXlJhvcS4YQup1RJ5bVfBERABERABERABLKJQFruUuIt5et+9ePmKF4ZLwxCAcgtURpGn1wOnz333NP3kO4XPkIsnH300Uf2KRemfuYEIFbYkQDkR0jbRCB6BAhFIly0JHv11VetF1CmQkBZ1jqo+FNSX737b7zxRtOnTx+z7777WuFH4o+XTu495zuP1cQQferWrRt6gISi8d7Ay8eFloVuLE7Ftm3b+nqvxSkeajMhaEHEH9c4IZCHH364DV1z2/QoAiIgAiIgAiIgAlEgkLIAxK9+uIonMtwjSypDfX5h90u6nKjtsPv4lZNcBPzKiBuun7EyB+b9JZNf1DGXgNO+8Pxz25245NmlpyIgAhElwDLMQY0QEvKJhfWkSHScZPqRqB2/fYSBscw4IWOy3CNAriREH7x9WBo8rJFTiRAoRB8e431/hm0/th5hjqyIiRCUKWPVzWQNbyeuDbxJv5NtQ+VFQAREQAREQAREoLQJpCwAlXaH03k8Elvi3cOvf/Xq1SvWNL+2Y958H1z8Yk7osS88/9xKJq6cZ1eRpySZJNePn5EwFPvuu+9Syufg13ZUt7mcDCQnlUWTgDc8hXnMhECSKTJ49gQ1PB/xhvD7TAnaRrxyyfQjXhvxttNncop8+eWX8Ypoe4QI8P7CowsvH0QfPGzDGiGCnB+IPnj8uATgYdtLth55qh5//PFkqwUuj8duGLvrrrvMgAEDwlRNWx2uT0q63kjbwdRQWgm46xoaZR7xLJNFj4CbR12fRm/uXI+jfH3qxqBHU3jP7CKQcpUJ3teY97xNdqyhBaD99tsv7Rc+tFmaxsopCEDjxo2zF8reZW/JYeButrjY5QOeP7yZsHgJnt2ywG5y4o2HXzURePyMVVEwJjaVyfVrO+rbxCPqM/hv/937KQqjIU8OieWSMd7b3mXHk6mbqCwrOWXKuIkkEaIsugRI2sz3KKIPeer8lngPOjrONb4HEX34MYT3QVnZ119/ndHvwpK+r+ONG0/fsv5OitJnaTyO2v4vgbI+lzQPqRHQ/KXGL1tq6zM1W2YifD9y/b2YjvGFFoBIEspflO2II44wM2bMsBe3hD2Q14eEmCtWrLDJLI877jjz7LPP2lAxfk3lj2V3cXmPd8HotrOCSSJjeV6W9fUzV9cd069Mvm3jAxmDiSyaBNwcut5HZS5J6FyxYkWbKNn1vaRHbrwzMT7CTTL1KyMhsYxTFi0CfF+0bt3aij7t2rUzzgs1zCjWrVtn3ihI4ozo8+GHHyZcDStM+2HrsDpZJt5Prj8wDBPKRp7ATPbL9S/eo/tMLcs+xOubtpdMwM2fK6l5dCSi9ejmUfMXrXnz9tbNodumuXQkovXo5jHX5y8d4wstAEXrlPDvLQBvuukmuwT8pEmT7OpdlKxcubIZPHiwOfDAA60A5Lx63D5+9Yu3/LLbHk/ccT0hBIw/PyM0jPwCu+66q+HCV2as5xXeCcxNJldYEuvMEYjyMpvkTpk8eXIgOLxnDzroIMOS3Om2Qw891DzzzDPpbta2d8ABB1gBnGWuWelIlr0EEOv4fuK85JEfJsIaP3gg+PD36aefhm0mo/XIT5VKCFtJnWvUqJH9zi2pXOx+fjjie7qsTMvAlxX59BwX0dF5l3KdGc+zPD1HUyuZIuCWgdf1aaYIZ77dKF+fZp5OdI6QT8vAMyup3GfktQAEPH75GzJkiGEJ2M8//9zwJcwNEPbuu+/aR++FJx/wiQQglzh6xx13tHX1TwREIPoEzjvvvMAC0NChQ1P6UE5Ei35kSgC67rrr7KFJNN2jR49E3dC+MiCAZw8ePog+rDbpPEXDdAWhx4k+CEDZbPyYgvCZSbvtttss22SOQX6lshR/kumryoqACIiACIiACIiAI5D3AhBxdPwRksWvgF5bsGCBfenNDeQu+JYvX27d7r3lec52rEGDBvZR/0RABKJPgBvvESNGWI/BRKOhXKaWgOe4hPrgDeHEmkR9SWYfHo8uBxuhr+SQIRRIVrYECCUklw9JnJs3bx7a+xG3aEK6EH2YV0K9omKvv/56xrvKCmN9+vQxTz31VKBjcb0wffr0QGVVSAREQAREQAREQASyiUD6YxSyaXQl9OWee+6xF9ZjxowpVpLl7adNm2a3ExrhzP0S+dprr7lNhY8ISTNnzrSvgyx7X1hRT0RABLKewI033miuv/56U758ed++nnTSSfYzIxXPDN+GYzZee+21hqXmg4T94LGIYETIkJ8RBnvBBReYu+++u8hubrqPPvroItv0onQIsAhA7969zYMPPmimTp1qRo0aZT1+kg195TuMFS45b8nXd8YZZ1iBIyriD+MlRx+5+UrDnnzySbuwRUmx9VWqVDFLly7NaEhaaYxXxxABERABERABEchPAnntAYRnz9NPP21DO0488cTC+GuEHHIDkWy1WbNmdoUwd3rwC3ytguXjP/vsM3uz16VLF7fLcAFJHULISuuitfDgeiICIpBxAtyMn3zyyTYMi6Wj//jjD1OnTh3TvXt34/UUzHRHzj//fMNn1sSJE+1KhiSfdwIBfSJciM8qvHnIK3HZZZeZ22+/3ZDrjBXKCHXFW4ntbtVBb5+JK54yZYpZtmyZvSlmtUTa3XLLLW0xniMw4FnibpjZR1JcxAtykyAisXoTfXOJ+Xh0z+kv/cSrEjGLPtFGpUqVbJ8++eQT67XCEuQYK1xRh89njOckxWa1tW7dutlVG/FuoTxlEOLIx0SeDUJz2YbnBtsYH30jdwP9oW2OT7gvAgkrorGdsVGHP17TFo+siMUf7bjxs50/jPIk1OY1/axRo4Zp0aKFDTNGlCFOnf5QHy+fnj17WnZ8d6S6etzGjRsNP1DAn3nivDz11FMtA5gS2uzGTV8ZO6zop+uz44XYSagT87pkyRLLjHEzZtrgD6Ncw4YNzfHHH29OOOEEu7ACx8fjiHMBDswV7eyxxx5m1apVdtlr5h9BhVXGWLaVFTfpA20QllXadt9991lBlPfF7Nmz7XiZJ85PxoeI1q9fv9Lulo4nAiIgAiIgAiIgAmkjUK7gwuzfK9a0NRmdhriw40aKhMtciHYoCHvgZumdd96xF+rcKPDLOBetXps1a5a9ceJCGNd8Lthxr587d669geFGq0mTJt4qST0nCfQ555xjL0Dpg+z/kkDDgxsVWfQIKMle9ObMr8eIF4g/eBfJwhNAZOI9gWDjhJQwrSEiIZogsCCeIeiUZIgyGGVdWHNJdbQ/+wgwj1yzIF7KokdASaCjN2d+Pebzm89yXZ/60YnGNl2fRmOeSuplPiWBRmcgIiBszs68vpPmwvmqq64y/Or30ksvmRdeeMGeW/y6SaLNAQMG+P46zgo//DpJHg6XSJOKtQo8g0jSmor4U9LJrf0iIALRJoDwjPH5g5CSiqCJfo+XBx4nXsOTAnNiAGXiha5RlgtYku26PvElSiJ756XCcfhcZD+GpyM3nt7jurHQHuWoy3PCz9avX19EMIr1nqEu2/BEcR41v/zyi63r+u5tH08h2mYbz+kfjxjbaYu+0Qeew9j13RYq+EddVm1kHLFzwPjptxuz4+jq8ggzmNIOzxPdhG/atMl6kTAmJ/owrrBGfxB7EH0Qfxhn7Bhc246bex30EY6OadA6rlxs3djXrlw2Pkapr9nIT30SAREQAREQARHIbgJ5LQAxNVz8jxw50i77jls6NxK4qLM9kREaRvgFN0KsCsavqIQPxN5kJGpD+0RABPKDADf+eAaSZJYwHD5nnOFheOyxx9pcL4QKlWT8anzllVeahx56yHqPUB6hAo8cPrdYwh3Rw88QCwhh4Y+VD99//32/YkltQ4xA/HChWiVVRlhBMMHoL2zi9bektpLZTxgPif4J3/XrK2wQhBBTYg0xiXBf+v7iiy/acrFleA0HQuf4AWHs2LHmiiuusCFOHQq8S/lLxWsK4eiNghA3fnTAaxUBiO8qQqfwBKGPLVu2tOFenF+PPPKIzQGE0LT77rvbnE7ke6JOPKNtftzgOLDgGB07drSJzUsKaya0jdBpws/oK6wQqJhfBDX4k2x50KBB9nyP14ey2M6ckRNwzpw5BrGOX/I7d+5s35Oxi0OURf90TBEQAREQAREQARFIF4G8DgFLF8R0t6MQsOJEuWHkpkIutsXZRGUL8+du/LkRDutdEJXxun6SMPaII44wK0pYbpsb5vHjxydMvkwb3ESvXbvWNa/HLCPAeX344YcbFgLAWxRhKawh7jgv00WLFhURDsO0iZcX55hb8Q3xjh8vEIzwXr3jjjviNovoSG4cP8MN+ZJLLvHb5butV69eZty4cSktZe/bcJIb8fbp379/3NW/4EMYON7A2WgKAcvGWQneJ4WABWeVzSV1fZrNsxOsb/l6fRqMTnRKKQQs+FzlvQdQcFQqKQIiIALJESC/C54EeBeWZHgekESX5LN4csQaOWNYElziTyyZsn9NKNiBBx5oc8K1adPGhtOF7RXnCh44rCiJeJhO4xwiXhyPF5I7O7vmmmsSij+Uu/zyy60AP3DgQFfNPuKJloz4QyUWXyDv3gMPPFCkrdJ+Qa69REu/45nGePHuxUtPJgIiIAIiIAIiIAJRJyABKOozqP6LgAhkLYHRo0cHEn/cAAjX4aaUhPKxRghZECEptp5eZ4YA4V6spEZoFyuuxcuxFOTohKU50Wf58uVBqoQuwzmGYEMoG0YIMwJQECOEDO8d8kNhhNKNGDEiSNViZVjm/qyzzjLNmzcvtq80NixYsMDcf//9gQ41ZMgQ68VHjiqZCIiACIiACIiACESZgASgKM+e+i4CIpC1BAireeyxx5Lu37x582yemtjlwLlhlpUtAYQPvLBY/ZEwqniJl0vqJefGRx99ZEUfQrzWrFlTUpW07if305dffmnq1KljJkyYYBOJBzkAy8PjPUTYFIaI5JdPye4M8I/3R1kJQI8//niAHv5bhPlBoDvssMMC11FBERABERABERABEchGAhKAsnFW1CcREIHIEyB/y7fffhtqHIsXLzZeAej333+X908okqlXIkcOgg9/hE2FTfRPONHChQttTp8333wz9LmR+oj+bYHwMgQgzrVkzFve+zyZNlzZVOu7dsI8JntsyksACkNadURABERABERABLKJgASgbJoN9UUERCBnCJBgNqzFLhGeSlth+5DP9Vgpi9AuVvNq2LBhaBTMGyt2kc9n1qxZdjWs0I2luaI7p2LPtZIO4+pRLtm6sW1724rdl+nXyR471bFmejxqXwREQAREQAREQASCEJAAFISSyoiACIhAkgSqVatml8ImuXOy5vX+oS75Zgg/YqUKWWYI4A3jRJ+99tor9EFYEYYwPkQfEnqTeDkbbc8997Tdij3XSuornJwlW9fVc4/etty20nrk2IhyQS3VsQY9jsqJgAiIgAiIgAiIQCYJSADKJF21LQIikLcEyA/DykGJVhnyg1OzZk3TokWLYrtOOOGEwElri1XWBl8CjRo1sqIP4V14/YS1X375xcyZM8eGd7399tuGkL1sNsa6zz772C527949cBJolkX3roZ19NFHm6FDh5q//vor1HBZkaysjGM/8sgjgQ5foUIFhX8FIqVCIiACIiACIiAC2U5AAlC2z5D6JwIiEFkCV1xxhZk8ebL57bffAo/hhhtuMOXKlStWnpWbxo0bl1RbxRrJ8w3k72natKnN50My5ypVqoQm8sMPPxhy+ZAc+N133w0tgoTuQAoVOZfcOdasWTPTu3dvM378+BJbHDx4sEGgdIaQxKp1t956q9sU+BH+Xbt2DVw+3QW7dOlizwOScJdk8KpYsWJJxbRfBERABERABERABLKegASgrJ8idVAERCCqBAgbefrppw3eO4QGlWSXXXaZLetXrnr16mbq1Knm8MMPN8nmL/FrL1+24YnFil3k8znooIMKlzAPM36SeiP6IBqwjPjff//t2wxCU7x9vhVKcePll19ujjrqqCJHZIU5loMnZC2eHXHEEeamm24qtvv666+3q9a5ZeWLFfDZgOcVq4+VtfHePPTQQ82SJUvidqVfv35m1KhRcfdrhwiIgAiIgAiIgAhEicBmUeqs+ioCIiACUSNAmAweIngcxFtBCq8UbqCvvPLKhMMjVImb1ZYtWxYrh0cHITolGStZIQKUL1++pKKR3b/11lvb5drh+corr5g77rjDHHPMMaHEn7Vr15onnnjCjBgxwgwcONDcfPPNhmXU4wk8J510khX7CK2K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S40AyZJZXh7Rp3379jaJctgW8ZYhkfXMmTNtAmaSVsv+JcBS9dkoAE2YMCGpsMhFixZpSkVABERABERABERABNJEQAJQmkCqGREQgaIEWKkoGSPvBzf02bySEStByZInwKperVq1sqIPK6WxClxYI/EtXj78kStHnlb+JLP1XF2yZIl/h+NsJYeTTAREQAREQAREQAREID0EJAClh6NaEQERiCFQ0kpEMcXtyzB1/NrJ1LZs71+mxh2mXVZyYnlzPH0OPPBAs+2224ZpxtZhuXsn+nz66aeh28mnitl6riYr8G622Wb5NG0aqwiIgAiIgAiIgAhklIAEoIziVeMikL8EatasaapUqWK++eabQBCaNm1qtt5660Bly6pQ69aty+rQkTgunj14+CD64PGD509YW7ZsmQ3teuONNwIlDA57nFytB/9stB49epjhw4cH7lq1atUCl1VBERABERABERABERCBxAQkACXmo70iIAIhCZDL56yzzgq0ChiHGDBgQMgjlV41Vqfaa6+9zBdffFF6B83yI+20006mQ4cOVvRp3ry52WKLcF8rhHIRHuQ8fdatW5flI8/e7tWuXdt07NgxKzuIMLznnnsGFvVYIVAmAiIgAiIgAiIgAiKQHgLhrtTTc2y1IgIikOMERo4caZ5//vkSl03HY+S0007LehpbbrmlGTNmjL25LinhMN5C8+bNy/oxhekgXhlO9Nlnn31M2DAdGH7wwQcGLx/+1q9fH6Y7OVWHJNklnVuJBkx9zlHO1Wy15557ziYCZ/W/RIbYesEFFyQqon0iIAIiIAIiIAIiIAJJEJAAlAQsFRUBEUiOQIUKFcyMGTMMYR+zZ8/2rXzkkUeaJ598MrTniG+jGdyI8DFlyhTTt29f88MPPxQ7EmFPt912mxk0aJDp2bOnmThxYrEyUdyA5wZCHeNv0KBB6CH88ccf5t1337WCDyt4/fTTT6HbyqWKeE7dcMMNZt999zUnnHCCTYie7PgqVqxonnjiCTtPydYtzfKEe7700kvm2GOPNZwPfla/fn3z/vvv++3SNhEQAREQAREQAREQgZAEJACFBKdqIiACwQiQB2jWrFnmscceM88++6wNn0Ikady4sRVRDj/88GANZVGprl272nE8+OCD5tVXXzVff/21IRSK/DeEvSGWYM8884yZM2eOGTFihHnvvffMX3/9VTgKQuSCrGAFKxIq88dN8c4772xYGnvVqlWF7SEe8Ed7POKhc/TRR1tPknHjxlmhin14hbA0+B577GGXT9+0aVORPtAnkjUzJ5dddpmds19//dWKPoQVhTVWeJs7d64N74IHbQYx1x9WgvKy89alDLmjYFOpUiUrNMYrS73y5csbBIhrr73Wzs+jjz5q3EpTtLXbbrtZdoSirV271u6jPa+3Ch5PtEOiZVjXqFHDdokVyjZu3Gh++eUXO0baddyZN7zCEDzJi8V5Q5gbfW7btq0588wzbXghDRFi+NBDD5mpU6eapUuXmv/+9792XqtWrWq22247w7xRl35xfjCnRxxxhD33OA+jYF26dDHff/+9IcTr5Zdftuco5y7nJjmCouARGAXO6qMIiIAIiIAIiIAIeAmUK7g4/ce7Qc/LnsD06dPNueeea38h5aZBZuyNrLvZ4SZNFj0Cf/75Z+FNNEJE2LCh6I08Oj3m6wCxAYEGESORkFLSqJhfxCQECx413yURK739XsELAUkWTQLMIyF/CGey6BEg1NN9xmoeozd/rsduHvks1fWpoxKtR12fRmu+4vWWeeQ6Nteva/ju71DgjX/11VfbSIN4PBJt11VDIjraJwIiIAI5ToAvSzx0nNdKqvlnCPvjD9FHF8M5fvJoeCIgAiIgAiIgAiIgApEiIAEoC6fL3TQRGhAVd/5MY8QrgXABclzo185M0069fcJ9xo4daxYsWGA9Slj1Z9ddd7WhUsuXL7fqPCIBYTUID4TwEJbTv39/Gw4TtAfk4Bk4cKANp+H8cGE6LiTo8ssvN926dStsbuXKleaBBx6wIWmEbX377bc2nIZ6vO94z5133nnmkksuKazDE1anIrEuSZ3XrFljkxWTu6QkB0p+hahevboVQwjh4hgclz9+qYg1vGTcGLz73K/D3n3ul2PKUS+IcFO5cmXTuXNn89FHH9k+8QtC+/bt7fvKe7xknhPORE4fxkR4F+FL8fK6JNOuX1nnVcRy8whMhBe2bNnShmMRYkdYHP3Bg8nxgDlhXcOGDbNhVngkwZ5cOSQo53wknIsVzE455RQbpuWO/eKLL5rx48fbMCy2kfuIMD+SGDNmF8rGMfjjfGCuCNU68cQTbZiZayuVxw0bNpj777/fvP7665YznqEHHXSQXTmPkKlkjVA1DJ76jkmWXvaUZx6dl1329Eo9CUoA4d3lkeP7gZBSWfQI6Po0enMW22OuH5lHjPuMbF5EIbbvev1/BPg85fou169rnBc313BhTSFgYcllsN4rr7xizjnnHJvLYpdddsngkaLTtPuChYcEoOydN278SX788MMPh+5kv379rEiDiJPInn76aZtDyN3oxyt74IEHmrfeesu2OXTo0EDiBOcZYhHCwKWXXmquu+66EsWeeMfPlu2MBRaIPuScQYALawgtbxSs2kWenI8//jhsM6Vej4uCu+++21x11VXmk08+8T3+6aefbt1qTzrpJPPaa6/5lgm6cccddzTvvPOO2XvvvYNWKVaOhOMnn3yyb7Js3iN33nmnFbaKVUywwQlAiFUIs7JoEmAeEQ0QNWXRI+AVgJhDCUDRm0N6rOvTaM6bt9deAYgfyiQAeelE57kTgHL93hkBqEmTJvZHRhbZCWPyAApDTXVEQAR8CZC4Fc+KVIykxVwYT5gwIW4zeEL07t077n7vjrffftvUrVvXeqZ4tyd6/t1339lktAMGDEibF0ei42VqHzcVeKwg+pCAGBEorH3++edW8EH0wcsnikaC5j59+iTsOp5eeAalY0l6LiqbNWtmEzbjtZSsIUB1797d1yuMtrgIIOk4QhDCqUwEREAEREAEREAEREAEEhGQAJSIjvaJgAgEJkDy8lTFH3cwVs8ihIaVrPysV69efpvjbgsjWBB2w0pRUTO8TggPOuSQQ8x+++0X2mOOcCa8exB8+CP0LV8sHeKPY0WYGGIlK3olY3jT4Y3kDfuLVx+PUVYX06IB8QhpuwiIgAiIgAiIgAiIAAQkAOk8EAERSAsBcuuk08h54icAkV8onTfo6exzWbVFGA9ePog+++67b+gVtwinY4l5BB9CvMiRJEudwIwZM5JuhFBgwhCD2E8//WQIiRw8eHCQ4iojAiIgAiIgAiIgAiKQpwQkAOXpxGvYIpBuAuQ6SaeRcNnP8A6SGRui5kSfhg0bhkZCMmkSKCP6vPnmm4VJSUM3qIrFCMD4008/NfXq1Su2L96GZN9PlJcAFI+mtouACIiACIiACIiACEBAApDOAxEQgbQQwAshnfbzzz/7NkdelXy1OnXqWE+fgw8+2PA8rJG0EoEN0YcE2W41q7DtqV7JBFidLBkBKN75H+9IyZaP1462i4AIiIAIiIAIiIAI5C4BCUC5O7camQiUKoEaNWoULpedjgPTnp/Vr1/fb3PObsO7B8GHvzBLfjswv/zyi12mHdGHxNhuGUm3X4+ZJcCKDclYsnOdbPlk+qKyIiACIiACIiACIiACuUFAAlBuzKNGIQJlTuCII45IqwDUtWtX3zGx6tGFF17ouy8XNm622WY2jw+CDyFeVapUCT0slsScNWuW9fR59913DaFIstInQHLmSpUqJXVg3k8jRowIXCfe+yVwAyooAiIgAiIgAiIgAiKQ8wQkAOX8FGuAIlA6BM4//3xDImg8TVK1bbbZxgwfPty3GVa5OvTQQw1LwWfadtllF8OS8Jm2zTff3LRs2dJ6+bRv394wxrBGf0ngzN8HH3wQaBWpsMdSvWAErrrqqmAFPaXw/Dr++OPNxIkTPVv9n7Zu3docdthh/ju1VQREQAREQAREQAREQAT+PwEJQDoVREAE0kKgWrVq5qmnnjLHHXec+fPPP0O3ucUWW9jl5OOFgNHwyy+/bNhPXpUgdv3115s77rjDfPXVV0GK2zIDBw40/fv3Nx07djSZyK+y9dZbG27c8fRp166d2W677QL3Lbbg2rVrrZcP4V1LliyJ3a3XHgJ4VCU6b7bcckvTt29fM3bsWE+t8E/x5Bk0aFCoBh588EHz0UcfmY8//jhu/erVq9sVwMqVKxe3jHaIgAiIgAiIgAiIgAiIAAQ2EwYREAERSBeBo446yq4k1bRp02JNBrlB3WeffczMmTNN9+7di9X3bthqq63sEtmESCWyihUrmilTpphRo0aZ+fPnm27duiUqbvcRgoVgdO+995r999/fsLoSXjnpsAoVKlhPjdGjRxuWBr/xxhtNly5dQok/y5cvNw8//LAVK+B111135a34E+TcoszIkSPteXPLLbcYzo1Ya9asmQ2Ze+SRR8ykSZN8cy4hUAYxvLqGDRtmpk6dGqS4bxnCxubOnWtOP/10w3kZa4itrOBWs2bN2F16LQIiIAIiIAIiIAIiIALFCJT7p8CKbdWGMiXwyiuvmHPOOcfMnj3bEIIiM4ZVi1j9CR5Bb8DErWwJLFiwwPDH3NWuXds0atTIkIfm888/NzvssINp0KCB+e2338yXX35p8IZBNGrRokXSncab4+677zYLFy40a9asMYSPcSzEHrwvYm3VqlV25auNGzfam+rXXnvNigJ44CCkDB06NLaKfc0y3qychTfQunXr7HOOR54d+r/99tub3XbbzXzxxRd2zLvuuqs56aSTDI/sZx/CVRCxwrcDBRsZK8eEGV4hvEbIIAHwH3/8YcfFNq8HFsfedtttDeLGMcccYwUjxCNEKMLESAZduXJl07ZtW7Ns2TLb///973/2vYbogJBBv2mTcW/atMluQ5zg/cix8WIiN9NLL71k+PzCCwnOLhyQHDgcgxxEtENfeR/zmmP9/fff9o9jsR/GbOM180n/eSQB+L777muZUm6nnXYq9J7C+4n+0R6iHZ4znF+sltavXz8rtHlFH85Lxg+L8uXLm+bNm9tz0MuetkiYvXTpUruZc/bAAw+0nB566CG7tDv94Hz78ccfDSvh0RaeXWeeeabl5m0vlecutO/rr7828MRrLGziZ+cJB1/OT1k0CTCPfO6k4j0YzZHnRq/5fOL7A2MOmUtZ9Ajo+jR6cxbbY+4vmEeMaxU8gWXRI8DnKddkuX7vzHU7C4tce+21pkePHqEmSgJQKGyZrSQBqDhffcEWZxK1Lfn0BYvAwXgRmVINH+PGAKGDvECIOWVtfMEi3HCRJIsmAQlA0Zy32F5LAIolEq3XEoCiNV/xeqvr03hkorM9n65PozMryfdUAlBwZsF82YO3p5IiIAIiEIgA3iGffPKJ9UDBQ4gcQkEMTwjCYvB0wbuD5MneX8ARX/COwRsDD4k999zTeh3hHYLXCsl1S/Iic31bv3699UShHsfCW4KLPbxCCOH69ttvDfl38OrBmwIvJlT5WrVqhfb0wfOFMSAcjR8/3nrR4M2EFwvHwvvn119/tV5LJMKmj3idtGrVytZh3AhFrArF2OGFVxJ9xJPF/XKAiPPEE0/YMTA+vGMQrHAKJRRvyJAhhvwyr776qnn++edtXeqQQ6dx48aFHlv0ZdGiRfYXM/Iy8Su2YwVz6nNc+kkIHN48zB2iFh5Jbdq0sWFMhOjRVzx9dt99d9t/vHPwuqLPnCPMJ/PHeJ2tXLnSehtxDrDPK5JxUYfn1urVq23b9AfjXOOPdhgT3jtVq1a19RlzPKM/ixcvNitWrLDnAeNhzvGu8p6Drj7nCucijAjTSpTXytXRowiIgAiIgAiIgAiIgAhkioAEoEyRVbsiIAK+BBAxWDHs2WeftUKHK0TYzHXXXWfDidw27yPhY4QZEerlNcKUCPUipIncLWPGjCnidYMrLy6hzhA6BgwYYC655JJiN+0IBRdddJGZMGFCkTquLl4vCBnOEFgIf+Kvbt26bnPSjwgcjI/8R2+99VaR/tMYeYz6FySkTmQkxvYaOYHCGn0hv5CfIeYQOlWSIcQwrkRGLp5kjXZPOeUUm5/p1ltvLZL3CEEGoaxPnz72fIBJslHOiF/kZurcuXNh1xDKOC84P/yMcxAx6/bbb7ciD+fIpZdeah577DEbMufqIA6yIhhlZSIgAiIgAiIgAiIgAiJQ2gQUAlbaxAMcTyFgxSHJxbY4k6htwRsDYaF37942PMqv/3ipcBNNDiyvPf7441YAwTsmnlE3mZt9bvTxoHGxwu+//7696fcKPH7HIg9Nh4Lk04ccckhKyXfJpYMnEaIPj4QDyNJDINlzwe+oxFYj+pDLh3w/QQxxkdXDzj333LhiEe1ceOGFVuwM0mYmyigELBNUS79NhYCVPvN0HlEhYOmkWXZt6fq07Nin68gKAUsXybJtRyFgwfnLAyg4K5UUARFIgQChSSeffHJc8YemEXC4eSaUh+XXMYQZvF8SiT+US0b8ofyHH35oevXqZUUg+sYKZn7iD2ICnhuIPnj6BA1V4xixxnHw8CFhMYmKCfWSpZ9AsueCXw8uvvhiGzqHV1lQI5Ts+OOPt4moE9XBW41znOXmZSIgAiIgAiIgAiIgAiJQWgQkAJUWaR1HBPKcwH333WfzzQTBcMEFF9hl2ynLjXhJ4k+QNv3K4H0zffp065nkvCIoRz4fViRD8GEJeFZdCmsbNmwwb775phV9ELNYWUoWDQKPPvpo0h0NOr+c44Sq+S3vnvRBVUEEREAEREAEREAEREAEAhCQABQAkoqIgAikTuDFF18M3AhCCYl2WfmKZMuZNHIREZrGUuckUkb0YYltlqoPa4hJePmQK4ekwenwSAnbF9ULTyBTwiM9IhcWXmAHHHBA+A6qpgiIgAiIgAiIgAiIgAgkQUACUBKwVFQERCA8AVaiSsY+//xzu9R4JsUTVpxiVSryEpGEmudhjdWo8ChC9GF1M5kIlETgs88+kwBUEiTtFwEREAEREAEREAERSBsBCUBpQ6mGREAEEhFgNa6SVoXy1qc8XjnpNjx72rZta5M477///kWWDU/2WMuWLbOePnj7sDy7TASSIZCJ8zuZ46usCIiACIiACIiACIhAfhGQAJRf863RikCZEWjcuLGZN29eoOOTF6VRo0Zm++23N3jppLpC1k477WRz+bByV/Pmzc0WW4T76MMbacmSJYWiz7p16wKNR4VEwI8AycVlIiACIiACIiACIiACIlBaBMLdBZVW73QcERCBnCFwwgknBBaAunbtasO/GDzhWcmsxOSAVa1a1ebzYfUubrTDJtslqe8HH3xgQ7sI7/JbKcwdU4+5RaB8+fKGJX4zYfvtt59dCSwTbatNERABERABERABERABEfAjIAHIj4q2iYAIpJ3AiSeeaB577DGzYMGChG1vt9125qabbiosc9VVV5nJkycnXD7eFa5Ro4YN7UL0adCggduc9OOff/5pE0MT2sUKXizfLssvAog/nIdDhgxJauCVKlUyP/zwQ8I6hDfeeeedCctopwiIgAiIgAiIgAiIgAikm4AEoHQTVXsiIAK+BAi7GjdunDn55JPNwoULfcuw6tdzzz1n6tWrV7i/evXq5tVXXzWHHXaY2bhxY+F292Tvvfe2nj4dO3Y0NWvWdJuTfixXrpwVp1gVbM6cOebXX39Nug1VKD0CeHTFW6WLZN6bNm0K3RlEyIkTJ5rOnTvbxOBnnnmmCbK8e9OmTc2kSZPMoEGD4q5eR0jjk08+qeTPoWdHFUVABERABERABERABMIS2CxsRdUTAREQgWQJVK5c2UyZMsV6P7Rs2dLgCYHwsueee5phw4aZpUuXGrx3Yq1FixaGVcGGDh1ql4YnnxCeGYhFTzzxhDnttNNCiT+bb7652XnnnU2dOnUMxzjllFPMsccea72HYkPGatWqZbyhabF9DPKaNklCzXGTNeqSyygZg21pm5tPRLwgSY4RBv36yXhjt7ONZdPxJPv0008Nwsxuu+1mh4jHzkEHHWTFlW+++cZcd911dl5j20jEA76DBw+2q7gh/mCnnnqqzfvUq1cvwzH8DM8zPHreffdds9dee5lp06bZPrZr164wyfjuu+9uBgwYYD7++GPTrVs3v2a0TQREQAREQAREQAREQAQySqBcQVLTfzJ6hAg0zi/9Tz/9tL35/Pbbb021atVszpAePXoUXrx7h8Evyw899JB3U7Hn3ChyUxnGXnnlFXPOOeeY2bNnm1122SVMEzlXhzwc33//veURNoFvzkGJ2ICYP5dPBSEI8YePH7w4ShJEKPfzzz9bDyDaIUQrrHH+4GnEH2IMooKfub6x36+P9IHttEffCP0hPxBj++WXX6z4wWeFOwbt8eeOh0cJ9XlNua233trWgRFCA/v4c224Pv7111/2mLT1xx9/2ATZHNvV49gVKlSwdeHqxsEjYgh18ELB6LdXgGE/4+L47n1GH+grK7jRBv3hkXG6MrTp2qG8dz55TZ9pm+fMO8fgtVcgon1e8+gVWtx2+uCO51i4R8fEvfY+ckzMPbp9HB/2rt1Ebbg6PLqxOJ60QVuJLGjbidpI576vvvrKNsc87brrrulsWm2VIgHmkUT5eKzJokeAxQ1cuChzyFzKokdA16fRm7PYHvtdn8aW0evsJ8DnKdeXuX7vzHUxuU2vvfZag1YRxvI+BIylm8877zyzYcMGy4+bNba9/fbb5sUXXzR33HGHqVKlShG2eCLg5p/ICAUIKwAlalf7RCCXCHDj7BULvGPjhp3cO4R98aHOTXRYQ3TAuwPRh4vskm7YOY63b359pE1nCDAYogjmbsi8AgfteY9Lm65d74W/Ez8QFvjjM8lrTgShLUQj/jBXzx3bte0dB+Wc+MNz73F5jbn2/n1lbB/ohxsvgkmsoOEdpzuut753v98xvNvcOFx91x83brfd+5hoH33H3KO3Hs9dXfcYuz/2ddBy3nph6njr67kIiIAIiIAIiIAIiIAIpINAXgtA3MRceeWVVvxp1aqVOf300039+vXN4sWLzQMPPGAfr776anP33XcXYf3ZZ5/Z14SMsKy0n5GXRCYCuUCAla9efvll895771kxhht03ifkWUFpx4OOMJzDDz/cdOrUqYjIwfjfeecdc++991pBFSEHzwkMoQBBpm7dunalL8K4EAp+/PHHQtEn1mvDVgz4D+GA9hF+8IjhuITmvPbaazYMB9GXsfBeRcDh8wAPHo6PyIE4gndE27ZtbcgO2/v372858IufEyYQqSjvzIk2HJcysCI30Ycffmjef/9960HD2OFHOyj5GMdr06aNIecRx4Lt2rVr7R9ePRhjcN4zeN3w3PHkuIwToYZHxs7nGseeN2+e4XOLdvnV2VuXviAK0V83n7QJE+oz72vWrCn0fGFMtI+oQZ3mzZtbsXvFihW2PvN53HHHFVnhivbI//Twww/btphn2NIPxohXETwIpaIvjIW+Mhb6j6B+/PHH21BBCyLmH3Nw+eWX27l1eaIYP21yDrEiHG0cc8wxhtBDwscQ8Xlk/I0aNbLtx+aQ+uKLL2w5wrYwEovTD8K8ghjz/fzzz5vly5fbcTVr1sz07Nkzkr9OMU/kReL7kfOE90337t0N4ZgyERABERABERABERCBaBDI6xAwPHnI+cEv5ISAuVwSTN0nn3xizjjjDDuLEyZMKLLv+uuvN1OnTjUjRowwRx99dNpnWiFgxZHKxbY4k0xv4aaflbtmzZoV+FDcXI8fP97eICOwkDcFwSWR4bGCyEKS5wMPPLCYgJSobuw+xAMn+nDz74wbeJaT5+Y1jNEWIoUsOAFy5yCeIwx16NDBEF6biiHUnH/++Ta3D8+d3XXXXdaL0yvCuX1+j4g8q1atKhTOXBkErVGjRhlWnUM04jkeoLHtIk6de+655sYbbyz0HnJtuEfEK8ZPjqpYQzzjO+Tss8+O3VVqr5MNASOfElycWOntaL9+/azA632/effreeYIKAQsc2xLo2WFgJUG5cwfQ9enmWec6SMoBCzThEunfYWABeec1x5A7iJ4jz32KCLwgI9f7QnnwCOAXz694hDCEeZdqchu0D8RyBECJNFFjFm9enVSI8JbhCS9M2fOtJ4SCKl+hkhDwt6DDz7YemSEDZHBswRxh+XaCdt86qmnzD777FPkkPSBsXBTHtYk/iRP7pFHHrF51fCCwdMnVUOIQXRZt26defzxx21zCDQkBk/GVq5c6VscDzDiqb/++mubwwnh388Qh2677TbbD344iDXOFTxDP/jgg9hd9jUecyQw53y8+OKLfctk00aSszPeeIZnF0xnzJhRGCYYr6y2i4AIiIAIiIAIiIAIlC2BvBaASKCE9w+/BpP3h5WInBEagPjDL824/TvjJgF3fm5Ya9eubTcTfkBYhAsJcWX1KAJRJYB3QrLijxvrd999Z7p06WJDfdw2Hgn5wRME0YdwHDwpwhg34IsWLbIiE+FpXs+SPn36WNHB5auhfTwUUhF/wvRRdf4lMHfu3LSjYNU3PC8JN0ScSLcRphbEEIiOPPJI07dv3yLFr7jiirjij7fgpZdeauvvu+++3s1Z9Zz3VyLxx3WWcrfeeqv1mnLb9CgCIiACIiACIiACIpB9BPJaAKpYsaL9pfb11183N998szn55JPtUtDz5883Y8eOtbPFTYZLqsoGfukk/wG5KvA2mDx5ss0hxM0s20466SQbypJ9U60eiUAwAgg/JSU5L6klwscwlr5G8OGvYcOGocO7EF55X+JZREga7rp+Rs4WkreTmwRjJT2W5pblFgHEBkILEQPL0uiHVwAiFIB8V0EM77Xbb7+98LsmSJ3SLsP4ghpC0ciRI0O/x4MeR+VEQAREQAREQAREQATCE8hrAQhsJA4lASi5KoYPH249e7jZRNBhKfbY5dVcAmi8hsaMGWPDxEgGTZ4L/kgajev/BRdckHBW+PWXPEJ+RvgZhmdDbP4Jv/L5sI2bJQyvLFlmCZC0NhUjQa4TfVJZCQ/vPJI0E1qCV4VLhFxS33hfEfKFIQbJco8ASa1dCG9Zjm7BggU2ubZbTY2E54R4BTVELELOysr4fkl0fATXoEbY6FtvvWWTugeto3KpE/j5558DfzamfjS1kE4C7rqGNvl+S+azI539UFupEXDzqOvT1DiWZW03h/SBeeT6UxY9Am4eE13XRG9UxXvs8jGm8iNo3gtAhKvgWQBEEsiy5Ds5JshZwao9rGzkXYbZ5f/hgp/EmISyYJx0eAPxiy43oK1btzYdCsJd4hmTF+/LHg8jjDbdyRyvnXzbLh6Zn3G3ilIyR8K7B9GHcx5PuLDGRfCcOXPse/CSSy6xQizvz6DiD8el/+48CTOWsH1XvdIlwI1vNhjJzp2XKM+TMe+5mky9dJZ175XYNvkOjPcdFVvWvWb88dpzZfSYfgJinn6mZdGi5rEsqKfvmJq/9LEs65Y0l2U9A6kdP9fnLx3jy2sBiBWB8PpBjMHbh6WL8fzBA+jJJ5+0Hj6UwQ3e5fshn8ihhx5qCB/zJoZGLSbsBC8ghCDyVHAzHM8QkHbZZRff3W41FfrCn+z/xDDxyPzZEO+89B6Z8x3x04k+CKdhjfw8b775piGPCOFaCKDHHnts4QpLQfrjPTbJ2915kmxdbzt6nr0EOP/4DM4GgY9zzJ1v5LlKxrznajL1Ui3r/dXI9T22Tbzv+J5KRmhj/PHai21fr1MnwDzyXuBPFj0CXMR7L+T13oneHNJjN4+av2jOH732fifqMzX685jr78V0jC+vBaCHHnrIsAwniWOPP/74wjOeBM8IPfyaiZhDqBfePhgXxN6k0IWV/v+Tjh072jokleYDJd4kEQLGn5+xDDwhDtxY6Ab2X0Jumc2dd965UBjwY6dtqRNAfBk8eHCxhkiIvt9++9m8WazgtdNOOxUrE3QDnneIPqzeRcik98uXNrp27Wq98Xh+1FFHGZb6DmqUd4IUyYJHjx4dtKrKRYRAmzZtrABJ6G5ZWsuWLQ0hj84OO+ywpEQTyrtz1bVRGo8ufI73dCLRyn2fBekTP4gQeikxIgit9JRhHvE+cx5o6WlVrZQWAS0DX1qkM3scXZ9mlm9ptO5dBp77DO9CIqVxfB0jPQTyaRl4iMXTGILQzGv3kqVLl1pGXOT6GeFfGCsOBTV3MR/GfT7oMVROBDJJgBu5E0880R6Cle3at29vc2UhTN55553WOyeM+LN27VrrWXfaaafZ1Y9uuummwvBL73j48kWUdcb704Vaum3xHhFnEY+cEYrZtm1b91KPOUIAz02EPcT6srQRI0YUOfxWW21lzj333CLb4r3gi/u8886LtzsrtsM5qMFC4k9QWionAiIgAiIgAiIgAmVDoGyvnstmzPaoJL90rrfxlF6X+8fl5KHixIkTrWdQ586dTa1atWxb3n8kwsSoi7eQTASiRoD3xjXXXGNatWplmjRpYnNjhR3D8uXLbWgXyWRdAvVEbXFTzApkLgySstxUEpJ5wAEHmJ9++ilu9QoVKtiV+fBq8Nq4cePM/vvvb9+33u16nnkChMuS04lfSNNlZ555pjnmmGNsc/fdd58544wz0tW0bYdwYMKe3EqQ8Rrv379/Ec9RV47cVawsOXfuXLfJ9/GWW26xK+P57sySjXj0MB4+DxIZ34dDhgxJVET7REAEREAEREAEREAEsoBA3noAcZPo8vosXLjQdyo++ugju93r4s+qLdyMclPpZyw7jbGymEwEokIAkZOwrE8//dSGZLECHQIQidGTNQRVln/fc889zTPPPGMeeOCBQOIPnj+EhXXwyZ1FkmluqJs1a+bbnX322ccKDX6eQrzPWZ0Jb6CwVqlSpbBV87IeQh5Cyssvv2w+/vjjlBKDO4B4o1155ZXm/vvvd5vM6aefbh599FGD501QY5VFP88hct7gVUQif8J+L7vsMt92ORbhuw8//LDvIennq6++ak4++WTf/ZxLiEtDhw713Z9tG1nZ8o477vANM2KeBw0aZFg5MFZ4zbZxqD8iIAIiIAIiIAIiIALG5K0HEJNPiJhNoV4AAEAASURBVNcnn3xiHnzwQdO4cWPjXbIaTx5uXF05+6TgH0lvuaHBo6Fv375F8j+8//771kOIsoS5yEQgmwkQpkjcM4l0k0n0GjsmPOloh6S8zZs3N9wAO3vuuefMkiVL7Hvs2WefNbyvXL4fbsKrVq1qc2qddNJJ5oQTTkgYd40IxHsM7wref4hU5MhCMOrUqVPCWFhEXAQkBCZuznnfI3jhabT33nsbxCd40CYsEMTw4iNJLyFkRxxxhPViQXCYNWuWzR1G3g28k6hDXWcIYPSLNhELEKcQw1hVkGWyaZ+bZdrftGmT/aPujjvuaI/DI4mx4bp69WqzcuVKQ1wzN9uwc8cieT1/eGxh8KQux6dvHJ++46mIFw4hr7TDyk545FCXY9AXvBWZC7bTPxLhMwZyPcEN7y3K0wfK0j7H4xh4ZiGysUIi9eDZrVs3O2b6xdgZA/nU+KzlOecIIiHHW7FihV3ljTb5DGYffeKc4hjU33fffW2b1apVo8kiRr623r172zxt06ZNK/T0ov/ML32qXr269WYjPxTi/KpVq2x/EDwZE5//9NmF8DKviE1nnXWW4Rx24cKEGFKO9hIZ3mj8SHDhhReaKVOmGDzhEFMRMMmxxXslSoaYR1goc8jCCJyDbp7dDylRGo/6KgIiIAIiIAIiIAL5SqBcwQ3AP/k6eIZOjgNWHuJGAY+HevXqma+//tqQ74QEfbjA33DDDYWIuNkib8OCBQvsthYtWhj+uPkhoS02cOBAe0NiX4T4x7G54MabiJsYmbE3itwQwoObQlk4AtzEI/jAMpml1f2OhoCB4MBfEA8MjulCgRBW4oVe+h1L27KHACISogpzKIsmgaBJoKM5uvzpNfPoBNn8GXXujFRJoHNjLrmu0fVptOdS16fRnj/X+3xKAk2Kjmuvvdb06NHDDT+px7y+k+ZXXsQd8voQRoCA40Qcfo0mpwFLw3uNX6ZvvPFGGwb21FNPWY8EvBKwPfbYwwo3qYSaeI+l57lNAC8PzjPOKWeIkmxHXMEzIZ7hCUI+HDwJOI8TGReZTvTB4ySscRyOh+CDNwMftCSDxqMkiAAUe1wEKMQ8Qm8ybV6ueLjQf1g4fmvWrLFj8eYeitcn+k15vFW8YqT3GMwdYhueEn65wLxlEZWZI/jSN5JwY8wZXkqI0rFGHfpRkicJ5whj5XjcLNasWdOKcNTHS4Xj4XHDBSzlvKIcZdhPyBLjYDzMM9sox3la0vFj+x37GrGdc5nziPOAMdG28yLj3OL9wT4YURbvLJh63zex7eq1CIiACIiACIiACIiACIhAcQJ5LQCBgxs4wgd69eplw1O4ISHMgKVx491YczNCiBehB+vWrbM3wrjBczMvE4FEBFjy/LrrrjPTp0+3wgnnGIJhu3btrFfZG2+8YW9wuQnuUBDaNGzYMEOCVWeEo5CPg5AebtA5F1kla9SoUUVWu+LG2Yk+zuvGtZHMI0IGAoDz8mGlnyeeeML23dsOwgBhUoS8kHA5nhECxkpi5IZxCdPr1q1rCAHDsw5RIp1GuBaCLWFfLnQqUfuIICwd/8gjjxRJRI3YxXa4I0I4g3/37t1t2BHiMceAGdud2IbXGkLyRRddZHMs3XzzzTaEzZtc3rUX7xGh5d5777WeNyQ+JqcRog68unTpYtt2+ZEIb+NXAUKPEGuSMUKh9ttvP7Ns2TIzb948O1bOUY7lZwhmRx55pD0+YVpBDMGccCLCr+IZ5xxeRghCGGIP57sz+sQS7JwzhA7G+6x25fUoAiIgAiIgAiIgAiIgAiJgTF6HgGXrCaAQsOIzkwsutgg33LDGu5kuPup/twwePNjcdttt5pRTTrGeZ37luAEmeS2rI+HKGkTs8GuHbXiNkKsGMQpxg2WtyZmCMIBHSkmG4BK7PDZ1XnrpJXvjH28lL4QgcrikK6cIqxchhIQxPEwI8yR3EKIdIl0ygo3fMRH1Um3Dr122ITox/3jSnHrqqSnNf7xjJNrO8e+++24b/pqoHCtfJbO0eKK23D7ENbwxw3ihuTby7VEhYLkx4woBi/Y8KgQs2vPnep8L16duLPn6qBCw3Jh5hYAFn8e89wAKjkolRSA8AZY2D7vqzz333GNDDfHI8BpeESRdPuSQQ0z79u1tQl7nVeMtF+T5hg0bbIJkvFjw0HDeFnjQ4MEycuTIQOIPx6IsYUx4eTgjRxaeds6jw233PuJ1ghcRgkuQUCxv3djniBFhxR/awnMGDxOEL/KApUO4SUcbseN0r/FKIm9YIm8dVzYTjxyf1aBIjoynlJ/NmDEj7eIPxyG5+Nlnn20TTPsdV9tEQAREQAREQAREQAREQAT+JSABSGeCCGSYADf+YcUf1zUn/uDlQIgVog8rPKWSg4Vfj/HyQfRhZZ94nkkkNY/nteP6F/tI6BqeGYRCYYSGJRJ/XH3CgggRu+CCC9ympB/5BYBwq1SNX4TweiL3TVQs3hyWVv8Robp27eqbn6d///4Z68ZDDz1kvY9cGFzGDqSGRUAEREAEREAEREAERCDCBCQARXjy1PVoEEBkWbt2bejOkpcGL5SDDz7YtGnTJiXvGJbgRvDhj1wxQSxZ8Yc2WRqdvDssu403Dflogho5hlIRgF588cWkc9/E61uiPDXx6uTzds4vVi/EI81rbHdhR97t6Xz+5JNP2mXW09mm2hIBERABERABERABERCBXCIgASiXZlNjyUoCS5YsSbpf5KAhMTSiT6tWrQpXRUq6oYIKhFY50efLL78M00SoOowbAYjjJxP+tHTpUhuCFnaVpw8//DBUf1UpPQSY91gBaObMmelpPEErYd5nCZrTLhEQAREQAREQAREQARHIOQISgHJuSjWgbCPAakZBjAS+3Dgj+rRo0aLIEuNB6rsyhAGxIh2hUD179rQr1bl9pfno8gi5x6DHJp8Mf2EFoGSPF7RfKheMgB//VJKSBzuqsauGBS2rciIgAiIgAiIgAiIgAiKQjwQkAOXjrGvMpUqgXr16cY9XtWpV06FguXdEnyZNmtjVnOIWTrCDm25WrcLThyS8LKtOyM26desS1MrsLlb1wurUqZNUcmJWAWPFrLCWiHfYNlUvOAE3794aBx10kPdlRp5r3jOCVY2KgAiIgAiIgAiIgAjkEAEJQDk0mRpKdhLo2LGjqVSpkvXIoYc1atSwgg+iT4MGDUJ3mrCqd9991yZyfvPNN82PP/5oky7fe++9ts1q1arZMDKWdE/Ftt5666QTIeOB1LlzZ3tYPJtgQE6gIIbXUipG2NmQIUPSshQ6DDOduyaVsWZb3cqVK9tzO7ZfnOfe90Ds/nS8Pv7449PRjNoQAREQAREQAREQAREQgZwlIAEoZ6dWA8sWAixpfsstt5h33nnH3hzj4RLW/vvf/5q3337bevrMmTPH/Prrr0WaYrUtlm13dv311xu8L/zCclyZkh6vuuoqc8011ySVWPmKK64wO+ywQ2HTo0ePtkJVSbmAqlSpYkaMGFFYL8wTRBvaSGUZeI7LCmasvrbnnnvakLQwfcm3Otddd13cfFW33XabOeWUUzKC5Mgjj7SedBlpXI2KgAiIgAiIgAiIgAiIQI4Q2CxHxqFhiEBWESAPD8uer1q1yixatMg0btzYnHbaaSaM+IPog0fNo48+ag477DC7pPqMGTOKiT+EfV1yySVFOLB62JgxY0Ln0zn77LPNyJEjrXjjlnQvcgCfF2eddZY5//zzi+whp9E999yTMK/RzjvvbFjBC4+hVO3KK680vXr1Ct3MFltsYT2W8NZ67rnnbAhb6Mb+f8Vy5cql2kTC+kOHDk1Z9Ep4gBJ2Dh8+3JxxxhlxS7EM/IABA+LuD7uDJOmPP/542OqqJwIiIAIiIAIiIAIiIAJ5Q0ACUN5MtQaaaQKIPiyZvmLFCrNw4ULz8ccfm6+//jrp8Cn6+f333xtWTmIZckSchg0bmjvuuMNcffXVpnr16kWGwr7HHnvM/m22WfG3NDfec+fOteKRd3+FChUM+7hxx/PGa02bNjWTJk0yd911l93cvHlzs3z5cpukOp6Qgcj19NNPm/vvv9/bVOHzHj16mKlTp1ovKG+CZzyk6AfMWrZsWVg+lSe0P378ePPII4+Y+vXrB26KsTHWzz//3LRt29bWO+aYYwwri+2+++7F2qH8PvvsY/baa68i+7yMYN6pUyfruQUbciIlawhS55xzjrnsssvMrrvuWqR6s2bNrEiFh81FF11kEAc5Z8IYq88dcMABxc6HRG0h7k2ZMsXcdNNNiYrZfffdd58VawgHS2TMn5ehX1k83fBMI/yxpPb86mubCIiACIiACIiACIiACOQbgXIFN63/5Nugs328r7zyir3Zmz17dpFwnmzvdyb7hxcMogg3fdwMZ4uxWhWiz8aNG22On6Arfvn1n8TH/DFWxlmzZk2/YnYby7lzTMKddtttt7jlYneQJwiBaquttrLeSOT3wfgYQOBhP+2RnDqe/f777zY0au3atfbGm7Il1aEt5o+xYRx/zZo1drx4RQX1LrKVQ/yjr4hxjBNB5ueffzYIT/D77bffzPz5863nEauwJeoLXl0vvPCCWblypRVZ2rVrV5i4e/Xq1ebbb7815MGBCTxhRQhZxYoVi/Tald1xxx3t6lXfffedYRuiR+vWrW35CRMmWGbkUkKQc8Y5R9ucd4iBseKdK7d+/Xrb5jbbbGNZf/PNN4YEzYybkECOvWHDBjsnMKGPLgE3nDjH3Htu06ZN9ngcmxW9OM8RXRDFYgUpd/ySHhkvIifnHF48cCLfEu8BBDWOQx94vzNPJDRnDjl3GDflSxKJSupDvu53ea0Q2sLOX76yy6ZxM4+ItniIyqJHgO8eVuvEmEPmUhY9Atl6fRo9kmXXY+/1KddwqSxEUnaj0JH5PCXVhDcVRi5S4d6ChYNIdcGP62FMAlAYahmuIwGoOOBs+oLl5pmbVr4w+OOmOKwhwHAjTtgTHjm5fEOrL9iwZ0l21eMLFgGIiyRZNAlIAIrmvMX2WgJQLJFovZYAFK35itfbbLo+jddHbU9MQNeniflEZa8EoOAzlT2uFMH7rJIiUOoEuOHlg4UvCR5TcZyjLh4MiD54Y+S7wZMVwvD2wFuFECzCkLzharnICG+i1157zXz22WfWqwU1H48iPKPwjMFjB5GlQ4cOZu+997aiI5zw/sFLifOHhOC8JuH20Ucfbfr27ZuLqDQmERABERABERABERABERCBNBCQAJQGiGoiNwngRojgwx/hNqmIPuQD+s9//mP/CH3hZv+BBx6w4T65Sa/kUeFJxQpjN954Y2FomKvFsuHky2EFs1y0W2+91ZComvPKawiChFvFGgIQ540LoYvdz+uJEycaEnCT9Lt3795+RbRNBERABERABERABERABEQgjwlIAMrjydfQixMg7wi5dRB9yBOTipFrhxWkEH7IDeO1xYsX24TK5JM5/PDDvbvy4jlhcz179jTPP/+873iXLl1qDjnkECtqdOvWzbdMVDeyUhYijZ/5iT+Uw0soiFG/T58+hvw/Q4YMCVJFZURABERABERABERABERABPKEgASgPJloDTM+ARe/jfDz66+/xi9Ywh7y9xCKQ06fhx9+2K7IlKgKYhNLlbPiFEug55Oxolk88cdxwEOIpe2XLVuWVKJrVz8bH1muPJ74k87+nnvuuea4447LGW7pZKO2REAEREAEREAEREAERCBfCRRfMzpfSWjceUUATwlWhmJ5b7xxCK8JI/4g+rAaEqsnsRx3vXr1rAhEZvYgRv6be+65J0jRnClDPqUbbrgh0HiYk9tvvz1Q2SgUYtny0jDCFQcMGFAah9IxREAEREAEREAEREAEREAEIkJAAlBEJkrdTJ0ASXcRehYtWmSWLFliBSBW4UjWSE5MAt46derYhMUsrU2yXrc8/ezZs5MSk6ZNm5ZsFyJdHv54WwW16dOnBy2a1eVI1ow3U2nZnDlzSutQOo4IiIAIiIAIiIAIiIAIiEAECCgELAKTpC6GI4AXBHl8XCJnQq7CGuIOnj4IP4R5JVqhCs+iZCzZ8sm0nY1l3RLUQfvGqli5YKU9zwieMhEQAREQAREQAREQAREQARFwBCQAORJ6zAkCJBdmZSUn+hBuFNa23HJLm8+HnD6IPoR7BTHKJmMVK1ZMpnjky26//fZJjSFX+CR7XiQFyafwVltt5bNVm0RABERABERABERABERABPKVgASgfJ35HBo3os+PP/5ow4rIqUPy4LDGTTNePog+2223XWDRx3u8Aw44wPuyxOfJli+xwSwv0LRpU7P55psHnqcDDzwwy0cUrHsNGzY0iFmcq6VhhCbKREAEREAEREAEREAEREAERMARUA4gR0KPkSKAyLNhwwa7PPYHH3xgH3kdRvwpX768XS2pUaNGBnGiRo0aBi+VoB4/seCqVq1qunfvHrs57uuBAwfG3ZeLOxBBevfuHXhoucIHjzKWgC8tK62E06U1Hh1HBERABERABERABERABEQgNQLyAEqNn2qXIgHEnfXr11sPCsK8yPET1rbddlvr5YO3zzbbbBO2mbj1WLmKZNDffvtt3DLsGDVqlF09LGGhHNw5evRo88Ybb5iS8vucffbZpm3btjlD4LLLLjNTp041S5cuzeiYOnbsaLp06ZLRY6hxERABERABERABERABERCBaBGQB1C05ivvekvi5m+++cawgtK6devMqlWrrAAURvwhpGuPPfYw++67r2ncuLGpXr16RsQfJonjzJo1yzRo0MB3zkgifemllxqEkHy0KlWqmDfffNN6XPmNH++r4cOH59QS8IwTz7KZM2cmLWolSjoey++www4zr776auxmvRYBERABERABERABERABEchzAvIAyvMTIBuH//vvv9t8PiRyTnUlIxLvks+Hv9JOiluvXj2zePFi8/TTT5sXX3zRrFixwuYV2m+//cwpp5xi6tevn434S61PtWvXNvPnzzcTJ040U6ZMMV9++aUV5Fq0aGH69+9vRbpS60wpHogQQcRBzolJkyaZzz//3BAe1qRJExs6uHDhQvP6669b77HKlSub9u3b2/MFwWzy5MlWDKU874/vvvvO/Prrr/bcRmy8+uqrzSGHHFKKo9GhREAEREAEREAEREAEREAEokKgXIEnRfg4mqiMMmL9nD59ujn33HPtDeLOO+8csd6H6y6ePog93Mymslw7Rye8q0KFCvaPZMOy7CDw559/FobtbbHFFiYZr5bsGIF6AQFW1uNrAxFKFk0C3s/Y0hbGo0ksO3vNPPIdp++57JyfknrFAhZupVK+D/lelEWPgJtHvhPD5o6M3qhzq8e8D5lHTNen0Z3bfLk+xVHi4IMPtj/69uzZM9SE6dsmFLbSqcQFQS7fJP/3v/+1og/CD+JAWOMLF8GHEC8ec5lZWEbZUI95cnpzrp/b2cA7033Q+yzThDPfPu9JzWPmOWfyCJrDTNLNbNvu+5CjaB4zyzqTrbt51BxmknLpta3r09Jjne4j8R7k/Zjr1zXpGJ8EoHSffWlojxMYY7UkQpey3RBw7r//fuuxtHLlSivEtGzZ0px++ummTZs2hd3nTUlZQlc2btyYkqcPv3hWqlTJLtkOp3S8GQo7qicZIcC8I/phhObJgyQjmEM3+sMPP5j77rvPvPzyy2b16tU2X1Hr1q3NWWedZQhbdEY5fmWJwmeT67MeixL46quv7AY+NzWPRdlE6RXzyCIG/Pghix6B3377zfB5ijGP5IiTRY8A1zVc33AtKi+u6M0fPdb1aTTnLbbXfJ7iUJDr1zV4AGGp3PtKAIo9e/Q6KQLvvPOO6datm3E3FK7yRx99ZB599FEzYMAAw3LUP//8s/2ATcXThxOdVbsIi+NCKZUT3/VTjyIgAsauyNajRw+zYcOGIjiWLFlixowZY4YNG2ZuuukmveeK0NELERABERABERABERABEYgWAQlA0ZqvrOrtp59+ajp16mTFHW/H8Oxo1aqVjU9s166d+eKLL7y7k3pOfgqUXEK7yHew66676heWpAiqsAgkJrBgwQK7ZLzzzvIrfeutt9o8IzfeeKPfbm0TAREQAREQAREQAREQARGIAAEJQBGYpGzt4pAhQ4qIP7i+XnHFFTbsi0TMYa18+fJW9EH4ca7tzsU2bJuqJwIi4E9g4MCBhaF5/iX+3XrzzTebvn37mho1aiQqpn0iIAIiIAIiIAIiIAIiIAJZSmCzLO2XupXlBFjS/NVXXy3SS/KC1KxZ067CVWRHgBfEv1evXt0u/c1y2HvssUeh+BOguoqIgAiEILB48WJDGGcQI4fXww8/HKSoyoiACIiACIiACIiACIiACGQhAXkAZeGkRKFL7733nm83//Of/5i6dev67ovdSFgXOX3w9MHrRyYCIlC6BOK9j+P1Itny8drRdhEQAREQAREQAREQAREQgdInIAGo9JnnxBF//fVX33EgALFqUDwjebMTfcjvIxMBESg7AvHex/F6lGz5eO1ouwiIgAiIgAiIgAiIgAiIQOkTkABU+sxz4oiEevnZl19+aVgK3u1n1S+8BtasWWNGjx6tpb/9oGmbCJQRAfc+DXr4ZMsHbVflREAEREAEREAEREAEREAEMk9AAlDmGefkEdq0aWMqVapkfvjhh2LjmzZtmqlXr56ZOXOmmTNnjsFrgCWkWR1MJgIikD0EDjnkEEP+rd9++y1Qp4488shA5VRIBERABERABERABERABEQg+wgoCXT2zUkkekT41qWXXurb17Fjx5oLLrjAzJgxw4o/1apVMwMGDPAtq40iIAJlR4CQzBEjRgTqQO3atU2/fv0ClVUhERABERABERABERABERCB7CMgASj75iQyPTrvvPNMr169EvaXG8zJkydrRa+ElLRTBMqOwGWXXWZK8uwhbxfv46233rrsOqoji4AIiIAIiIAIiIAIiIAIpERAAlBK+PK7crly5cxTTz1lbrnlFhsOFkujU6dONv9Pq1atYnfptQiIQJYQ2Hzzzc3zzz9vrrnmGoNgG2uIQ/PnzzdNmjSJ3aXXIiACIiACIiACIiACIiACESKgHEARmqxs7Coi0LBhw8zZZ59t8/2QAJrl3Vu2bGlq1aqVjV1Wn0RABGIIIAJdfPHF5vzzzzezZ882q1evNjvssINBvN19991jSuulCIiACIiACIiACIiACIhAFAlIAIrirGVhn8kJdPDBB2dhz9QlERCBoATKly9vOnbsGLS4yomACIiACIiACIiACIiACESIgELAIjRZ6qoIiIAIiIAIiIAIiIAIiIAIiIAIiIAIhCEgASgMNdURAREQAREQAREQAREQAREQAREQAREQgQgRkAAUoclSV0VABERABERABERABERABERABERABEQgDAEJQGGoqY4IiIAIiIAIiIAIiIAIiIAIiIAIiIAIRIiABKAITZa6KgIiIAIiIAIiIAIiIAIiIAIiIAIiIAJhCGgVsDDUSqnO//73P/Pnn3+W0tGy+zBw+OuvvyyPf/75J7s7q975EmD++MN0XvsiisRGN4+aw0hMl28n3fuQz1LNoy+iSGxkHpk/zWEkpqtYJ5k39150c1mskDZkPQE3jzzq+jTrp8u3g7z/3HtRn6e+iCKx0c1jrs9hOsYnASiLT+n27dtnce/UNREQAREQAREQAREQAREQAREQAREQgagQKFegVsudIstma/Xq1ebtt9/Osl6VbXc4Tf/++2+z2WabmXLlypVtZ3T0UATee+89s27dOlu3Q4cOpmLFiqHaUaWyJcD7kPfj5ptvXrYd0dFDE5gyZYqtu91225lDDz00dDuqWLYE8BLWd2LZzkEqR1+7dq2ZP3++baJevXqmfv36qTSnumVEQNenZQQ+jYfV9WkaYZZhU/l2fdqyZUtTu3btUMQlAIXCpkoiIALJEjjnnHPMK6+8Yqu9+OKLpm7dusk2ofIiIAJpIMDNJsaFw7Rp09LQopoQARFIlgDvvaFDh9pqgwYNMueee26yTai8CIhAGgjw3ps+fbpt6YUXXjDuOzINTasJEchKAkoCnZXTok6JgAiIgAiIgAiIgAiIgAiIgAiIgAiIQPoISABKH0u1JAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJZSUACUFZOizolAiIgAiIgAiIgAiIgAiIgAiIgAiIgAukjIAEofSzVkgiIgAiIgAiIgAiIgAiIgAiIgAiIgAhkJQEJQFk5LeqUCIiACIiACIiACIiACIiACIiACIiACKSPwBbpa0otiYAIiEB8Ao0aNTK//fabLVChQoX4BbVHBEQgowQOOugg2361atUyehw1LgIiEJ/ALrvsYtx7sVatWvELao8IiEBGCTRs2NBs2rTJHmO77bbL6LHUuAhkAwEtA58Ns6A+iIAIiIAIiIAIiIAIiIAIiIAIiIAIiEAGCSgELINw1bQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIZAMBCUDZMAvqgwiIgAiIgAiIgAiIgAiIgAiIgAiIgAhkkIAEoAzCVdMiIAIiIAIiIAIiIAIiIAIiIAIiIAIikA0EJABlwyyoDyIgAiIgAiIgAiIgAiIgAiIgAiIgAiKQQQISgDIIV02LgAiIgAiIgAiIgAiIgAiIgAiIgAiIQDYQ0DLw2TAL6oMI5ACB+fPnm+nTp5sVK1aYzTff3LCs7bHHHmsaNGjgO7r//Oc/ZvHixb772Fi5cmVz4oknxt2vHSIgAsUJbNy40TzzzDNm2bJlZsOGDaZ69eqmU6dOpn379mazzfx/8/n999/NpEmTDO/h77//3uy9996madOmpnPnzva9XPwo2iICIlASgWTfiyxD/dBDDyVstmvXrqZOnToJy2inCOQ7Ad5Lw4cPN1WrVjWXXXZZXBxhvvvC1InbAe0QgTIioGXgywi8DisCuUTg9ttvN88++6wd0tZbb23++ecf88cff5hy5cqZ0047zfTr16/YcIcOHWref//9Ytvdhtq1a5tx48a5l3oUAREogcC8efPMNddcY3788UdbEhF1/fr19nnHjh3N5ZdfXqyFH374wQwaNMisXr3a7ttpp50MN67YQQcdZOtstdVW9rX+iYAIBCMQ5r3IDyKDBw9OeADe3/+PvfOAl6K6/vhBEEFQqoIgKKCiYlfEEuwt9iiKGA2xRWPsSmKL2KNiwxJLLNiwYm9RI/aGYu8iCBZUEFSKNPc/v5v/nczu2923Zfa92X3f8/m8N7Mzd+7c+70zuzu/PedcibkYBCCQnYC+f5500kn24osv2rrrrmuXXXZZ1oKlfPaVckzWk7MRAo1MAA+gRh4ATg+BaicgTx6JP3pIPProo23rrbe2X3/91R577DG74oor7LrrrrN+/frZBhtskNbVTz/91L0+6qijTKJRpi211FKZm3gNAQjkICDR5owzzrBZs2bZFltsYccff7y1b9/eiUEjRoywp556yvr06WP77bdfWg1nnXWWE38GDBhgf//7361du3b21Vdf2SmnnGLPPfec+/KsX1IxCECgMAKl3ov+M3H99de3rbbaKuvJ5J2HQQAC2QnMnTvXRo4c6cSf7CX+t7WUz75SjvnfGVmDQHII4AGUnLGgJRCoSgInn3yyPf/887bjjju6X12infjrX/9qL7/8sm2//fZ26qmnhru+++4723PPPa1Tp052//33h9tZgQAESiNw4YUX2gMPPOBCLq+55hrnfedrWrhwofPCk5ePRNm11lrL7frggw/s0EMPtdatW9uDDz5orVq18oc4L6A99tjDhYDpHkWQDdGwAoG8BEq5F1XheeedZ4888ogNGzbMdt1117znYCcEIJBOQCHM559/vk2dOtWFO+uHyFweQKV89pVyTHoLeQWB5BDInhAgOe2jJRCAQMIJfPPNN66FG264YZ2WDhw40G2TR0HU/C+dffv2jW5mHQIQKJHAe++9545U3iyFXkatRYsWtssuu7jQzKeffjrc9cwzz7h1hZRExR9tVCiY7mmFcsqbD4MABAojUMq9qJo/++wzdwI+FwvjTCkIeAJPPvmkHXvssU78kTfrcccd53dlXZby2VfKMVlPzkYIJIAAAlAC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AIGmRwABqOmNOT2GAAQgAAEIQKAAAjfccIMrteOOO9rOO+/s1m+88UabN29eAUdTBAIQgAAEIAABCCSLAAJQssaD1kAAAhCAAAQgkAACr7/+ur377ruuJTvssIPtvffebv3777+3e+65JwEtpAkQgAAEIAABCECgOAItiitOaQhAAAIQgAAEIFD7BK6//nrXyZYtW9pWW21lSyyxhHXu3NmUF+jqq6+23//+9wVDmD59uj3++OM2adIkW7RokfXp08cGDBhgK620Ulod48aNM5X19uWXX9prr73mXq6//vrWvHlzF5L21ltvuW09e/a0rl27+uJpS9UzYcIEt61fv37Wpk2btP3+hULNPvroI/c3depUW3HFFW3llVe21Vdf3fXXl2MJAQhAAAIQgED1E2gWxLOTwa/6x5EeQAACEIAABCAQE4G5c+facsstZz/++KNp5i+fjPmII46wK6+80p1F3kFrrLFG3jNqJq9jjjnGlEsoM2xsscUWs/32288uvPBCW2aZZVw9iy++uC1cuDBrnTNnzrR27drZF1984UQaFRoxYoSdcMIJWcvffPPNNnToULdPIlL//v3Tyk2ePNkOPPBA+89//pO23b9o1aqVDR8+3NXfokX674WaBWzUqFFOVFIfMQhAAAIQgAAEqoNA+id6dbSZVkIAAhCAAAQgAIGKEbj33nud+KMTeBFF63/84x9DAeiqq64K17Uv0+SBs/nmm9v777/vdi277LK24YYbmsSUxx57zAlCEmk++eQTGzt2rElwkZfPL7/8Ym+//bY7pnv37k6I0gt5/8RlTz75pO255572888/m4SoTTfd1Hr16uW8k9QeeSKpHSeddJIrc84558R1auqBAAQgAAEIQKARCZADqBHhc2oIQAACEIAABJJHwId/aeav3XbbLWzgBhtsEHr9yKsnn/fLcccdF4o/hx56qPPceeihh+y+++4zzfR18MEHu3pfeeUV8wKL1jXVvDd5HEmM0V/btm395rKXp5xyihN2OnXqZAone+655+ymm25ynkryFnrxxRdt6aWXdueR0DVnzpyyz0kFEIAABCAAAQg0PgEEoMYfA1oAAQhAAAIQgEBCCEycONGeeeYZ15p99tnHeeZEmyYvINlPP/1ko0ePduuZ/z799FOTd49M+YOUM0gePt4UyqXQLwkwsltuucVNMe/3V3L5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AAQgAAEIQAACEIAABCAAAQg0AgGfx8d7+CgUKy5r06aNtWvXzgk+Cu+KCj0KJWvqVnMC0A8//GB33XWXffLJJzZ9+nTr3r27bbvttrb55punDX504FVOx0yYMMG+/fZb5xLWq1cvGzx4sFMHo2XrWx87dqy98847OYt17tzZfv/73+fczw4IQAACEIAABCAAAQhAAAIQgECtEFAenzlz5oRhXcrjo21xWKtWrZzYI9FH3j4tWtScxBEHprCOmqLzyiuv2Nlnn+3cutRDiS2ff/65Pf/887bNNtvY8OHDw477lWeeecbOPfdcl1hKMYGdOnWyN954w1577TV78MEH7W9/+5ttvfXWvni9ywceeMAdn6tg7969EYBywWE7BCAAAQhAAAIQgAAEIAABCFQ9AU3H7sO6tIwrj8/iiy8ehnRJ9FFOH6xwAjUjAMnz54wzznBTwm2xxRZ2/PHHu8ROcisbMWKEPfXUU9anTx/bb7/9QjpfffVVKP4ccMABTphRIijFHN58883u77zzzrNVVlnFevToER6Xb+XTTz91u4866qisSaWkSmIQgAAEIAABCEAAAhCAAAQgAIFaIbBgwYJQ8NEz+Pz582Ppms/j48O6llxyyVjqbaqV1IwAdMMNNzjxZ7XVVrMzzzzTlOBJpgvl9NNPt6FDh9q1115ra621lvvTvoceesh5/sg76MADD9QmZxKBDjnkEJs8ebLJQ0jlDj/8cL875/K7775zF728iPbaa6+c5dgBAQhAAAIQgAAEIAABCEAAAhCoVgLK46NQLp/HRyFecZly9yhxs57lldMnmscnrnM01XpqRgB677333Bgqv44Xf/ygKg5wl112sSuvvNKefvrpUAB68803XZGBAwf6omnLAQMGOAHos88+S9ue64X3/unbt2+uImyHAAQgAAEIQAACEIAABCAAAQhUFQHl7FGyZj89+6xZs2LL49O6deswrEvCj1KzYJUhUBMCkC7GKVOmOEJK3pzNunXr5ja/9dZb4e7LLrvMJYpu3759uC26orAyWa790bJazxSA/HR2HTt2zCzKawhAAAIQgAAEIAABCEAAAhCAQGIJaNasaB6fRYsWxdJW5fHxIV0SfMjjEwvWgiqpCQFIHj+KBVScYa6p3XThyryoo3WFenlhSK+jJvHmsccec5v69esX3ZVz3QtAOvbYY481eRjp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cDnsxwcfkhIhIASEgBAQAmkikDoBRFQtZP/994/VTlRacZBMyFDCq4sAigWbEgkBISAEhIAQEAJCQAg0AgKEY/cmXRA/RH1NQ4g26026+GRjVCIEhIAQEAJCoJIIpEoA4dhu9uzZrr34/okrrVq1cknffPPNuFmUTggIASEgBISAEBACQkAIpI4Afny8hg+fP//8cyp1sOnpTbrQ9MGPj0QICAEhIASEQGMikCoBhOPjFi1auGhar776qll99dVjXctzzz3n0q200kqx0iuREBACQkAICAEhIASEgBBIAwE0evDj40mfH3/8MY1inZNmApN4sy78+MhxcyrQqhAhIASEgBAoEYFUCSDasPHGG5tHH33UnHnmmaZ///6OECrUNkzGrrvuOpdkq622KpRU54SAEBACQkAICAEhIASEQFkIeD8+3qwrTT8+aPV4sy6idsmPT1ldpcxCQAgIASGQMgKpE0DHH3+8I4Dee+89s+WWW5pRo0YZQsbn7niw03LppZeasWPHGlRtW7duLf8/KXeuihMCQkAICAEhIASEgBAwBq0er+HDJ9G70hD89oTNuvDrIxECQkAICAEhUK0IpE4A9evXzxx11FHm8ssvN2+88YYZMmSIWX755Q0+gdq3b29++ukns2DBAvPRRx8ZnOoha6yxhpk6daoLcVmtQKldQkAICAEhIASEgBAQArWBAH57IHo86cNmYxqCRo8nfPiUH580UFUZQkAICAEh0FgIpE4A0fBx48Y5jZ7zzz/f7bh88803hj/CvecKZl/33nuvI4lyz+m3EBACQkAICAEhIASEgBAohgB+fDzhw2eafnzw3eP9+ODTJ1ervVjbdF4ICAEhIASEQLUgUBECiCgH+AA66KCDzPTp011kMKKD8ccOzAorrGDWX399s8suuzjzMKnLVstwUDuEgBAQAkJACAgBIVD9CGDC9Y9//CMTnh0/PmnJMsssk+XHh3mtRAgIASEgBIRAPSBQEQLIA0NUr/3228//1KcQEAJCQAiUiADOShcuXOhMZTGpTWtB8vnnn5uvv/7atGnTxpHzJTZP2f6DAFoIH3/8sfnhhx9Mhw4d3CISfMF5ueWWMyuvvHIWVjijxSwajQXemZhMe/H5iK7J8Q8++MD1FeWsuuqqTiPBp/WfjJNPPvnEsIBlc+Xbb791GrkrrriiT5L1Sd3fffedadeunWnVqpUrn7ZSJ+1PIizAufalllrKmX37zZ1FixYZ/lq2bOmuMV+ZX331lfniiy/ctWIyHlfQ9GCD6csvvzRrrrmm6dy5s9PQ4H757LPPXL3UXSmJ6vPca541a5Z58sknXf8PGjTI4DcGicpbqXYmLZex8+mnnxocGfPMydV6gYChv+l3xjVjJongJuD11183Xbt2NZtttlnRrIzrxYsXu3GNCwGwS0voD6/hg1mXH7tplR+nHH8v8hyo5HiN0xalEQJCoPERwD8uzwHeoR07djRE15YIgYogYCefjSZ2khDYwd1o9dVjRXbiGJx66qk1dWn0uV1QuD+7W1dTbW8OjbWTePVNlXY0fXPPPfcEdnEU2MVXYF8C7s8u1INTTjklsIv9klpuF07BlVdeGVj/a5kyKXvttdcObrjhhoB6JfEQsIvkwBIPgTVzDoYPHx5YoiaDKX1mF8+Z32BsF8rBn//858CSLsHZZ58dWGIm63z37t2DkSNHBhtuuGHWcd/34c8ePXoENpKma+izzz4b9OnTJ2+etdZaK7ARN13f2sVzYE20A0uyZKW3pFHWb7sQDcaMGROQvpC89tprwfbbbx9Y3yiZ/HYRHfTt2zewhEzmGG1fffXVA+sjMPjll18yRd5xxx1Bt27dstLZyW9w0UUXBdaPSyZd7hcbbCLo3bt31r1BHXbxHlgyIqs82nHttdemOrbz9bk1EcqqO9xn/jvYWi3prPFiSV2H2XPPPZd7qY36+7HHHgt69uyZdQ1t27YNzjjjjMDP40477bTAksZZaXr16hU88cQTBdvKs+eAAw4ILOGSlZc+23PPPQOrJZ6Vn/puvvnmwAYMCR566KHgpZdeSuWPMcv4sURdYAnErDob8wf3FvcY48GPDT5tRN3ggQceaMymZNXFfefnbYxzSfUhYAlz996pvpapRfSNv3945hWTl19+ObA+dLPeobzDjj766ICyJOkiYDfoXP/E6Zt0a06nNN4bdqMruPvuu0sucAly2pdNRYTdvAsuuMC88sorhqhg7OzZCbKxkzrz4YcfOu2gY4891jmKTms3uyIXUkWFElFtnXXWMXbCUEWtKtwUdgdhtRF22NiZllQPAjwC2ClX31RPn/iWWKLAnHzyyf5ng0+0HR5//PEGWiUNEoYO4Igf89tp06aFjmZ/HTp0qLntttsUvjgblshfaM/wftt9993dey0yUcRB/IhgvlKuoJWBRsmDDz5o4rzOd9ppJ6cp8+KLL8auGu2MRx55JFLDY9KkSebAAw80ltCJXR4J+/fvb+677z5jJ7jm+uuvz5uXaKJRQSIsSWEGDhzozMrzZo44sfPOO5s777yzbA2P999/32y77baJ+jyiOZGH6FN8KYJNY8s555xjzjrrrLzVWiLRRc96991386YZPXq0sSRmg/N20uqCfqBVlE86depkLAFmcODMvcVnGgKmaDJ5LR/mIRxrSkHDasCAAcaSWnmbcdxxx5lLLrkk7/lKncBdAxqIyNJLL+20FytVl8otDQH6B4fkaIRKqgsB+sY7nbfkeUGNbbvpZg499NC8Go1owzLP49krSQcBtIZ5vxTrm3RqS78U5vFozvKu3XXXXUuqoCIEEJNQJi92d9MBHG6ZJ4CeeuopY3cH3am99trLTJw4sewJWbieev0uAqhee7bprksEUNNhX6jm+++/35HjhdJwzmqKGLt7FJusGTZsmLn66quLFWtGjBjhCPyiCZt5AsyOtthiC1NoQVwPEFkNnwak4QsvvOCu3e6ilXSJVsvBvPrqq0XzQq5ZLaFMOkzh2AhhElSKlLuohpTAj+Hbb79dSvWx8zz88MOOKIudocyEkL577713maX8OzskG0RyWDbddFO3IRg+hokDE1nObbLJJsZqIcZ+loXLifoOyYo5F6QPTpyrbaORe4o+LiZE1T3yyCOLJUv1vAigVOGsSGEigCoCayqFxiWArAavsZq7jlQvVDEm33PmzNEGeiGQEpwTAWRMRbzaXXrppeb444935A8v9w022MBYte+srmG30NtYM+k4/PDDs87rhxAQAkKguSIAKXfCCSfEunx8aNxyyy2x0r7zzjvmmmuuiZX24osvdr5kYiVuxomseUrdkz90rzW/cUEdwl2Ndlqp5A/lxCF/SAeZAMnpxZoilUz+UMb48ePL0tyxpnQVJ39o54knnshHowj9eNJJJ6VWF23HR5AXyEK0wRFreuqIJjYKCRRy1VVXGWsWZtZbb72yyB98Z+CTiPkmxPi6667rtCMhgaqN/LGmcrHIH/A6/fTTU9EWpCyJEBAC1YMAG23h52S+lrHpccUVV+Q7reNCIDECqRNAMJTWR41ryA477GBQk2aBwvewoDrNOXZOETSA5s2bF06i70JACAiB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qdVJclpYqBwhIASEgBAQAvWEQOoEEE4t586daw499FDn+C8OWNiwPfzwwwb/NrXk2ybOtSmNEBACQkAICAEhIATSQABTLsgeSB+Cbfhd5nLLxozLa/hA/MhUu1xElV8ICAEhIASEQHUikDoBRHQRQnFuu+22sQmgp20EEKIdELVDIgSEgBAQAkJACAgBIWCc+bTX8IH4wTQnDcEpOESP/5MfkTRQVRlCQAgIASEgBKofgdQJoCSXjL06foGIjIHIN0wS9JRWCAgBISAEhIAQqCcE8FmEZo8nffCRk4bgKwBTLq/lU6vOL9PAQmUIASEgBISAEGjOCJRFAO2www5m+vTpWfj53amdd965qNMr0obVlzfeeOOssvRDCAgBISAEhIAQEAL1igBzIHz3eLMufPqkJThX9n58cOIsR6RpIatyhIAQEAJCQAjULgJlEUAXXXSR6dq1a6RKsieC4kKz3nrrmcGDB8dNrnRCQAgIASEgBISAEKgpBHxkPwgf/tL047PUUktlNHwgfjDzkggBISAEhIAQEAJCIIxAWbODtdZay1x11VXmlVdeyZSJM+cFCxaYAQMGmA4dOmSOR33BySA7VJ06dTJDhw41yy23XFQyHRMCQkAICAEhIASEQE0iQMhWb9IF6eND05d7Md6PjzfrggCSCAEhIASEgBAQAkKgEAJlEUAUfNBBB7k/XwlmYRBARx55pOG7RAgIASEgBISAEBACzQUBCB5v0sUnBFAaggkXfny8WddvfvMbg28fiRAQAkJACAgBISAE4iJQNgGUW9G+++5revToYdZcc83cU/otBISAEBACQkAICIG6QgA/PphyedKHUO1pCb57fKQu+fFJC1WVIwSEgBAQAkKg+SKQOgHEBOirr75yoUvjwnruuecaTMd23HFHc+qpp8bNpnRCQAgIASEgBISAEGhUBPDjg7Nm5jv8Qf5wLA0hHLs36YL4+dWvfpVGsSpDCAgBISAEhIAQEAIOgdQJoAcffNA89NBDZttttzXrrLNOLJiffvpp88ILL5jVVlstVnolEgJCQAgIASEgBIRAYyFAOPawH59//etfqVSNL0Rv0sXnkksumUq5KkQICAEhIASEgBAQAlEIpE4ARVWS7xgTqPfee8/Mnj3bJVlmmWXyJdVxISAEhIAQEAJCQAg0CgJEMvUmXXz+/PPPqdSLHx9v0oWmD358JEJACAgBISAEhIAQaCwEyiKAcPI8ffr0rLb68O8777yzYaJTSEiL7byXjTfe2H/VpxAQAkKg0RDAaeu0adPMM888YxYvXmzatm1rtt56a6fJWOw5llYjv/nmG3PfffeZ119/3fz4449m1VVXNTvttJNp06ZNKlUsXLjQnH322WbGjBkGHyUrrrii2X///c3BBx+ct/yPPvrI3Hvvveadd95xadDq3HXXXc3KK6+cN0/uiW+//dZd12uvveaui6iPXNf666+fm7TBbzYJMA9+6qmnzNdff21at25tOnbs6L5//PHHbvG80UYbmSFDhuSNIvnpp5+ae+65x8ydO9e9b4heucsuuxhMbbi222+/3cyfP99FZqL8TTfd1LRs2dI8//zzjgAgOiUarRtssIHrG4IcEG2JcfHdd985bHiXocHKmKHslVZaKetawODOO+80999/v/nkk0+clgdjrEWLFq4d1LfVVluZ7bffvkHo7htuuMFMnDjRfP755+56N9tsM7PeeuuZqVOnZsqiX6j/3XffNR988IFzDIy/GK5x+eWXd+ZJvGv5zfXgp48+CJMPkBxjxowxjz/+uNN0oU2DBw82xx9/vMuXdUH/+cGYBcOZM2dmxuygQYNM165do5KncgyHylOmTDHPPfecAdd27dq5e+WLL75wffbll1+69tIHjB/+uKeJmMWY79y5sxk4cKDZZJNNstpDOvLOmjXLHQe3NBwsUwbRTr1ZF+1kHNBXtKlLly5uzNC2JMI4ZFy//fbbLtvaa6/tyllllVWSFJNJyzNn8uTJ7vmAphP4ca8+8sgjmXtn9dVXNyeccILp27dvJl/uF4gy+ufZZ591/cN1cf+QJw08c+urxd8vv/yyu3/pQ+5TnjnMmXHwLRECQkAICAEhUHEErN16yWInHoFVX8bwvew/O6EN7OSr5LY0l4x2ch1YP0k1dbnWP0JgFy/uz/pNqKm2N4fG2oVhs+6bF198MbALm8hnmCUpAkscVHwYXHPNNYHVCohsg12oB3axWNbz8aSTTgrs4iuyfLvQD6wWZtY1WkIsII/1P9IgD8/8kSNHBnbBnJUn6oclLwK78G1QBu8MSyQFlkCJyuaOWSIssIvayLy57xzquP7667PKon1nnHFG5DsKLCyBE6vs3LqK/QafUaNGBdxXCO2yBECsutZYY43ALg5dvjff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Hn744UR5uZemTJmSKI9PTNS97bff3v/M+wlRxD1/5plnmkceecRFt8ub2J7YZ599zE477eScq0PGFZJlllnG3HjjjYZ7XCIEhIAQEAJCQAgIgXpD4H/q7YJ0PUJACDRPBE4//XRz4YUXxiZiWOCyeNxyyy0LAoZmwp133mnWWmsts/POO5sxY8aYRx991BFHRx11lNP4KYf8Wbx4sWvHOeec4zSRhg4dasaOHeuiR8Uhf/BtktTfSviCe/ToYZ599lmz3nrrmeeee84t+sPn43xH6wmCg1De/fr1i5MlbxoW3hBJhQRijrDemNpFSefOnc3o0aPznvd5IADRDIGwQJuE3+WIxxBtqrBAjhXCdumllzYXXXSROfDAA8PZyv7evXt3Zxo5YsSIRBppED+094EHHnBaOXEbgt+c119/3Wk9xc0TTofmFNHDCoWPHzZsmCNlyffb3/7WRVvbbrvtwsVkvqOFh3bg+eef745x/2LSmc+/D/321FNPGTSAJEJACAgBISAEhIAQqEcElrDhWoN6vLB6vabBgwcbwkSzCK0VYff573//u2suCzt2WCXVgwCPALQ+6qVvPvnkEzNp0iTnHBkCpV27dm6hCNHy9ddfm9atW5s+ffq4ENUsIPMJDmMxR+EPE7C0QqizKIW4AG/CvZ922mmGkNa0DRO2n376yWD65QVSggUppAdpOM89BKmABhJmanxnsY4WC9dP+auuuqpr84cffuic37Zp08YRHJjA/PDDDwatH7QicjUuaMODDz7oypozZ44zmaGdmDKtvvrqrs04mwZbbz43cODALI0JFtEstOfPn+8IOdqHfPbZZ65NlIMmBuZs999/v/nggw8MJAjEA9oaq622miNkxo0bZ/BzBPZolqy99trmgAMOMHvvvbe7RvCgryGfvvvuO4dD//79za677uqulfO33HKLmTFjhnn//ffddUPW0e6NNtrIYQdOXigDTTLaTohx2se1t23b1nCNmAXdc889TkPLmwX+/ve/N2iAQd5AMJA+n4Dt5MmTzdSpU82CBQvcNUCe0YeMU2TmzJnm9ttvd5pUPDvpbwgRxg3fKZ/+5xogTDhGe/ENhVNk+n6zzTYz+NRBs8lrssybN8/ceuutZvbs2YZ7gXzc+zybuU5IEcYZeQYNGpRFGJGHNr311ltubFI/fcY44D6BTOUaTj755HyXnug4vq5OOukkp32Eo3McPjPWIXIwr4ySJ5980pnZ+TFHnzC+/dhr2bJlRtOPfmZcQHxyP0CgbrPNNgaytxwyN6pdOpYfAcYO92i4b/Kn1pnGRMD3DXXybM5HmjZmm1RXNgLcO7wP1DfZuFTDL/qGewhh/pCGS4BquK56aQNzJeYBtdo3zN9wO8FGJ/PdUkQEUCmoNWEeEUBNCH6dVl1vBFCp3QTpwoKbhT2kDyRJWoIZDkQBpA+kU9zJgO8b2gERBHklqS4EmEQw0VPfVFe/0Br6xkcKE8lQff3jSQb1TfX2DS0TAVR9/UOLRABVZ7/4vhEBVL39IwLIrimqt3vUMiEgBIRA5RCAXEGLxWv4QP5wLA1BYwHCx/8V0gpJoz6VIQSEgBAQAkJACAgBISAEhIAQKIaACKBiCOm8EBACdYMArL836+IzbGpVzkViooN2jyd88jmVLqcO5RUCQkAICAEhIASEgBAQAkJACJSDgAigctBTXiEgBKoaAVRwvUkXhE9afnzQ6PF+fCB90PiRCAEhIASEgBAQAkJACAgBISAEqhkBEUDV3DtqmxAQAokQQKMHp7ae9PH+PxIVEpEYR7q5fny8c92I5DokBISAEBACQkAICAEhIASEgBCoOgREAFVdl6hBQkAIxEUAnz347vF+fPDpk6YfH2/WhbaP/PjE7RWlEwJCQAgIASEgBISAEBACQqAaERABVI29ojYJASGQFwG0eryGD8QPobXTEPz2YM7lSR/8+kiEgBAQAkJACAgBISAEhIAQEAL1goAIoHrpSV2HEKhTBPDb4zV8+PShNcu9XDR6vNNmSB9C3UqEgBAQAkJACAgBISAEhIAQEAL1ioAIoHrtWV2XEKhRBPDjA9HjSZ///d//TeVK8NmDKZcnfX77298a+fFJBVoVIgSEgBAQAkJACAgBISAEhEANICACqAY6SU0UAvWMACZc3o8PpA/f05JlllkmY9IF+fM///M/aRWtcoSAEBACQkAICAEhIASEgBAQAjWFgAigmuouNVYI1D4COGkO+/EhaldafnyWWmqpLD8+/+//6RFX+yNGVyAEhIAQEAJCQAgIASEgBIRAGghodZQGiipDCAiBggj89NNPGZMutHx++eWXgunjnoTg8SZd+PGBAJIIASEgBISAEBACQkAICAEhIASEQEMERAA1xERHhIAQKBMBCJ6wHx8IoDQEE66wHx9MvOTHJw1kVYYQEAJCQAgIASEgBISAEBAC9Y5A3RFA//jHP8wdd9xh3n77bfPll1+aFVdc0XTt2tXsuuuukdoBP/zwg7n22msL9vMOO+xgVl999YJpwiffeecdc/fdd5uPP/7Y4Gi2S5cupm/fvmbVVVcNJ9N3IVA3CHg/Pj48O/dhWsI95EOzL7vssvLjkxawKkcICAEhIASEgBAQAkJACAiBZoVAXRFAH374oTn++OPN4sWLXSdiGsKx559/3kyZMsWMGzfOtG3bNquD58+fb+65556sY7k/1l9//dgEEGVRD8JilRDWr7/+urnrrrvM+eefbzbccMPc4vVbCNQcAvjxgTz1kbrw48OxNIRw7Ny7kD5o+8iPTxqoqgwhIASEgBAQAkJACAgBISAEmjsCdRMSB5OTs88+25E/m222mdPqmTZtmrniiiucBtBnn31mzj333Ab9/d5777ljG220kTnppJMi/9ZYY40G+aIOzJkzx1x22WVmySWXNKNHjzYPPfSQeeSRR8wxxxzjnN6eeOKJZuHChVFZdawOEWBMXn311aZnz56OyIDY6NatmxuHECdNLWioHXXUUU4zrUOHDmbllVc2AwcONNw3UUI4drTqIE1nzpxp3nrrLfPJJ584Eqgc8ufXv/61admypenUqZOBbEVjr2PHjma55ZYrSv7gTHrs2LFm4403NpiDoS206aabmksuucSUEj7+pZdeMnvuuafTHIR4gjDu3LmzadeunWsL5bdo0cJpE0Lwdu/e3YwfP94RvWB2/fXXm1VWWcVpKWGa5v8wXaOcqVOnRkGbOQZ5fdppp5l11lnH1UFdu+yyi9MozOcoe968eebggw929YJlmzZtXJ6nn346U+6//vUv079/f8N53yY+Idh4vnnseHZCYJdqskcbJ06caLbaaitH4OGTad111zWnn366+eaMVaxFAABAAElEQVSbbzLtoW/oo0022cT1GfXTh/QlfZq2PPzww2annXZy4wwMGF9c69pr///2zgTeymn//99UVESJDCWNhpQxU5Q04x+R4qIkGS66lDHXLP2ES1GaKFJk7DYYIkpEMlbGyJBIA1GaTOe/P+vete8+++zh2fvsc87e+7y/r9c5+9nrWWs9a73X8+xnPd/n+/2ufa1q1aqOQ8uWLW3kyJH2+++/xz28FJ36bdd5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xfFZu3atHX300fbxxx/HrHHKlCn21ltvOcuJ+vXrx8xDYu4R0DnWrVs3mzp1aszGa8xbtmxpzz33nLPeiZkpKlHnSo8ePUyWbtHy888/W//+/Z1i6MEHH4zeXWLf9913X/v000/j1v/CCy84S5XPP/88bh52JCbwyCOPWO/evYsoj1Xqxx9/tAsvvNA++eQTp+hOXBN7IQABCEAAAhCAAAQgUHoEUACVHutyc6RXXnmliPKndu3aJguLQw891P3tuOOOjoeCORdHKlWqVCiOjxRAyURv5uMpf3xZWS2ddtppNn/+fOe65tP5zF0Ccn+Kp/zxvZLb1KmnnmpffPGFyYInkSxfvtzOOuusmMqfyHLjxo1ziqVzzz03MrlEtmVxl0j54w+q/sl6RZZuSGoElixZYhrLZErrYcOG2VFHHWXdu3dP7QDkhgAEIAABCEAAAhCAQAkR+I8/TAlVTrXlk8Att9xSpON9+/a16667zjp16mRe+VMkU4AEuXApaPMee+xh++23n4sp1LhxY5OCKYjyR4qfJ598MsCRzBYsWGCylkByn4Di8tx+++2BOiILjvvvvz9p3rvuusui3cjiFbr55ptN8WJKWu69997Ahxg9enTgvGT8HwGdR0ED0WvcEQhAAAIQgAAEIAABCGQLARRA2TISedKO9evX29y5c4v05u233y6SFjRBQXp3220322effezggw92n/qudAV2TkVSjX0idyAk9wkoELLiPgWVZ599NmnWIHl8Jd9++6199NFH/muJfMq1MqhiQg2Q25osgZDUCKQy7hrzZcuWpXYAckMAAhCAAAQgAAEIQKCECOACVkJgy2u1cp2KZekgBZDSgyhstJqOX55dn3LzypSk+jCmB3ck9wmkOo5B8qdzLjVr1qzEYCrIc6ryxhtvmCzokGAEfvvtN1u1alWwzP/NpXOJlQVTQkZmCEAAAhCAAAQgAIESIpC5J+sSaiDV5hYBrbQVSxQQV0Fn99prryK7K1as6OKteKVPEFeuIpUETNAxUpF4/UmlDvKWPYFUxzFI/h122MFWr14duHNB6gxcWYyM6axah2IiBsgESVtvvbVb4l2KoKBS0uMetB3kgwAEIAABCEAAAhCAAAogzoGMEtBDaN26dU0BcqNFVkBSACluyvvvv2/6rngrM2fOjM5aYt8ViDoVOeKII1LJTt4sJVAS4646o5daj9d9KQ5SXV4+Xl3x0lPto+rRqmdIagT0mxDLzTVWLVI4a1U2BAIQgAAEIAABCEAAAtlAgBhA2TAKedYGLYEcS7Rktlbgat++vQ0YMMAee+wx+3//7//FylpiaR07drSgS7vr4e30008vsbZQcekRqFOnjnXp0iXwAXWeJpN453mscj179rTtttsu1q6MpSlAetOmTQPX16RJE2fNErgAGR2BVMa9T58+VrlyZchBAAIQgAAEIAABCEAgKwigAMqKYcivRki5c8ghhxTplGJhfPDBB/bnn3+6fa1atbJUHqaKVJhGgiwxHnjgAZPbWTLRikq1atVKlo39OUJAy3IHWYHu0ksvtcMOOyxpr0444QT729/+ljSfVqwbPHhw0nyZyDBnzhyTIiiZKE9QK5ZkdZW3/VIKB1EmSsF24403ljc89BcCEIAABCAAAQhAIIsJJH9SyOLG07TsJFC1alW3fHqbNm3iNvC4446zadOmlcnb8Xbt2pmskRTDJZYoBtGYMWPs7LPPjrWbtBwl0KBBA5s9e7bpM55Iefmvf/0r3u4i6ePHjzdZecST5s2bu2PWrl07XpaMpu+88862YMGChNeVgqprVbRdd901o8cuL5UpkP3kyZPttNNOi9vlFi1a2Msvv+xim8XNxA4IQAACEIAABCAAAQiUMgFiAJUy8Ewc7q+//nJLOGeirpKqo0aNGvbSSy85Jc+jjz5qn376qVsBbL/99rOzzjrLOnfu7A6tpajLQqSA+uyzz2zs2LHuQW3lypXO2kdWSeedd57JaqOs2lbaPPyqbbLMyvc+y0Vq8eLF9vDDD7v4PVrJa9tttzU9sJ9zzjkuTo94BOUgS7LRo0db7969XZ0LFy60zZs3W8OGDa1r167OQkgKl6D1RY+9HxulB23XAQccYL/++qv16tXLpk+fbps2bXLVSjF7/PHH26RJk5yVULptim5jefwuS8KJEye634px48bZhx9+6MZHK6p169bNunfvDuMsODEir5/y8PuWBchTaoK3BmZsUsJWKpn92OhgQe89pdIwDhImoHFhbMI4smoj8t6juVYQy+ys6kCeN8b/vuXq2Pj5e+R5luqQVQgVLki1EPnLjoBcDxo1amRXX3112TWCI0MAAhCAAAQgAAEIQAACEIAABCBQagS2bNlinTp1sltvvdV69OiR1nGxAEoLW9kVkhZZLko1a9Ysu0akeGRZRHgrhGrVqrn2p1gF2UuQgHTAP//8szE2JQg5zar92Ki4rI0UmBzJLgIbNmxwcc0Ym+waF7VGY/Pbb7+5hlWvXt1kjYdkDwG9xVy/fr0xNtkzJr4lfmz0XYHsS3oRA39cPoMTWLdunbMsYWyCMyutnBobb2WicBNYAJUW+WDH0bxA84NcHRspgCQKSZCuMBtKl1wZldNg60GwSpUqZdSC1A/rTdVUUhOJXGp76r3NvRLeCJCxyb6x82Ojluna59rJvjGSgltuuYxNdo6Nb5Xc9vSHZA+B33//3SmAGJvsGRPfEj82+p5rc07fh3z/lKs3Y5Odo6yx8QogzQ1QAGXXOPm5da6OjVf8+M906BIEOh1qlIEABCAAAQhAAAIQgAAEIAABCEAAAjlEAAVQDg0WTYUABCAAAQhAAAIQgAAEIAABCEAAAukQQAGUDjXKQAACEIAABCAAAQhAAAIQgAAEIACBHCKAAiiHBoumQgACEIAABCAAAQhAAAIQgAAEIACBdAigAEqHGmUgAAEIQAACEIAABCAAAQhAAAIQgEAOEUABlEODRVMhAAEIQAACEIAABCAAAQhAAAIQgEA6BFAApUONMhCAAAQgAAEIQAACEIAABCAAAQhAIIcIoADKocGiqRCAAAQgAAEIQAACEIAABCAAAQhAIB0CKIDSoUYZCEAAAhCAAAQgAAEIQAACEIAABCCQQwRQAOXQYNFUCEAAAhCAAAQgAAEIQAACEIAABCCQDgEUQOlQowwEIAABCEAAAhCAAAQgAAEIQAACEMghAiiAcmiwaCoEIAABCEAAAhCAAAQgAAEIQAACEEiHAAqgdKhRBgIQgEAAAuvWrbM77rjDWrdubfXr17dmzZrZueeea/Pnzw9QunhZnn32WevRo4fts88+1qhRI+vUqZONGTPGfv/99+JVXEqlZ8yYUaj9nTt3trFjx+ZM+0sJE4eBAAQgAAEIQAACEIBAYAKVAuckIwQgAAEIBCYwb948O+WUU2zVqlWFynz00Uc2btw4u+SSS2zo0KFWsWLFQvuL+2X9+vV25pln2vTp0wtV9eWXX9qLL77ojjlt2jRr3Lhxof3Z8kVKM7VfCqBIUftnzpxp99xzj+ublFoIBCAAAQhAAAIQgAAEIBCcABZAwVmREwIQgEAgAlLyyOImWvkTWXj48OHWv3//yKRib//111926qmnFlH+RFb8ySefWLt27WzNmjWRyVmxrfZ369atiPInsnFqf9u2bbOy/ZHtZBsCEIAABCAAAQhAAALZRgAFULaNCO2BAARynsBFF11kGzZsSNqP++67z95+++2k+YJmmDRpkrPySZZ/2bJldv311yfLVur7H3nkEZs1a1bS46r9N9xwQ9J8ZIAABCAAAQhAAAIQgAAE/kcABdD/WLAFAQhAoNgElixZYnPnzg1czwMPPBA4b7KMipETVCZMmGCbN28Omr1U8qXa/i1btpRKuzgIBCAAAQhAAAIQgAAE8oEACqB8GEX6AAEIZA2BVC16Us2fqKMLFixItLvQvo0bN5rcqbJJUmEhC6tsa382saQtEIAABCAAAQhAAAIQiCaAAiiaCN8hAAEIFINAENevyOpTzR9ZNnL7jz/+sFQtYn799dfIKsp0W6uT/fbbbym1IVPsUjoomSEAAQhAAAIQgAAEIJCjBFAA5ejA0WwIQCA7Cey5554pNSzV/PEqr1SpktWpUyfe7pjpmTp2zMpTTKxcubLttttuKZXKpvan1HAyQwACEIAABCAAAQhAoAwIoAAqA+gcEgIQyF8CrVu3turVqwfuYJcuXQLnTZYxlbr2339/q1evXrIqS3V/Ku0/8MADrW7duqXaPg4GAQhAAAIQgAAEIACBXCaAAiiXR4+2QwACWUegatWqNnDgwEDt2mOPPezcc88NlDdIpquvvtp0/CByyy23BMlWqnmuueYaq1KlSqBj3nzzzYHykQkCEIAABCAAAQhAAAIQ+A8BFECcCRCAAAQyTECKmFNOOSVhrTvssINNmTLFqlWrljBfKjvr169vEydONLmDJZJrr73WTjrppERZymRfgwYNArX/n//8p5144oll0kYOCgEIQAACEIAABCAAgVwlgAIoV0eOdkMAAllLYKuttrInn3zShgwZYlL0REvnzp3tnXfesUMOOSR6V7G/S/GkZehj1a0YQVIQ3XbbbcU+TklV0K1bN3v11Vdjtl8uX5MmTbJBgwaV1OGpFwIQgAAEIAABCEAAAnlLIPFr4hzstlaFmTx5slseeNWqVS6oqGJdnHrqqbbNNtvE7NGPP/5oTzzxhC1dutRWrlxptWvXNr2JPu2002znnXeOWSZe4uzZs23RokXxdttOO+1kZ555Ztz97IAABPKD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d6XHkh9//NGWLl3qdu2333627bbbxspmmzZtcv359NNP7bPPPrMqVaq4tql9TZs2ta224r1hTHAkQgACEIAABHKEAAqgHBkomgkBCEAAAhCAQNkQmDBhgv3555/u4F27dnWff/vb3+zKK6906SNHjgykAHrhhRfs0ksvdUqW6J40aNDAhgwZYt27d3e7xo8fb9ddd104m5Q9hx9+uPt+2WWX2T333OMUSD7tzjvvtCuuuCKcP3Lj2WeftbPPPtslSYl06KGHRu5227JkUvlff/21yD4l6DgPPPCANWvWLOZ+EiEAAQhAAAIQyH4CKICyf4xoIQQgAAEIQAACZUjAr/61zz772GGHHeZaImsbWQNJuTJ16lSnjNltt93itvL++++3fv362V9//WUVK1Y0uZJJmaLl3T///HP76quv7LTTTnP7TjnlFFNdLVq0MC2z7mMPHXLIIa7+PfbYI+5xUt0hy6ITTjjBnn/+eVd09913tyOOOMJ23HFHkxWSFEZr1qyxt956y4488khbtmyZ1axZM9XDkB8CEIAABCAAgSwggC1vFgwCTYAABCAAAQhAIDsJzJ0717744gvXuN69exdq5DnnnOO+//HHHzZ27NhC+yK/yKVqwIABTvlTp04dmz17tr3zzjsugLRcyObPn2/Vq1d3sYR69epl69atsz59+tjbb79t3bp1c1VtvfXW7rvSVFemRIofr/y5+OKL7euvv7ann37a9UfKLSmmfL9lHTRq1KhMHZp6IAABCEAAAhAoZQIogEoZOIeDAAQgAAEIQCB3CHjrH1nt9OzZs1DDu3TpYrVq1XJpUgB5N7FCmUJfBg0aZFu2bHHJjz32mLVq1apQFrlXXXXVVS5tw4YNTgFTKEMJfhk2bJirvW7duqbtyDhE2rHddtuZVj2rVOk/RuOyBEIgAAEIQAACEMhNAriA5ea40WoIQAACEIAABEqYwPr16+3JJ590R+nQoYPJPSpSZJVzxhln2H333ecCNmup+JNOOikyi8k6SJY0kmOPPbaI8sdnllWPXL0aNmxoBx10kE8u8c/bb7/d+vbtazVq1HDuZ7EOqKDRUhDJOihejKBY5UiDAAQgAAEIQCC7CKAAyq7xoDUQgAAEIAABCGQJgccff9w2btzoWuODKEc3Te5RUgBJFAw6WgH0ySef2M8//+z2a/n4eFKtWjVngRNv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" width="576" /></p>
<!-- Make title of bibliography here: -->
<!-- \newpage -->
<div class="page-break-after"></div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs">

</div>
</div>
<div id="appendix" class="section level1 unnumbered">
<h1>Appendix</h1>
<div id="appendix-a" class="section level2 unnumbered">
<h2>Appendix A</h2>
<p>Some appendix information here</p>
</div>
<div id="appendix-b" class="section level2 unnumbered">
<h2>Appendix B</h2>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
